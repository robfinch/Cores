; ============================================================================
;        __
;   \\__/ o\    (C) 2020-2022  Robert Finch, Waterloo
;    \  __ /    All rights reserved.
;     \/_//     robfinch<remove>@finitron.ca
;       ||
;  
;
; BSD 3-Clause License
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met:
;
; 1. Redistributions of source code must retain the above copyright notice, this
;    list of conditions and the following disclaimer.
;
; 2. Redistributions in binary form must reproduce the above copyright notice,
;    this list of conditions and the following disclaimer in the documentation
;    and/or other materials provided with the distribution.
;
; 3. Neither the name of the copyright holder nor the names of its
;    contributors may be used to endorse or promote products derived from
;    this software without specific prior written permission.
;
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;
; ============================================================================

;	bss
;	align 4
;FreeMsg	dw	0
;msgs:
;	fill.b	MSG_SIZE*1024,0
;mbxs:
;	fill.b	MBX_SIZE*32,0
;mbxs_end:

;------------------------------------------------------------------------------
; Convert a mailbox handle to a pointer.
;------------------------------------------------------------------------------

MBXHandleToPointer:
	decd
	muld	#MBX_SIZE
	tfr		w,d
	addd	#32
	addd	#mailboxes
	rts

;------------------------------------------------------------------------------
; Convert a message handle to a pointer.
;------------------------------------------------------------------------------

MSGHandleToPointer:
	decd
	muld	#MSG_SIZE
	tfr		w,d
	addd	#32
	addd	#messages
	rts

;------------------------------------------------------------------------------
; Remove the task from the list of tasks waiting at the mailbox.
;
; Parameters:
;		D = task id
;------------------------------------------------------------------------------

MbxRemoveTask:
	lbsr	TCBHandleToPointer
	tfr		d,x
0001:
	ldd		#-1
	lbsr	LockSysSemaphore
	beq		0001b
	ldw		TCBMbxNext,x
	ldd		TCBMbxPrev,x
	beq   mrtAtHead
	pshs	d											; save D
	lbsr	TCBHandleToPointer		; convert to pointer
	tfr		d,y
	stw		TCBMbxNext,y					; prev->next = next
	tfr		w,d
	beq		mrtAtTail
	lbsr	TCBHandleToPointer
	tfr		d,y
	puls	d
	std		TCBMbxPrev,y					; next->prev = prev
	clrd
	std   TCBMbxPrev,x
	std  	TCBMbxNext,x
  lbra	UnlockSysSemaphore
mrtAtHead:
	ldw		TCBWaitMbx,x					; get mailbox handle
	cmpw	#1										; is the handle good?
	lblo	UnlockSysSemaphore
	cmpw	#NR_MBX
	lbhs	UnlockSysSemaphore
	exg		w,d
	bsr		MBXHandleToPointer		; convert to pointer
	tfr		d,y
	cmpw	MBX_TQHEAD,y					; should be the same
	lbne	UnlockSysSemaphore
	exg		w,d
	tstd
	beq   mrtTqEmpty
	ldd		TCBMbxNext,x
	std		MBX_TQHEAD,y					; mailbox TQ head = next
	lbsr	TCBHandleToPointer
	tfr		d,y
	clrd
	std		TCBMbxPrev,y					; next->prev = null
mrtTqEmpty:
	clrd
	std   TCBMbxPrev,x
	std  	TCBMbxNext,x
	lbra	UnlockSysSemaphore
mrtAtTail:
	ldw		TCBWaitMbx,x
	cmpw	#1										; is the handle good?
	lblo	UnlockSysSemaphore
	cmpw	#NR_MBX
	lbhs	UnlockSysSemaphore
	exg		w,d
	bsr		MBXHandleToPointer
	tfr		d,y
	cmpw	MBX_TQTAIL,y
	lbne	UnlockSysSemaphore
	exg		w,d
	tstd
	beq		mrtTqEmpty
	ldd		TCBMbxPrev,x
	std		MBX_TQTAIL,y
	lbsr	TCBHandleToPointer
	tfr		d,y
	clrd
	std		TCBMbxNext,y
	bra		mrtTqEmpty

;------------------------------------------------------------------------------
; FMTK_AllocMbx
;   Allocate a mailbox. Get the mailbox off the free list. If there are no
; free mailboxes then allocate a block of new mailboxes.
;
; Parameters:
;		D = app id of owner
; Returns:
;		X = E_Ok
;   D = mailbox handle
;------------------------------------------------------------------------------

FMTK_AllocMbx:
0001:
	ldd		#-1
	lbsr	LockSysSemaphore
	beq		0001b
	ldd		FreeMbx
  bne   amGotMbx
  lbsr	UnlockSysSemaphore
  ldx		#E_NotAlloc
  stx		7,s
  lbra	OSExit
amGotMbx: 
	tfr		d,w										; save mailbox handle
	bsr		MBXHandleToPointer
	tfr		d,x
	ldd		MBX_LINK,x
	std		FreeMbx
	lbsr	UnlockSysSemaphore
	clrd
	std		MBX_LINK,x
	stb   MBX_TQHEAD,x
	stb   MBX_TQTAIL,x
	std   MBX_MQHEAD,x
	std   MBX_MQTAIL,x
	ldb		2,s
	stb		MBX_OWNER,x
	tfr		w,d
	std		1,s
	ldx		#E_Ok
	stx		7,s
	lbra	OSExit

;------------------------------------------------------------------------------
; Dequeue any waiting tasks returning to them a E_NoMsg status and removing
; them from the timeout list as well. Then move any messages that are queued
; back to the free message list.
;
; Parameters:
;		D = mailbox handle
;------------------------------------------------------------------------------

FMTK_FreeMbx:
	cmpd	#1
	blo		fmBadMbx
	cmpd	#NR_MBX
	bhs		fmBadMbx
	tfr		d,w											; save D in W
  bsr		MBXHandleToPointer
  tfr		d,x											; X = pointer to mailbox being freed
0004:
  ldd		#-1
  lbsr	LockSysSemaphore
  beq		0004b
  ldd   FreeMbx
  std   MBX_LINK,x
  stw   FreeMbx
FreeMbx1:
	ldb		MBX_TQHEAD,x
0002:
  tstb
	beq 	0001f
	clra
	lbsr	TCBHandleToPointer
	tfr		d,x
	aim		#~TS_WAITMSG,TCBStatus,x	; no longer waiting
	clra
	ldb   TCBtid,x
	tim		#TS_TIMEOUT,TCBStatus,x   ; Is the task timing out?
	beq	  0003f
	lbsr	RemoveFromTimeoutList			; Remove from the timeout list
0003:
	lbsr 	InsertIntoReadyQueue
	ldx		#E_NoMsg					; but no message
	stx		TCBxXR,x					; XR = E_NoMsg
	ldb   TCBMbxNext,x
	pshs	b
	lbsr	TCBHandleToPointer
	tfr		d,u
	clrd
	std   TCBMbxNext,x
	std   TCBMbxPrev,x
	tfr		u,x
	puls	b
	bra   0002b
0001:
  clr   MBX_TQHEAD,x
  clr   MBX_TQTAIL,x
  ; Now free any messages queued at the mailbox. We are crafty here and
  ; don't follow any links. Instead the entire chain of messages queued
  ; is transferred to the free message list.
  ldd   MBX_MQTAIL,x 				; get pointer to last message
  bsr		MSGHandleToPointer
  tfr		d,y
  ldd   FreeMsg
  std   MSG_LINK,y   				; link current free list onto it
  ldd   MBX_MQHEAD,x
  std   FreeMsg         		; set new head of free list
  lbsr	UnlockSysSemaphore
	ldx		#E_Ok
	stx		7,s
	lbra	OSExit
fmBadMbx:
	ldx		#E_BadMbx						; return null pointer if bad mailbox
	stx		7,s
	lbra	OSExit


;------------------------------------------------------------------------------
; AllocMsg
;
; This internally used routine to provide message space to store data in.
; First the free list is checked to see if any messages are available.
; If there are no message available then a block of 408 messages is allocated
; and added to the free list. 408 messages fit nicely into a 16kB memory page.
;
; Parameters:
;   none
; Returns:
;   $a0 = status (E_Ok)
;   $a1 = pointer to message
;------------------------------------------------------------------------------

AllocMsg:
0002:
	ldd		#-1
  lbsr	LockSysSemaphore
  beq		0002b
  ldd  	FreeMsg
  bne   .gotMsg
  ; no free messages?
  ldd		#8160
  swi2
  fcb		OSF_AllocMem
  cmpx	#E_Ok
  bne   .outOfMem
  ldi   $t0,#680           ; 680 messages in block
  tfr		d,x
  ; Initialize object fields
  ldw   #MSG_MAGIC
  stw   OBJMagic,x
  ldw   #8192
  stw   OBJSize,x
  clr   OBJState,x
  clr   OBJScavcnt,x
  clr   OBJOwningMap,x
  ldw   #MsgFinalizer
  stw   OBJFinalizer,x
 
  add   $t1,$a0,#64       ; point to first message
  sto   $t1,FreeMsg
  mov   $a0,$t1
0001:
  add   $t2,$t1,#MSG_SIZE
  sto   $t2,MSG_LINK[$t1]
  mov   $t1,$t2
  sub.  $t0,$t0,#1
  bgt   0001b
  sto   $x0,MSG_LINK[$t1]
.gotMsg:
	std		1,s								; return MSG handle
	bsr		MSGHandleToPointer
	tfr		d,x
  ldw   MSG_LINK,x
  stw   FreeMsg
  clrw
  stw   MSG_LINK,x
  lbsr	UnlockSysSemaphore
  ldx   #E_Ok
  stx		7,s
  lbra	OSExit
.outOfMem:
  lbsr	UnlockSysSemaphore
  ldx   #E_NoMem
  stx		7,s
  lbra	OSExit

;------------------------------------------------------------------------------
; FreeMsg
;
; This internally used routine frees a message previously allocated with
; AllocMsg. The message is added to the free list. Must be called only
; when system semaphore is locked.
;
; Parameters:
;   D = message handle
; Returns:
;   none
;------------------------------------------------------------------------------

FreeMsgRout:
  pshs	d,y
  bsr		MSGHandleToPointer
  tfr		d,y
  ldd   FreeMsg
  std   MSG_LINK,y
  puls	d,y
  std   FreeMsg
  rts

;------------------------------------------------------------------------------
; Send a message to a mailbox.
; The message will be broadcast to any waiting tasks. Waiting tasks will then
; be moved to the ready list. If there are no waiting tasks then the message
; is queued at the mailbox.
;
; Register Usage:
;		$t0 = mailbox pointer
;		$t1 = message pointer
;		$s1 = task id of waiting task
; Modifies:
;		$a0
; Parameters:
;		$a1 = mailbox handle
;		$a2 = message d1
;		$a3 = message d2
;		$a4 = message d3
;------------------------------------------------------------------------------
  align 16
ISendMsg:
;  mEI
;	slt		$t0,$a1,#32
;	beq		$t0,$x0,.badMbx
;	sll		$t0,$a1,#4					; convert handle to pointer
;	add		$t0,$t0,#mbxs
  mov   $a0,$a1
  mMbxHandleToPointer
  mov   $t0,$a0
	ldt.	$s3,MBX_TQHEAD[$t0]
	beq		.noWaiters
	sto		$a2,TCBMsgD1[$s3]		; copy message to TCB
	sto		$a3,TCBMsgD2[$s3]
	sto		$a4,TCBMsgD3[$s3]
	ldbu	$t2,TCBStatus[$s3]
	or		$t2,$t2,#TS_MSGRDY
	stb		$t2,TCBStatus[$s3]
	ldwu  $a0,TCBtid[$s3]
	sub		$sp,$sp,#8
	sto		$t0,[$sp]						; push t0
	call	InsertIntoReadyQueue
	ldo		$t0,[$sp]						; pop t0
	add		$sp,$sp,#8
	ldo   $s5,TCBMbxNext[$s3]
	sto   $x0,TCBMbxNext[$s3]
	sto   $x0,TCBMbxPrev[$s3]
	sto   $s5,MBX_TQHEAD[$t0]
	ldi		$a0,#E_Ok
	jmp   .xit
.noWaiters:
  jsr   AllocMsg
  tst   $a0
	bne	  .noMsg			    ; message available?
	sto		$a2,MSG_D1[$a1]
	sto		$a3,MSG_D2[$a1]
	sto		$a4,MSG_D3[$a1]
	ldo.	$t3,MBX_MQTAIL[$t0]
	beq	  .mbxEmpty
	sto		$a1,MSG_LINK[$t3]
	sto		$a1,MBX_MQTAIL[$t0]
	ldi		$a0,#E_Ok
	jmp   .xit
.mbxEmpty:
	sto		$a1,MBX_MQHEAD[$t0]
	sto		$a1,MBX_MQTAIL[$t0]
	ldi		$a0,#E_Ok
	jmp   .xit
.noMsg:
	ldi		$a0,#E_NoMsg
	jmp   .xit
.badMbx:
	ldi		$a0,#E_BadMbx				; return null pointer if bad mailbox
.xit
	ret

  align 16
FMTK_SendMsg:
  chk.  $a1,$x0,#4096
  bf    .badMbx
  mDI
  jsr   ISendMsg
  mEI
  jmp   OSExit
.badMbx:
  ldi   $a0,#E_BadMbx
  jmp   OSExit

;------------------------------------------------------------------------------
; Parameters:
;		D = mailbox handle
;		X = pointer where to put message D1
;		Y = pointer where to put message D2
;		U = pointer where to put message D3
;		E = 1 = remove from queue
;------------------------------------------------------------------------------

PeekMsg:
;	slt		$t0,$a1,#32
;	beq		$t0,$x0,.badMbx
;	sll		$t2,$a1,#4					; convert handle to pointer
;	add		$t2,$t2,#mbxs
	puls	u										; U = return address
	ldd		1,s
	bsr		MBXHandleToPointer
	tfr		d,x
	orcc	#$290								; disable interrupts
	ldd		MBX_MQHEAD,x
	beq	  pmNoMsg
	tst   3,s
	beq 	pmNodq
	bsr		MSGHandleToPointer
	tfr		d,y
	ldd		MSG_LINK,y
	std		MBX_MQHEAD,x
	; This is done here only because interrupts are disabled
	tfr		y,d
	bsr  	FreeMsgRout
pmNodq:
  ; Makes use of the MPRV feature. PeekMsg() or WaitMsg() will be running in
  ; the task context expecting to receive a message. That means the base
  ; registers and ASID should be set appropriately.
	ldi   $a1,#$20000       ; bit 17 = mprv
  ldb   $a0,TCBmid[$t1]   ; $a0 = mid
  tst   $a2
	beq   .nod1
	ldo		$t3,MSG_D1[$t1]
	csrrs $x0,#CSR_MSTATUS,$a1
	sto		$t3,[$a2]
	csrrc $x0,#CSR_MSTATUS,$a1
.nod1:
  tst   $a3
	beq	  .nod2
	ldo		$t3,MSG_D2[$t1]
	csrrs $x0,#CSR_MSTATUS,$a1
	sto		$t3,[$a3]
	csrrc $x0,#CSR_MSTATUS,$a1
.nod2:
  tst   $a4
	beq	  .nod3
	ldo		$t3,MSG_D3[$t1]
	csrrs $x0,#CSR_MSTATUS,$a1
	sto		$t3,[$a4]
	csrrc $x0,#CSR_MSTATUS,$a1
.nod3:
	ldi		$a0,#E_Ok
	jmp		.ret
pmNoMsg:
	ldx		#E_NoMsg
	stx		7,s
	andcc	#$D6F								; enable interrupts
	jmp		,u
pmbadMbx:
	ldx		#E_BadMbx						; return null pointer if bad mailbox
	stx		7,s
	jmp		,u
.ret:
  mEI
	ret

;------------------------------------------------------------------------------
; PeekMsg will check for a message at a mailbox optionally dequeuing it.
; If no message is available PeekMsg returns to the caller with a E_NoMsg
; status.
;
; Parameters:
;		D = mailbox handle
;		X = pointer where to put message D1
;		Y = pointer where to put message D2
;		U = pointer where to put message D3
;		E = 1 = remove from queue
;------------------------------------------------------------------------------

FMTK_PeekMsg:
  cmpd	#1
  blo		fpmBadMbx
  cmpd	#NR_MSG
  bhs		fpmBadMbx
	bsr 	PeekMsg
	lbra	OSExit
fpmBbadMbx:
  ldx   #E_BadMbx
  stx		7,s
  lbra  OSExit

;------------------------------------------------------------------------------
; Calling WaitMsg will cause the task to be queued at the mailbox and a task
; switch to occur if there are no messages at the mailbox.
;
; Parameters:
;		a1 = mailbox handle
;		a2 = pointer where to put message D1
;		a3 = pointer where to put message D2
;		a4 = pointer where to put message D3
;		a5 = time limit
;------------------------------------------------------------------------------
  align 16
FMTK_WaitMsg:
  chk.  $a1,$x0,#4096
  bf    .badMbx
	mov		$s5,$a5
	ldi		$a5,#1              ; dequeue messages
	call 	PeekMsg							; check for a message, return if available
	seq		$a0,#E_NoMsg
	bt		.qt					        ; no message? Then go queue task
	jmp		OSExit
.qt:
  mov   $a0,$a1
  mMbxHandleToPointer
  mov   $t3,$a0
	mGetCurrentTid
	asl		$t1,$a0,#LOG_TCBSZ  ; $t1 = tcb pointer
;	sll		$t3,$a1,#5					; convert handle to pointer
;	add		$t3,$t3,#mbxs
  mDI
	ldo.	$t4,MBX_TQTAIL[$t3]	; get waiting task list tail
	beq   .qempty
  sto   $t4,TCBMbxPrev[$t1] ; add task onto tail of waiting list
  sto   $t1,TCBMbxNext[$t4] ; tail->next = tid tcb pointer
  sto   $t1,MBX_TQTAIL[$t3]
  jmp   .setA
.qempty:
  sto   $t1,MBX_TQHEAD[$t3]
  sto   $t1,MBX_TQTAIL[$t3]
.setA:
  sto   $a2,TCBxA2[$t1]   ; save pointers for data in task regs
  sto   $a3,TCBxA3[$t1]
  sto   $a4,TCBxA4[$t1]
	ldbu	$t3,TCBStatus[$t1]
	or		$t3,$t3,#TS_WAITMSG	; set waiting for message status
	and		$t3,$t3,#~TS_READY	; not ready
	stb		$t3,TCBStatus[$t1]
	stb		$a1,TCBWaitMbx[$t1]	; set mailbox task is waiting for
	mEI
	jmp		FMTK_Sleep          ; Continue by switching tasks
.badMbx:
  ldi   $a0,#E_BadMbx
  jmp   OSExit

MsgFinalizer:
  ret
