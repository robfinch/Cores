3 error(s), 526 warning(s) unlisted in pass 1
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2013-2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; BSD 3-Clause License
                              ; Redistribution and use in source and binary forms, with or without
                              ; modification, are permitted provided that the following conditions are met:
                              ;
                              ; 1. Redistributions of source code must retain the above copyright notice, this
                              ;    list of conditions and the following disclaimer.
                              ;
                              ; 2. Redistributions in binary form must reproduce the above copyright notice,
                              ;    this list of conditions and the following disclaimer in the documentation
                              ;    and/or other materials provided with the distribution.
                              ;
                              ; 3. Neither the name of the copyright holder nor the names of its
                              ;    contributors may be used to endorse or promote products derived from
                              ;    this software without specific prior written permission.
                              ;
                              ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                              ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                              ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                              ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                              ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                              ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                              ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                              ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                              ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                              ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                              ;                                                                          
                              ; ============================================================================
                              ;
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2013-2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; BSD 3-Clause License
                              ; Redistribution and use in source and binary forms, with or without
                              ; modification, are permitted provided that the following conditions are met:
                              ;
                              ; 1. Redistributions of source code must retain the above copyright notice, this
                              ;    list of conditions and the following disclaimer.
                              ;
                              ; 2. Redistributions in binary form must reproduce the above copyright notice,
                              ;    this list of conditions and the following disclaimer in the documentation
                              ;    and/or other materials provided with the distribution.
                              ;
                              ; 3. Neither the name of the copyright holder nor the names of its
                              ;    contributors may be used to endorse or promote products derived from
                              ;    this software without specific prior written permission.
                              ;
                              ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                              ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                              ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                              ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                              ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                              ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                              ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                              ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                              ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                              ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                              ;                                                                          
                              ; ============================================================================
                              ;
                              CR      EQU     $0D             ;ASCII equates
                              LF      EQU     $0A
                              TAB     EQU     $09
                              CTRLC   EQU     $03
                              CTRLH   EQU     $08
                              CTRLI   EQU     $09
                              CTRLJ   EQU     $0A
                              CTRLK   EQU     $0B
                              CTRLM   EQU $0D
                              CTRLS   EQU     $13
                              CTRLT EQU $14
                              CTRLX   EQU     $18
                              CTRLZ   EQU     $1A
                              XON             EQU     $11
                              XOFF    EQU     $13
 
                              FIRST_CORE      EQU     1
                              MAX_TASKNO      EQU 63
                              DRAM_BASE       EQU $10000000
 
                              ; ROM monitor functions
                              ;
                              MF_Monitor      EQU             0
                              MF_INCH                 EQU             1
                              MF_OUTCH                EQU     2
                              MF_CRLF                 EQU             3
                              MF_DisplayString        EQU             4
                              MF_DisplayByteAsHex             EQU     5
                              MF_DisplayWordAsHex             EQU     6
                              MF_ShowSprites  EQU             7
                              MF_Srand                EQU             8
                              MF_Random               EQU             9
                              MF_OSCALL               EQU             10
                              MF_GetRange     EQU             11      ; gets a pair of numbers last>first
                              MF_GetNumber    EQU     12
 
                              mon_numwka      EQU             $910
                              mon_r1          EQU             $920
                              mon_r2          EQU             $924
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) S2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; BSD 3-Clause License
                              ; Redistribution and use in source and binary forms, with or without
                              ; modification, are permitted provided that the following conditions are met:
                              ;
                              ; 1. Redistributions of source code must retain the above copyright notice, this
                              ;    list of conditions and the following disclaimer.
                              ;
                              ; 2. Redistributions in binary form must reproduce the above copyright notice,
                              ;    this list of conditions and the following disclaimer in the documentation
                              ;    and/or other materials provided with the distribution.
                              ;
                              ; 3. Neither the name of the copyright holder nor the names of its
                              ;    contributors may be used to endorse or promote products derived from
                              ;    this software without specific prior written permission.
                              ;
                              ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                              ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                              ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                              ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                              ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                              ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                              ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                              ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                              ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                              ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                              ;                                                                          
                              ; ============================================================================
 
                              COREID  EQU             $FFFFFFFE0
                              MSCOUNT EQU             $FFFFFFFE4
                              LEDS            EQU             $FFFE60001
                              VIA                     EQU             $FFFE60000
                              VIA_PA          EQU             1
                              VIA_DDRA        EQU             3
                              VIA_ACR                 EQU             11
                              VIA_IFR                 EQU             13
                              VIA_IER                 EQU             14
                              VIA_T3LL                EQU             18
                              VIA_T3LH                EQU             19
                              VIA_T3CMPL      EQU             20
                              VIA_T3CMPH      EQU             21
                              TEXTSCR         EQU             $FFFE00000
                              TEXTREG         EQU             $FFFE07F00
                              TEXT_COLS       EQU             0
                              TEXT_ROWS       EQU             1
                              TEXT_CURPOS     EQU             34
                              COLS            EQU             64
                              ROWS            EQU             32
                              ACIA            EQU             $FFFE30100
                              ACIA_TX         EQU             0
                              ACIA_RX         EQU             0
                              ACIA_STAT       EQU             1
                              ACIA_CMD        EQU             2
                              ACIA_CTRL       EQU             3
                              ACIA_CTRL2      EQU             11
                              RTC                             EQU             $FFFE30500      ; I2C
                              RTCBuf          EQU             $7FC0
                              PRNG            EQU             $FFFE30600
                              KEYBD           EQU             $FFFE30400
                              KEYBDCLR        EQU             $FFFE30402
                              PIC                     EQU             $FFFE3F000
                              SPRITE_CTRL             EQU             $FFFE10000
                              SPRITE_EN                       EQU             $3C0
 
                              OUTSEMA EQU     $EF0000
                              SEMAABS EQU     $1000
                              OSSEMA  EQU     $EF0010
 
                              OPC_SWI                         EQU             $03F
                              ScreenLocation          EQU             $10
                              ColorCodeLocation       EQU             $14
                              ScreenLocation2         EQU             $18
                              BlkcpySrc                       EQU             $1C
                              BlkcpyDst                       EQU             $20
                              Strptr                          EQU             $24
                              PICptr                          EQU             $28
                              ; Forth Area
                              ; 0x30-0x60
 
                              ; Task control blocks, room for 256 tasks
                              TCB_NxtRdy              EQU             $00     ; next task on ready / timeout list
                              TCB_PrvRdy              EQU             $04     ; previous task on ready / timeout list
                              TCB_NxtTCB              EQU             $08
                              TCB_Timeout             EQU             $0C
                              TCB_Priority    EQU             $10
                              TCB_MSGPTR_D1   EQU             $14
                              TCB_MSGPTR_D2   EQU             $18
                              TCB_hJCB                        EQU             $1C
                              TCB_Status              EQU             $1E
                              TCB_CursorRow   EQU             $20
                              TCB_CursorCol   EQU             $21
                              TCB_hWaitMbx    EQU             $22     ; handle of mailbox task is waiting at
                              TCB_mbq_next    EQU             $24     ; mailbox queue next
                              TCB_mbq_prev    EQU             $28     ; mailbox queue previous
                              TCB_iof_next    EQU             $2C
                              TCB_iof_prev    EQU             $30
                              TCB_SPSave              EQU             $34     ; TCB_SPSave area
                              TCB_mmu_map             EQU             $38
 
                              KeybdHead               EQU             $FFFFFC800
                              KeybdTail               EQU             $FFFFFC900
                              KeybdEcho               EQU             $FFFFFCA00
                              KeybdBad                EQU             $FFFFFCB00
                              KeybdAck                EQU             $FFFFFCC00
                              KeybdLocks              EQU             $FFFFFCD00
                              KeybdBuffer             EQU             $FFFFFC000      ; buffer is 16 chars
 
                              BIOS_SCREENS    EQU     $17000000       ; $17000000 to $171FFFFF
 
                              ; EhBASIC vars:
                              ;
                              NmiBase         EQU             $FFC013
                              IrqBase         EQU             $FFC014
 
                              IOFocusNdx      EQU             $100
 
                              ; These variables in global OS storage area
 
                              IOFocusList     EQU             $FFC000 ; to $FF000F
                              IOFocusID               EQU             $FFC010
                              IrqSource               EQU             $FFC011
                              IRQFlag                 EQU             $FFC012
                              RunningID               EQU             $FFC013
                              ; Top of boot stack is at $FFC0FF
 
                              ; These variables use direct page access
                              CursorRow       EQU             $110
                              CursorCol       EQU             $111
                              CharColor       EQU             $112
                              ScreenColor     EQU             $113
                              CursorFlash     EQU             $114
                              KeyState1       EQU     $120
                              KeyState2       EQU     $121
                              KeyLED          EQU     $122
                              KeybdID         EQU     $124
                              KeybdBlock      EQU     $126
                              kbdHeadRcv      EQU     $127
                              kbdTailRcv      EQU     $128
                              kbdFifo                 EQU     $40                             ; in local RAM
                              kbdFifoAlias    EQU     $C00040 ; to $C0007F    ; alias for $40 to $7F
                              SerhZero                EQU     $130
                              SerHeadRcv      EQU     $131
                              SertZero                EQU     $132
                              SerTailRcv      EQU     $133
                              SerHeadXmit     EQU     $136
                              SerTailXmit     EQU     $138
                              SerRcvXon               EQU     $139
                              SerRcvXoff      EQU     $140
                              SerRcvBuf               EQU     $BFF000 ; 4kB serial recieve buffer
 
                              farflag EQU             $15F
                              asmbuf  EQU             $160    ; to $17F
 
                              QNdx0           EQU             $780
                              QNdx1           EQU             QNdx0+2
                              QNdx2           EQU             QNdx1+2
                              QNdx3           EQU             QNdx2+2
                              QNdx4           EQU             QNdx3+2
                              FreeTCB         EQU             QNdx4+2
                              TimeoutList     EQU             FreeTCB+2
                              FreeMbx         EQU             RunningTCB + 2
                              nMailbox        EQU             FreeMbx + 2
                              FreeMsg         EQU             nMailbox + 2
                              nMsgBlk         EQU             FreeMsg + 2
 
 
                              CharOutVec      EQU             $800
                              CharInVec       EQU             $804
                              CmdPromptJI     EQU     $808
                              MonErrVec       EQU             $80C
                              BreakpointFlag  EQU             $810
                              NumSetBreakpoints       EQU     $811
                              Breakpoints                     EQU             $820    ; to $82F
                              BreakpointBytes EQU             $830    ; to $83F
                              mon_vectb                               EQU             $880
 
                              ; Register save area for monitor
                              mon_DSAVE       EQU             $900
                              mon_XSAVE       EQU             $902
                              mon_YSAVE       EQU             $904
                              mon_USAVE       EQU             $906
                              mon_SSAVE       EQU             $908
                              mon_PCSAVE      EQU             $90A
                              mon_DPRSAVE     EQU             $90E
                              mon_CCRSAVE     EQU             $90F
 
                              mon_numwka      EQU             $910
                              mon_r1          EQU             $920
                              mon_r2          EQU             $924
                              jmpvec          EQU             $928
                              mon_init        EQU             $92C
                              mon_retflag     EQU     $930
 
                              ; The ORG directive must set an address a multiple of 4 in order for the Verilog
                              ; output to work correctly.
 
                                      org             $FFD0AC
 00FFD0AC 012                             nop
 00FFD0AD 012                             nop
 00FFD0AE 012                             nop
                              XBLANK
 00FFD0AF 0C6020                          ldb             #' '
 00FFD0B1 017001E2D                       lbsr    OUTCH
 00FFD0B4 039                             rts
 
                                      org             $FFD0D0
 00FFD0D0 012                             nop
 00FFD0D1 012                             nop
                              CRLF
                              CRLF1:
 00FFD0D2 0C600D                          ldb             #CR
 00FFD0D4 017001E0A                       lbsr    OUTCH
 00FFD0D7 0C600A                          ldb             #LF
 00FFD0D9 017001E05                       lbsr    OUTCH
 00FFD0DC 039                             rts
 
                                      org             $FFD0F0
 00FFD0F0 012                             nop
 00FFD0F1 020FDF                          bra             CRLF1
 
                                      org             $FFD1DC
                              ONEKEY
 00FFD1DC 06E90F000804                    jmp             [CharInVec]
 
                                      org             $FFD2C0
 00FFD2C0 012                             nop
                              LETTER
 00FFD2C1 017001C1D                       lbsr    OUTCH
 00FFD2C4 039                             rts
 
                                      org             $FFD2CC
 00FFD2CC 012                             nop
 00FFD2CD 012                             nop
                              HEX2
 00FFD2CE 017001166                       lbsr    DispByteAsHex
 00FFD2D1 039                             rts
                              HEX4
 00FFD2D2 017001159                       lbsr    DispWordAsHex
 00FFD2D5 039                             rts
 
                                      org             $FFD300
                              ClearScreenJmp
 00FFD300 016000F36                       lbra    ClearScreen
                                      org             $FFD308
                              HomeCursorJmp
 00FFD308 016000FA5                       lbra    HomeCursor
 
                                      org             $FFD400
 
                              ; Local RAM test routine
                              ; Checkerboard testing.
                              ; There is 70kB of local RAM
                              ; Does not use any RAM including no stack
 
                              ramtest:
 00FFD400 18E000000                       ldy             #0
 00FFD403 086001                          lda             #1
 00FFD405 0150B7FFFE60001                 sta             LEDS
 00FFD40A 0CCAAA555                       ldd             #$AAA555
                              ramtest1:
 00FFD40D 0EDA01                          std             ,y++
 00FFD40F 18C008000                       cmpy    #$8000
 00FFD412 025FF9                          blo             ramtest1
                                      ; now readback values and compare
 00FFD414 18E000000                       ldy             #0
                              ramtest3:
 00FFD417 0ECA01                          ldd             ,y++
 00FFD419 183AAA555                       cmpd    #$AAA555
 00FFD41C 02600E                          bne             ramerr
 00FFD41E 18C008000                       cmpy    #$8000
 00FFD421 025FF4                          blo             ramtest3
 00FFD423 086002                          lda             #2
 00FFD425 0150B7FFFE60001                 sta             LEDS
 00FFD42A 06EC04                          jmp             ,u
                              ramerr:
 00FFD42C 086080                          lda             #$80
 00FFD42E 0150B7FFFE60001                 sta             LEDS
 00FFD433 0150F6FFFFFFFE0                 ldb             COREID
 00FFD438 0C1020                          cmpb    #$20
 00FFD43A 027009                          beq             ramerr1
 00FFD43C 08EE00000                       ldx             #TEXTSCR
 00FFD43F 03A                             abx
 00FFD440 086046                          lda             #'F'
 00FFD442 0A7804                          sta             ,x
 00FFD444 013                             sync
                              ramerr1:
 00FFD445 06EC04                          jmp             ,u
 
 
                                      org             $FFE000
 00FFE000 FFF039                          FDB Monitor
 00FFE002 FFE022                          FDB DumRts      ;       NEXTCMD
 00FFE004 FFEEA9                          FDB INCH
 00FFE006 FFEEC7                          FDB INCHE
 00FFE008 FFEECB                          FDB INCHEK
 00FFE00A FFEEE1                          FDB OUTCH
 00FFE00C FFE41B                          FDB PDATA
 00FFE00E FFE40E                          FDB PCRLF
 00FFE010 FFE40A                          FDB PSTRNG
 00FFE012 FFE022                          FDB DumRts                      ; LRA
 00FFE014 FFE022                          FDB DumRts
 00FFE016 FFE022                          FDB DumRts
 00FFE018 FFE022                          FDB DumRts
 00FFE01A FFE022                          FDB DumRts                      ; VINIZ
 00FFE01C FFE319                          FDB DisplayChar ;       VOUTCH
 00FFE01E FFE022                          FDB DumRts                      ; ACINIZ
 00FFE020 FFE022                          FDB DumRts                      ; AOUTCH
 
                              DumRts:
 00FFE022 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
 
                              start:
 00FFE023 086FFF                          lda             #$FFF                   ; all cores can do this
 00FFE025 0150B7FFFE60003                 sta             VIA+VIA_DDRA
 00FFE02A 086055                          lda             #$55                    ; see if we can at least set LEDs
 00FFE02C 0150B7FFFE60001                 sta             LEDS
 00FFE031 086001                          lda             #1                              ; prime OS semaphore
 00FFE033 0B7EF1010                       sta             OSSEMA+$1000
 00FFE036 0B7EF1000                       sta             OUTSEMA+$1000
 00FFE039 0CEFFE03C                       ldu             #st6                    ; U = return address
                              ;       jmp             ramtest         ; JMP dont JSR
                              st6:
 00FFE03C 1CE006FFF                       lds             #$6FFF          ; boot up stack area
 00FFE03F 0150B6FFFFFFFE0                 lda             COREID
 00FFE044 081001                          cmpa    #FIRST_CORE
                              ;       beq             st8
                              ;       sync                                            ; halt cores other than 2
                              st8:
                              ;       bne             skip_init
                              ;       bsr             romToRam
                              ;       ldd             #st7 & $FFFF
                              ;       tfr             d,x
                              ;       jmp             ,x                              ; jump to the BIOS now in local RAM
                              st7:
 00FFE046 08D16D                          bsr             Delay3s         ; give some time for devices to reset
 00FFE048 07F000810                       clr             BreakpointFlag
 00FFE04B 07F000811                       clr             NumSetBreakpoints
 00FFE04E 0860AA                          lda             #$AA
 00FFE050 0150B7FFFE60001                 sta             LEDS
 00FFE055 0150B6FFFFFFFE0                 lda             COREID
 00FFE05A 081020                          cmpa    #$20
 00FFE05C 027002                          beq             st11
 00FFE05E 086001                          lda             #FIRST_CORE
                              st11:
 00FFE060 0B7FFC010                       sta             IOFocusID       ; core #2 has focus
 00FFE063 0B7FFC013                       sta             RunningID
                                      ; Clear IO focus list
 00FFE066 08E000000                       ldx             #0
                              st9:
 00FFE069 06F80A000FFC000                 clr             IOFocusList,x
 00FFE06E 030001                          inx
 00FFE070 08C000010                       cmpx    #16
 00FFE073 025FF4                          blo             st9
 00FFE075 086018                          lda             #24
 00FFE077 0B7FFC001                       sta             IOFocusList+FIRST_CORE
 
 00FFE07A 0860CE                          lda             #$0CE
 00FFE07C 097113                          sta             ScreenColor
 00FFE07E 097112                          sta             CharColor
 00FFE080 08D1B7                          bsr             ClearScreen
 00FFE082 0CCFFE319                       ldd             #DisplayChar
 00FFE085 0FD000800                       std             CharOutVec
 00FFE088 0CCFFEC64                       ldd             #SerialPeekCharDirect
 00FFE08B 0FD000804                       std             CharInVec
                              ;       swi
                              ;       fcb             MF_OSCALL
                              ;       fcb             24                                      ; request IO focus
 00FFE08E 0150F6FFFFFFFE0                 ldb             COREID
 00FFE093 0C1001                          cmpb    #FIRST_CORE
 00FFE095 027011                          beq             init
 00FFE097 0C1020                          cmpb    #$20                            ; CmodA709 core?
 00FFE099 02705D                          beq             init2
 00FFE09B 02006D                          bra             skip_init
 00FFE09D 0200B4                          bra             multi_sieve
                              st3:
 00FFE09F 0860FF                          lda             #$FF
 00FFE0A1 0150B7FFFE60001                 sta             LEDS
 00FFE0A6 020FF7                          bra             st3
 
                                      ; initialize interrupt controller
                                      ; first, zero out all the vectors
                              init:
 00FFE0A8 017000449                       lbsr    rtc_read        ; get clock values
 00FFE0AB 08E000127                       ldx             #kbdHeadRcv
 00FFE0AE 0C6020                          ldb             #32                             ; number of bytes to zero out
                              init1:
 00FFE0B0 06F800                          clr             ,x+
 00FFE0B2 05A                             decb
 00FFE0B3 026FFB                          bne             init1
                              st1:
 00FFE0B5 06F809E3F000                    clr             PIC,x                   ; cause code
 00FFE0B9 0A7809E3F001                    sta             PIC+1,x
 00FFE0BD 0E7809E3F002                    stb             PIC+2,x
 00FFE0C1 030004                          leax    4,x
 00FFE0C3 08C000100                       cmpx    #256
 00FFE0C6 025FED                          blo             st1
 00FFE0C8 086081                          lda             #$81                    ; make irq edge sensitive
 00FFE0CA 0150B7FFFE3F0FD                 sta             PIC+$FD
 00FFE0CF 08601F                          lda             #31                             ; enable timer interrupt
 00FFE0D1 0150B7FFFE3F009                 sta             PIC+9
 00FFE0D6 086040                          lda             #COLS
 00FFE0D8 0150B7FFFE07F00                 sta             TEXTREG+TEXT_COLS
 00FFE0DD 086020                          lda             #ROWS
 00FFE0DF 0150B7FFFE07F01                 sta             TEXTREG+TEXT_ROWS
 00FFE0E4 08D153                          bsr             ClearScreen
 00FFE0E6 08D1C8                          bsr             HomeCursor
 00FFE0E8 08E000000                       ldx             #0
 00FFE0EB 0CC000000                       ldd             #0
 00FFE0EE 017000DFA                       lbsr    ShowSprites
 00FFE0F1 0170008CC                       lbsr    KeybdInit
 00FFE0F4 0DC124                          ldd             KeybdID
 00FFE0F6 08D336                          bsr             DispWordAsHex
                              init2:
 00FFE0F8 01700036A                       lbsr    TimerInit
 00FFE0FB 017000AF1                       lbsr    InitSerial
 00FFE0FE 08E000080                       ldx             #128
 00FFE101 086001                          lda             #1                      ; set irq(bit0), clear firq (bit1), disable int (bit 6), clear edge sense(bit 7)
 00FFE103 0C6001                          ldb             #FIRST_CORE                     ; serving core id
                              ;       lda             #4                              ; make the timer interrupt edge sensitive
                              ;       sta             PIC+4                   ; reg #4 is the edge sensitivity setting
                              ;       sta             PIC                             ; reg #0 is interrupt enable
 00FFE105 0C6001                          ldb             #1
 00FFE107 0F7EF1000                       stb             OUTSEMA+SEMAABS ; set semaphore to 1 available slot
                              skip_init:
 00FFE10A 01C0EF                          andcc   #$EF                    ; unmask irq
 00FFE10C 086005                          lda             #5
 00FFE10E 0150B7FFFE60001                 sta             LEDS
 00FFE113 0CCFFE11C                       ldd             #msgStartup
 00FFE116 08D2C2                          bsr             DisplayString
                              st10:
 00FFE118 03F                             swi
 00FFE119 000                             fcb             MF_Monitor
 00FFE11A 020FFC                          bra             st10
 
                              msgStartup
 00FFE11C 072066036038030039020           fcb             "rf6809 12-bit System Starting.",CR,LF,0
 00FFE123 03103202D062069074020
 00FFE12A 05307907307406506D020
 00FFE131 05307406107207406906E
 00FFE138 06702E00D00A000
 
                              ;------------------------------------------------------------------------------
                              ; The checkpoint register must be cleared within 1 second or a NMI interrupt
                              ; will occur. checkpoint should be called with a JSR so that the global ROM
                              ; routine is called.
                              ;
                              ; Modifies:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              checkpoint:
 00FFE13D 01507FFFFFFFFE1                 clr             $FFFFFFFE1      ; writing any value will do
 00FFE142 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Copy the system ROM to local RAM
                              ; Running the code from local RAM is probably an order of magnitude faster
                              ; then running from the global ROM. It also reduces the network traffic to
                              ; run from local RAM.
                              ;
                              ; Modifies:
                              ;               d,x,y
                              ;------------------------------------------------------------------------------
 
                              romToRam:
 00FFE143 08EFFC000                       ldx             #$FFC000
 00FFE146 18E00C000                       ldy             #$00C000
                              romToRam1:
 00FFE149 0EC801                          ldd             ,x++
 00FFE14B 0EDA01                          std             ,y++
 00FFE14D 08C000000                       cmpx    #0
 00FFE150 026FF7                          bne             romToRam1
 00FFE152 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Multi-core sieve program.
                              ;------------------------------------------------------------------------------
 
                              ; First fill screen chars with 'P' indicating prime positions
                              ; Each core is responsible for the Nth position where N is the
                              ; core number minus two.
                              ;
                              multi_sieve:
 00FFE153 086050                          lda             #'P'                                    ; indicate prime
 00FFE155 0150F6FFFFFFFE0                 ldb             COREID                          ; find out which core we are
 00FFE15A 0C0001                          subb    #FIRST_CORE
 00FFE15C 08E000000                       ldx             #0                                              ; start at first char of screen
 00FFE15F 03A                             abx
                              multi_sieve3:
 00FFE160 0A7809E00000                    sta             TEXTSCR,x                       ; store 'P'
 00FFE164 030008                          leax    8,x                                             ; advance to next position
 00FFE166 08C000FFF                       cmpx    #4095
 00FFE169 025FF5                          blo             multi_sieve3
 00FFE16B 0BDFFE13D                       jsr             checkpoint
*** warning 1: Long branch within short branch range could be optimized
 00FFE16E 0CB002                          addb    #2                                              ; start sieve at 2 (core id)
 00FFE170 08604E                          lda             #'N'                                    ; flag position value of 'N' for non-prime
                              multi_sieve2:
 00FFE172 08E000000                       ldx             #0
 00FFE175 03A                             abx                                                                     ; skip the first position - might be prime
                              multi_sieve1:
 00FFE176 03A                             abx                                                                     ; increment
 00FFE177 0A7809E00000                    sta             TEXTSCR,x
 00FFE17B 08C000FFF                       cmpx    #4095
 00FFE17E 025FF6                          blo             multi_sieve1
 00FFE180 0BDFFE13D                       jsr             checkpoint
*** warning 1: Long branch within short branch range could be optimized
 00FFE183 0CB008                          addb    #8                                              ; number of cores working on it
 00FFE185 0C1FF0                          cmpb    #4080
 00FFE187 025FE9                          blo             multi_sieve2
                              multi_sieve4:                                   ; hang machine
 00FFE189 013                             sync
 00FFE18A 016000EAC                       lbra    Monitor
 
                              ;------------------------------------------------------------------------------
                              ; Single core sieve.
                              ;------------------------------------------------------------------------------
 
                              sieve:
 00FFE18D 086050                          lda             #'P'                                    ; indicate prime
 00FFE18F 08E000000                       ldx             #0                                              ; start at first char of screen
                              sieve3:
 00FFE192 0A7809E00000                    sta             TEXTSCR,x                       ; store 'P'
 00FFE196 030001                          inx                                                                     ; advance to next position
 00FFE198 08C000FFF                       cmpx    #4095
 00FFE19B 025FF5                          blo             sieve3
 00FFE19D 0C6002                          ldb             #2                                              ; start sieve at 2
 00FFE19F 08604E                          lda             #'N'                                    ; flag position value of 'N' for non-prime
                              sieve2:
 00FFE1A1 08E000000                       ldx             #0
 00FFE1A4 03A                             abx                                                                     ; skip the first position - might be prime
                              sieve1:
 00FFE1A5 03A                             abx                                                                     ; increment
 00FFE1A6 0A7809E00000                    sta             TEXTSCR,x
 00FFE1AA 08C000FFF                       cmpx    #4095
 00FFE1AD 025FC7                          blo             multi_sieve1
 00FFE1AF 05C                             incb                                                            ; number of cores working on it
 00FFE1B0 0C1FF0                          cmpb    #4080
 00FFE1B2 025FED                          blo             sieve2
                              sieve4:                                                         ; hang machine
 00FFE1B4 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Three second delay for user convenience and to allow some devices time to
                              ; reset.
                              ;------------------------------------------------------------------------------
 
                              Delay3s:
 00FFE1B5 0CC895440                       ldd             #9000000
                              dly3s1:
 00FFE1B8 0C10FF                          cmpb    #$FF
 00FFE1BA 026000                          bne             dly3s2
                              dly3s2:
 00FFE1BC 0150B7FFFE60001                 sta             LEDS
 00FFE1C1 083000001                       subd    #1
 00FFE1C4 026FF2                          bne             dly3s1
 00FFE1C6 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              ShiftLeft5:
 00FFE1C7 058                             aslb
 00FFE1C8 049                             rola
 00FFE1C9 058                             aslb
 00FFE1CA 049                             rola
 00FFE1CB 058                             aslb
 00FFE1CC 049                             rola
 00FFE1CD 058                             aslb
 00FFE1CE 049                             rola
 00FFE1CF 058                             aslb
 00FFE1D0 049                             rola
 00FFE1D1 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Parameters:
                              ;               b = core id of core to copy
                              ;------------------------------------------------------------------------------
                              ;
                              CopyVirtualScreenToScreen:
 00FFE1D2 034076                          pshs    d,x,y,u
                                      ; Compute virtual screen location for core passed in accb.
 00FFE1D4 01F098                          tfr             b,a
 00FFE1D6 048                             asla
 00FFE1D7 048                             asla
 00FFE1D8 048                             asla
 00FFE1D9 048                             asla
 00FFE1DA 08AC00                          ora             #$C00
 00FFE1DC 05F                             clrb
 00FFE1DD 01F001                          tfr             d,x
 00FFE1DF 034006                          pshs    d
 00FFE1E1 18EE00000                       ldy             #TEXTSCR
 00FFE1E4 0CE000400                       ldu             #COLS*ROWS/2
                              cv2s1:
 00FFE1E7 0EC801                          ldd             ,x++
 00FFE1E9 0EDA01                          std             ,y++
 00FFE1EB 0335FF                          leau    -1,u
 00FFE1ED 283000000                       cmpu    #0
 00FFE1F0 026FF5                          bne             cv2s1
                                      ; reset the cursor position in the text controller
 00FFE1F2 035010                          puls    x
 00FFE1F4 0E6808110                       ldb             CursorRow,x
 00FFE1F7 086040                          lda             #COLS
 00FFE1F9 03D                             mul
 00FFE1FA 01F002                          tfr             d,y
 00FFE1FC 0E6808111                       ldb             CursorCol,x
 00FFE1FF 01F021                          tfr             y,x
 00FFE201 03A                             abx
 00FFE202 0150BFFFFE07F22                 stx             TEXTREG+TEXT_CURPOS
 00FFE207 0350F6                          puls    d,x,y,u,pc
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              ;
                              CopyScreenToVirtualScreen:
 00FFE209 034076                          pshs    d,x,y,u
 00FFE20B 08D08D                          bsr             GetScreenLocation
 00FFE20D 01F002                          tfr             d,y
 00FFE20F 08EE00000                       ldx             #TEXTSCR
 00FFE212 0CE000400                       ldu             #COLS*ROWS/2
                              cs2v1:
 00FFE215 0EC801                          ldd             ,x++
 00FFE217 0EDA01                          std             ,y++
 00FFE219 0335FF                          leau    -1,u
 00FFE21B 283000000                       cmpu    #0
 00FFE21E 026FF5                          bne             cs2v1
 00FFE220 0350F6                          puls    d,x,y,u,pc
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
 00FFE222 054045058054053043052           fcb             "TEXTSCR "
 00FFE229 020
 00FFE22A FFE234                          fcw             TextOpen
 00FFE22C FFE235                          fcw             TextClose
 00FFE22E FFE236                          fcw             TextRead
 00FFE230 FFE237                          fcw             TextWrite
 00FFE232 FFE238                          fcw             TextSeek
 
                              TextOpen:
 00FFE234 039                             rts
                              TextClose:
 00FFE235 039                             rts
                              TextRead:
 00FFE236 039                             rts
                              TextWrite:
 00FFE237 039                             rts
                              TextSeek:
 00FFE238 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Clear the screen and the screen color memory
                              ; We clear the screen to give a visual indication that the system
                              ; is working at all.
                              ;
                              ; Modifies:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              ClearScreen:
 00FFE239 034076                          pshs    d,x,y,u
 00FFE23B 08E000800                       ldx             #COLS*ROWS
 00FFE23E 01F013                          tfr             x,u
 00FFE240 08D058                          bsr             GetScreenLocation
 00FFE242 01F002                          tfr             d,y
 00FFE244 0C6020                          ldb             #' '                            ; space char
                              cs1:
 00FFE246 0E7A00                          stb             ,y+                                     ; set text to space
 00FFE248 0301FF                          leax    -1,x                            ; decrement x
 00FFE24A 026FFA                          bne             cs1
 00FFE24C 0150F6FFFFFFFE0                 ldb             COREID                  ; update colors only if we have focus
 00FFE251 0F1FFC010                       cmpb    IOFocusID
 00FFE254 02000D                          bra             cs3
 00FFE256 18EE02000                       ldy             #TEXTSCR+$2000
                              ;       lda             CharColor
 00FFE259 0860CE                          lda             #$0CE
 00FFE25B 01F031                          tfr             u,x                                     ; get back count
                              cs2:
 00FFE25D 0A7A00                          sta             ,y+
 00FFE25F 0301FF                          dex                                                             ; decrement x
 00FFE261 026FFA                          bne             cs2
                              cs3:
 00FFE263 0350F6                          puls    d,x,y,u,pc
 
                              ;------------------------------------------------------------------------------
                              ; Scroll text on the screen upwards
                              ;
                              ; Modifies:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              ScrollUp:
 00FFE265 034076                          pshs    d,x,y,u
 00FFE267 18E0003FF                       ldy             #(COLS*ROWS-1)/2        ; y = num chars/2 to move
 00FFE26A 08D02E                          bsr             GetScreenLocation
 00FFE26C 01F001                          tfr             d,x
 00FFE26E 01F003                          tfr             d,u
 00FFE270 030040                          leax    COLS,x          ; x = index to source row
                              scrup1:
 00FFE272 0EC801                          ldd             ,x++                    ; move 2 characters
 00FFE274 0EDC01                          std             ,u++
 00FFE276 0313FF                          dey
 00FFE278 026FF8                          bne             scrup1
 00FFE27A 08601F                          lda             #ROWS-1
 00FFE27C 08D002                          bsr             BlankLine
 00FFE27E 0350F6                          puls    d,x,y,u,pc
 
                              ;------------------------------------------------------------------------------
                              ; Blank out a line on the display
                              ;
                              ; Modifies:
                              ;               none
                              ; Parameters:
                              ;       acca = line number to blank
                              ;------------------------------------------------------------------------------
 
                              BlankLine:
 00FFE280 034016                          pshs    d,x
 00FFE282 034002                          pshs    a
 00FFE284 08D014                          bsr             GetScreenLocation
 00FFE286 01F001                          tfr             d,x
 00FFE288 035002                          puls    a
 00FFE28A 0C6040                          ldb             #COLS   ; b = # chars to blank out from video controller
 00FFE28C 03D                             mul                                     ; d = screen index (row# * #cols)
 00FFE28D 03080B                          leax    d,x
 00FFE28F 086020                          lda             #' '
 00FFE291 0C6040                          ldb             #COLS   ; b = # chars to blank out from video controller
                              blnkln1:
 00FFE293 0A7800                          sta             ,x+
 00FFE295 05A                             decb
 00FFE296 026FFB                          bne             blnkln1
 00FFE298 035096                          puls    d,x,pc
 
                              ;------------------------------------------------------------------------------
                              ; Get the location of the screen memory. The location
                              ; depends on whether or not the task has the output focus.
                              ;
                              ; Modifies:
                              ;               d
                              ; Retuns:
                              ;               d = screen location
                              ;------------------------------------------------------------------------------
 
                              GetScreenLocation:
 00FFE29A 0150B6FFFFFFFE0                 lda             COREID                  ; which core are we?
 00FFE29F 0B1FFC010                       cmpa    IOFocusID               ; do we have the IO focus
 00FFE2A2 026008                          bne             gsl1                            ; no, go pick virtual screen address
 00FFE2A4 081020                          cmpa    #$20                            ; CmodA709?
 00FFE2A6 027004                          beq             gsl1
 00FFE2A8 0CCE00000                       ldd             #TEXTSCR                ; yes, we update the real screen
 00FFE2AB 039                             rts
                              gsl1:
 00FFE2AC 0CC007800                       ldd             #$7800
 00FFE2AF 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; HomeCursor
                              ; Set the cursor location to the top left of the screen.
                              ;
                              ; Modifies:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              HomeCursor:
 00FFE2B0 034016                          pshs    d,x
 00FFE2B2 00F110                          clr             CursorRow
 00FFE2B4 00F111                          clr             CursorCol
 00FFE2B6 0150F6FFFFFFFE0                 ldb             COREID
 00FFE2BB 0F1FFC010                       cmpb    IOFocusID
 00FFE2BE 02600A                          bne             hc1
 00FFE2C0 0C1020                          cmpb    #$20
 00FFE2C2 027006                          beq             hc1
 00FFE2C4 04F                             clra
 00FFE2C5 0150B7FFFE07F22                 sta             TEXTREG+TEXT_CURPOS
                              hc1:
 00FFE2CA 035096                          puls    d,x,pc
 
                              ;------------------------------------------------------------------------------
                              ; Update the cursor position in the text controller based on the
                              ;  CursorRow,CursorCol.
                              ;
                              ; Modifies:
                              ;               none
                              ;------------------------------------------------------------------------------
                              ;
                              UpdateCursorPos:
 00FFE2CC 034016                          pshs    d,x
 00FFE2CE 0150F6FFFFFFFE0                 ldb             COREID                          ; update cursor position in text controller
 00FFE2D3 0F1FFC010                       cmpb    IOFocusID                       ; only for the task with the output focus
 00FFE2D6 026018                          bne             ucp1
 00FFE2D8 0C1020                          cmpb    #$20                                    ; and not for CmodA709
 00FFE2DA 027014                          beq             ucp1                                    
 00FFE2DC 096110                          lda             CursorRow
 00FFE2DE 08403F                          anda    #$3F                                    ; limit of 63 rows
 00FFE2E0 0150F6FFFE07F00                 ldb             TEXTREG+TEXT_COLS
 00FFE2E5 03D                             mul
 00FFE2E6 01F001                          tfr             d,x
 00FFE2E8 0D6111                          ldb             CursorCol
 00FFE2EA 03A                             abx
 00FFE2EB 0150BFFFFE07F22                 stx             TEXTREG+TEXT_CURPOS
                              ucp1:
 00FFE2F0 035096                          puls    d,x,pc
 
                              ;------------------------------------------------------------------------------
                              ; Calculate screen memory location from CursorRow,CursorCol.
                              ; Also refreshes the cursor location.
                              ;
                              ; Modifies:
                              ;               d
                              ; Returns:
                              ;       d = screen location
                              ;------------------------------------------------------------------------------
                              ;
                              CalcScreenLoc:
 00FFE2F2 034010                          pshs    x
 00FFE2F4 096110                          lda             CursorRow
 00FFE2F6 0C6040                          ldb             #COLS
 00FFE2F8 03D                             mul
 00FFE2F9 01F001                          tfr             d,x
 00FFE2FB 0D6111                          ldb             CursorCol
 00FFE2FD 03A                             abx
 00FFE2FE 0150F6FFFFFFFE0                 ldb             COREID                          ; update cursor position in text controller
 00FFE303 0F1FFC010                       cmpb    IOFocusID                       ; only for the task with the output focus
 00FFE306 026009                          bne             csl1                                    
 00FFE308 0C1020                          cmpb    #$20
 00FFE30A 027005                          beq             csl1
 00FFE30C 0150BFFFFE07F22                 stx             TEXTREG+TEXT_CURPOS
                              csl1:
 00FFE311 08DF87                          bsr             GetScreenLocation
 00FFE313 03080B                          leax    d,x
 00FFE315 01F010                          tfr             x,d
 00FFE317 035090                          puls    x,pc
 
                              ;------------------------------------------------------------------------------
                              ; Display a character on the screen.
                              ; If the task doesn't have the I/O focus then the character is written to
                              ; the virtual screen.
                              ;
                              ; Modifies:
                              ;               none
                              ; Parameters:
                              ;       accb = char to display
                              ;------------------------------------------------------------------------------
                              ;
                              DisplayChar:
 00FFE319 01700096C                       lbsr    SerialPutChar
 00FFE31C 034016                          pshs    d,x
 00FFE31E 0C100D                          cmpb    #CR                                     ; carriage return ?
 00FFE320 026007                          bne             dccr
 00FFE322 00F111                          clr             CursorCol               ; just set cursor column to zero on a CR
 00FFE324 08DFA6                          bsr             UpdateCursorPos
                              dcx14:
 00FFE326 01600008C                       lbra            dcx4
                              dccr:
 00FFE329 0C1091                          cmpb    #$91                            ; cursor right ?
 00FFE32B 02600D                          bne             dcx6
 00FFE32D 096111                          lda             CursorCol
 00FFE32F 081040                          cmpa    #COLS
 00FFE331 024003                          bhs             dcx7
 00FFE333 04C                             inca
 00FFE334 097111                          sta             CursorCol
                              dcx7:
 00FFE336 08DF94                          bsr             UpdateCursorPos
 00FFE338 035096                          puls    d,x,pc
                              dcx6:
 00FFE33A 0C1090                          cmpb    #$90                            ; cursor up ?
 00FFE33C 026009                          bne             dcx8            
 00FFE33E 096110                          lda             CursorRow
 00FFE340 027FF4                          beq             dcx7
 00FFE342 04A                             deca
 00FFE343 097110                          sta             CursorRow
 00FFE345 020FEF                          bra             dcx7
                              dcx8:
 00FFE347 0C1093                          cmpb    #$93                            ; cursor left ?
 00FFE349 026009                          bne             dcx9
 00FFE34B 096111                          lda             CursorCol
 00FFE34D 027FE7                          beq             dcx7
 00FFE34F 04A                             deca
 00FFE350 097111                          sta             CursorCol
 00FFE352 020FE2                          bra             dcx7
                              dcx9:
 00FFE354 0C1092                          cmpb    #$92                            ; cursor down ?
 00FFE356 02600B                          bne             dcx10
 00FFE358 096110                          lda             CursorRow
 00FFE35A 081020                          cmpa    #ROWS
 00FFE35C 027FD8                          beq             dcx7
 00FFE35E 04C                             inca
 00FFE35F 097110                          sta             CursorRow
 00FFE361 020FD3                          bra             dcx7
                              dcx10:
 00FFE363 0C1094                          cmpb    #$94                            ; cursor home ?
 00FFE365 02600C                          bne             dcx11
 00FFE367 096111                          lda             CursorCol
 00FFE369 027004                          beq             dcx12
 00FFE36B 00F111                          clr             CursorCol
 00FFE36D 020FC7                          bra             dcx7
                              dcx12:
 00FFE36F 00F110                          clr             CursorRow
 00FFE371 020FC3                          bra             dcx7
                              dcx11:
 00FFE373 0C1099                          cmpb    #$99                            ; delete ?
 00FFE375 026008                          bne             dcx13
 00FFE377 08DF79                          bsr             CalcScreenLoc
 00FFE379 01F001                          tfr             d,x
 00FFE37B 096111                          lda             CursorCol               ; acc = cursor column
 00FFE37D 020011                          bra             dcx5
                              dcx13
 00FFE37F 0C1008                          cmpb    #CTRLH                  ; backspace ?
 00FFE381 02601E                          bne             dcx3
 00FFE383 096111                          lda             CursorCol
 00FFE385 02702E                          beq             dcx4
 00FFE387 04A                             deca
 00FFE388 097111                          sta             CursorCol
 00FFE38A 08DF66                          bsr             CalcScreenLoc
 00FFE38C 01F001                          tfr             d,x
 00FFE38E 096111                          lda             CursorCol
                              dcx5:
 00FFE390 0E6001                          ldb             1,x
 00FFE392 0E7801                          stb             ,x++
 00FFE394 04C                             inca
 00FFE395 081040                          cmpa    #COLS
 00FFE397 025FF7                          blo             dcx5
 00FFE399 0C6020                          ldb             #' '
 00FFE39B 0301FF                          dex
 00FFE39D 0E7804                          stb             ,x
 00FFE39F 020014                          bra             dcx4
                              dcx3:
 00FFE3A1 0C100A                          cmpb    #LF                             ; linefeed ?
 00FFE3A3 02700E                          beq             dclf
 00FFE3A5 034004                          pshs    b
 00FFE3A7 08DF49                          bsr     CalcScreenLoc
 00FFE3A9 01F001                          tfr             d,x
 00FFE3AB 035004                          puls    b
 00FFE3AD 0E7804                          stb             ,x
                                      ; ToDo character color
                              ;       lda             CharColor
                              ;       sta             $2000,x
 00FFE3AF 08D006                          bsr             IncCursorPos
 00FFE3B1 020002                          bra             dcx4
                              dclf:
 00FFE3B3 08D011                          bsr             IncCursorRow
                              dcx4:
 00FFE3B5 035096                          puls    d,x,pc
 
                              ;------------------------------------------------------------------------------
                              ; Increment the cursor position, scroll the screen if needed.
                              ;
                              ; Modifies:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              IncCursorPos:
 00FFE3B7 034016                          pshs    d,x
 00FFE3B9 096111                          lda             CursorCol
 00FFE3BB 04C                             inca
 00FFE3BC 097111                          sta             CursorCol
 00FFE3BE 081040                          cmpa    #COLS
 00FFE3C0 025014                          blo             icc1
 00FFE3C2 00F111                          clr             CursorCol               ; column = 0
 00FFE3C4 020002                          bra             icr1
                              IncCursorRow:
 00FFE3C6 034016                          pshs    d,x
                              icr1:
 00FFE3C8 096110                          lda             CursorRow
 00FFE3CA 04C                             inca
 00FFE3CB 097110                          sta             CursorRow
 00FFE3CD 081020                          cmpa    #ROWS
 00FFE3CF 025005                          blo             icc1
 00FFE3D1 04A                             deca                                                    ; backup the cursor row, we are scrolling up
 00FFE3D2 097110                          sta             CursorRow
 00FFE3D4 08DE8F                          bsr             ScrollUp
                              icc1:
 00FFE3D6 08DEF4                          bsr             UpdateCursorPos
                              icc2:
 00FFE3D8 035096                          puls    d,x,pc  
 
                              ;------------------------------------------------------------------------------
                              ; Display a string on the screen.
                              ;
                              ; Modifies:
                              ;               none
                              ; Parameters:
                              ;               d = pointer to string
                              ;------------------------------------------------------------------------------
                              ;
                              DisplayString:
 00FFE3DA 034016                          pshs    d,x
 00FFE3DC 01F001                          tfr             d,x
 00FFE3DE 0150B6FFFFFFFE0                 lda             COREID
 00FFE3E3 081020                          cmpa    #$20
 00FFE3E5 027005                          beq             dspj1B
                              dspj2:                                          ; lock semaphore for access
 00FFE3E7 0B6EF0001                       lda             OUTSEMA+1
 00FFE3EA 027FFB                          beq             dspj2
                              dspj1B:
 00FFE3EC 0E6800                          ldb             ,x+                             ; move string char into acc
 00FFE3EE 027005                          beq             dsretB          ; is it end of string ?
 00FFE3F0 017000AEE                       lbsr    OUTCH                   ; display character
 00FFE3F3 020FF7                          bra             dspj1B
                              dsretB:
 00FFE3F5 07FEF0001                       clr             OUTSEMA+1       ; unlock semaphore
 00FFE3F8 035096                          puls    d,x,pc
 
                              DisplayStringCRLF:
 00FFE3FA 034006                          pshs    d
 00FFE3FC 08DFDC                          bsr             DisplayString
 00FFE3FE 0C600D                          ldb             #CR
 00FFE400 017000ADE                       lbsr    OUTCH
 00FFE403 0C600A                          ldb             #LF
 00FFE405 017000AD9                       lbsr    OUTCH
 00FFE408 035086                          puls    d,pc
                                      
                              ;
                              ; PRINT CR, LF, STRING
                              ;
                              PSTRNG
 00FFE40A 08D002                          BSR             PCRLF
 00FFE40C 02000D                          BRA             PDATA
                              PCRLF
 00FFE40E 034010                          PSHS    X
 00FFE410 08EFFE422                       LDX             #CRLFST
 00FFE413 08D006                          BSR             PDATA
 00FFE415 035010                          PULS    X
 00FFE417 039                             RTS
 
                              PRINT
 00FFE418 0BDFFEEE1                       JSR             OUTCH
                              PDATA
 00FFE41B 0E6800                          LDB             ,X+
 00FFE41D 0C1004                          CMPB    #$04
 00FFE41F 026FF7                          BNE             PRINT
 00FFE421 039                             RTS
 
                              CRLFST
 00FFE422 00D00A004                       fcb     CR,LF,4
 
                              DispDWordAsHex:
 00FFE425 08D007                          bsr             DispWordAsHex
 00FFE427 01E001                          exg             d,x
 00FFE429 08D003                          bsr             DispWordAsHex
 00FFE42B 01E001                          exg             d,x
 00FFE42D 039                             rts
 
                              DispWordAsHex:
 00FFE42E 01E089                          exg             a,b
 00FFE430 08D005                          bsr             DispByteAsHex
 00FFE432 01E089                          exg             a,b
 00FFE434 08D001                          bsr             DispByteAsHex
 00FFE436 039                             rts
 
                              DispByteAsHex:
 00FFE437 034004                    pshs  b
 00FFE439 054                             lsrb
 00FFE43A 054                             lsrb
 00FFE43B 054                             lsrb
 00FFE43C 054                             lsrb
 00FFE43D 054                             lsrb
 00FFE43E 054                             lsrb
 00FFE43F 054                             lsrb
 00FFE440 054                             lsrb
 00FFE441 08D00C                          bsr             DispNyb
 00FFE443 035004                          puls    b
 00FFE445 034004                          pshs    b
 00FFE447 054                             lsrb
 00FFE448 054                             lsrb
 00FFE449 054                             lsrb
 00FFE44A 054                             lsrb
 00FFE44B 08D002                          bsr             DispNyb
 00FFE44D 035004                          puls    b
 
                              DispNyb
 00FFE44F 034004                          pshs    b
 00FFE451 0C400F                          andb    #$0F
 00FFE453 0C100A                          cmpb    #10
 00FFE455 025007                          blo             DispNyb1
 00FFE457 0CB037                          addb    #'A'-10
 00FFE459 017000A85                       lbsr    OUTCH
 00FFE45C 035084                          puls    b,pc
                              DispNyb1
 00FFE45E 0CB030                          addb    #'0'
 00FFE460 017000A7E                       lbsr    OUTCH
 00FFE463 035084                          puls    b,pc
 
                              ;==============================================================================
                              ; Timer
                              ;==============================================================================
 
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; Timer routines for a WDC6522 compatible circuit.
                              ;
                              ; This source file is free software: you can redistribute it and/or modify 
                              ; it under the terms of the GNU Lesser General Public License as published 
                              ; by the Free Software Foundation, either version 3 of the License, or     
                              ; (at your option) any later version.                                      
                              ;                                                                          
                              ; This source file is distributed in the hope that it will be useful,      
                              ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                              ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                              ; GNU General Public License for more details.                             
                              ;                                                                          
                              ; You should have received a copy of the GNU General Public License        
                              ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                              ;                                                                          
                              ; ============================================================================
                              ;
                              TimerInit:
 00FFE465 0CC061A80                       ldd             #$61A80                                 ; compare to 400000 (100 Hz assuming 40MHz clock)
 00FFE468 0150F7FFFE60014                 stb             VIA+VIA_T3CMPL
 00FFE46D 0150B7FFFE60015                 sta             VIA+VIA_T3CMPH
 00FFE472 01507FFFFE60012                 clr             VIA+VIA_T3LL
 00FFE477 01507FFFFE60013                 clr             VIA+VIA_T3LH
 00FFE47C 0150B6FFFE6000B                 lda             VIA+VIA_ACR                     ; set continuous mode for timer
 00FFE481 08A100                          ora             #$100
 00FFE483 0150B7FFFE6000B                 sta             VIA+VIA_ACR                     ; enable timer #3 interrupts
 00FFE488 086810                          lda             #$810
 00FFE48A 0150B7FFFE6000E                 sta             VIA+VIA_IER
 00FFE48F 039                             rts
 
                              TimerIRQ:
                                      ; Reset the edge sense circuit in the PIC
 00FFE490 08601F                          lda             #31                                                     ; Timer is IRQ #31
 00FFE492 0B7FFC011                       sta             IrqSource               ; stuff a byte indicating the IRQ source for PEEK()
 00FFE495 0150B7FFFE3F010                 sta             PIC+16                                  ; register 16 is edge sense reset reg   
 00FFE49A 0150B6FFFE6000D                 lda             VIA+VIA_IFR
 00FFE49F 02A011                          bpl             notTimerIRQ
 00FFE4A1 085080                          bita    #$80                                            ; timer3 irq is bit 7
 00FFE4A3 02700D                          beq             notTimerIRQ
 00FFE4A5 01507FFFFE60012                 clr             VIA+VIA_T3LL
 00FFE4AA 01507FFFFE60013                 clr             VIA+VIA_T3LH
 00FFE4AF 07CE00037                       inc             $E00037                                 ; update timer IRQ screen flag
                              notTimerIRQ:
 00FFE4B2 039                             rts
 
 
                                      
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2013-2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; BSD 3-Clause License
                              ; Redistribution and use in source and binary forms, with or without
                              ; modification, are permitted provided that the following conditions are met:
                              ;
                              ; 1. Redistributions of source code must retain the above copyright notice, this
                              ;    list of conditions and the following disclaimer.
                              ;
                              ; 2. Redistributions in binary form must reproduce the above copyright notice,
                              ;    this list of conditions and the following disclaimer in the documentation
                              ;    and/or other materials provided with the distribution.
                              ;
                              ; 3. Neither the name of the copyright holder nor the names of its
                              ;    contributors may be used to endorse or promote products derived from
                              ;    this software without specific prior written permission.
                              ;
                              ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                              ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                              ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                              ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                              ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                              ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                              ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                              ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                              ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                              ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                              ;                                                                          
                              ; ============================================================================
                              ;
                              ;===============================================================================
                              ; Generic I2C routines
                              ;
                              ; It is assumed there may be more than one I2C controller in the system, so
                              ; the address of the controller is passed in the X register.
                              ;===============================================================================
 
                              I2C_PREL        EQU             $0
                              I2C_PREH        EQU             $1
                              I2C_CTRL        EQU             $2
                              I2C_RXR         EQU             $3
                              I2C_TXR         EQU             $3
                              I2C_CMD         EQU             $4
                              I2C_STAT        EQU             $4
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; i2c initialization, sets the clock prescaler
                              ;
                              ; Parameters:
                              ;               x = I2C controller address
                              ; Returns: none
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              i2c_init:
 00FFE4B3 034004                          pshs    b
 00FFE4B5 0C6004                          ldb             #4                                                                      ; setup prescale for 400kHz clock
 00FFE4B7 0E7804                          stb             I2C_PREL,x
 00FFE4B9 06F001                          clr             I2C_PREH,x
 00FFE4BB 035084                          puls    b,pc
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Wait for I2C transfer to complete
                              ;
                              ; Parameters
                              ;       x - I2C controller base address
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              i2c_wait_tip:
 00FFE4BD 034004                          pshs            b
                              i2cw1:
 00FFE4BF 0E6004                          ldb                     I2C_STAT,x              ; would use lvb, but lb is okay since its the I/O area
 00FFE4C1 0C5001                          bitb            #1                                              ; wait for tip to clear
 00FFE4C3 026FFA                          bne                     i2cw1
 00FFE4C5 035084                          puls            b,pc
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Write command to i2c
                              ;
                              ; Parameters
                              ;               accb - data to transmit
                              ;               acca - command value
                              ;               x       - I2C controller base address
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              i2c_wr_cmd:
 00FFE4C7 0E7003                          stb             I2C_TXR,x
 00FFE4C9 0A7004                          sta             I2C_CMD,x
 00FFE4CB 08DFF0                          bsr             i2c_wait_tip
 00FFE4CD 0E6004                          ldb             I2C_STAT,x
 00FFE4CF 039                             rts
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Parameters
                              ;               x - I2C controller base address
                              ;               accb - data to send
                              ; Returns: none
                              ; Stack space: 2 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              i2c_xmit1:
 00FFE4D0 034006                          pshs    d                                                               ; save data value
 00FFE4D2 034006                          pshs    d                                                               ; and save it again
 00FFE4D4 0C6001                          ldb             #1
 00FFE4D6 0E7002                          stb             I2C_CTRL,x                      ; enable the core
 00FFE4D8 0C6076                          ldb             #$76                                            ; set slave address = %0111011
 00FFE4DA 086090                          lda             #$90                                            ; set STA, WR
 00FFE4DC 08DFE9                          bsr             i2c_wr_cmd
 00FFE4DE 08D00A                          bsr             i2c_wait_rx_nack
 00FFE4E0 035006                          puls    d                                                               ; get back data value
 00FFE4E2 086050                          lda             #$50                                            ; set STO, WR
 00FFE4E4 08DFE1                          bsr             i2c_wr_cmd
 00FFE4E6 08D002                          bsr             i2c_wait_rx_nack
 00FFE4E8 035086                          puls    d,pc
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              i2c_wait_rx_nack:
 00FFE4EA 034004                          pshs    b                                                               ; save off accb
                              i2cwr1:
 00FFE4EC 0E6004                          ldb             I2C_STAT,x                      ; wait for RXack = 0
 00FFE4EE 0C5080                          bitb    #$80                                            ; test for nack
 00FFE4F0 026FFA                          bne             i2cwr1
 00FFE4F2 035084                          puls    b,pc
 
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; BSD 3-Clause License
                              ; Redistribution and use in source and binary forms, with or without
                              ; modification, are permitted provided that the following conditions are met:
                              ;
                              ; 1. Redistributions of source code must retain the above copyright notice, this
                              ;    list of conditions and the following disclaimer.
                              ;
                              ; 2. Redistributions in binary form must reproduce the above copyright notice,
                              ;    this list of conditions and the following disclaimer in the documentation
                              ;    and/or other materials provided with the distribution.
                              ;
                              ; 3. Neither the name of the copyright holder nor the names of its
                              ;    contributors may be used to endorse or promote products derived from
                              ;    this software without specific prior written permission.
                              ;
                              ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                              ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                              ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                              ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                              ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                              ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                              ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                              ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                              ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                              ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                              ;
                              ; ============================================================================
 
                              ;===============================================================================
                              ; Realtime clock routines
                              ;===============================================================================
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Read the real-time-clock chip.
                              ;
                              ; The entire contents of the clock registers and sram are read into a buffer
                              ; in one-shot rather than reading the registers individually.
                              ;
                              ; Parameters: none
                              ; Returns: d = 0 on success, otherwise non-zero
                              ; Modifies: d and RTCBuf
                              ; Stack space: 6 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              rtc_read:
 00FFE4F4 08EE30500                       ldx                     #RTC
 00FFE4F7 18E007FC0                       ldy                     #RTCBuf
 00FFE4FA 0C6080                          ldb                     #$80
 00FFE4FC 0E7002                          stb                     I2C_CTRL,x              ; enable I2C
 00FFE4FE 0CC0900DE                       ldd                     #$900DE                         ; read address, write op, STA + wr bit
 00FFE501 08DFC4                          bsr                     i2c_wr_cmd
 00FFE503 0C5080                          bitb            #$80
 00FFE505 02603C                          bne                     rtc_rxerr
 00FFE507 0CC010000                       ldd                     #$10000                         ; address zero, wr bit
 00FFE50A 08DFBB                          bsr                     i2c_wr_cmd
 00FFE50C 0C5080                          bitb            #$80
 00FFE50E 026033                          bne                     rtc_rxerr
 00FFE510 0CC0900DF                       ldd                     #$900DF                         ; read address, read op, STA + wr bit
 00FFE513 08DFB2                          bsr                     i2c_wr_cmd
 00FFE515 0C5080                          bitb            #$80
 00FFE517 02602A                          bne                     rtc_rxerr
                                      
 00FFE519 05F                             clrb
                              rtcr0001:
 00FFE51A 086020                          lda                     #$20
 00FFE51C 0A7004                          sta                     I2C_CMD,x                       ; rd bit
 00FFE51E 08DF9D                          bsr                     i2c_wait_tip
 00FFE520 08DFC8                          bsr                     i2c_wait_rx_nack
 00FFE522 0A6004                          lda                     I2C_STAT,x
 00FFE524 085080                          bita            #$80
 00FFE526 02601B                          bne                     rtc_rxerr
 00FFE528 0A6003                          lda                     I2C_RXR,x
 00FFE52A 0A7A07                          sta                     b,y
 00FFE52C 05C                             incb
 00FFE52D 0C105F                          cmpb            #$5F
 00FFE52F 025FE9                          blo                     rtcr0001
 00FFE531 086068                          lda                     #$68
 00FFE533 0A7004                          sta                     I2C_CMD,x                       ; STO, rd bit + nack
 00FFE535 08DF86                          bsr                     i2c_wait_tip
 00FFE537 0A6004                          lda                     I2C_STAT,x
 00FFE539 085080                          bita            #$80
 00FFE53B 026006                          bne                     rtc_rxerr
 00FFE53D 0A6003                          lda                     I2C_RXR,x
 00FFE53F 0A7A07                          sta                     b,y
 00FFE541 04F05F                          clrd                                                                    ; return 0
                              rtc_rxerr:
 00FFE543 06F002                          clr                     I2C_CTRL,x      ; disable I2C and return status
 00FFE545 04F                             clra
 00FFE546 039                             rts
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Write the real-time-clock chip.
                              ;
                              ; The entire contents of the clock registers and sram are written from a 
                              ; buffer (RTCBuf) in one-shot rather than writing the registers individually.
                              ;
                              ; Parameters: none
                              ; Returns: r1 = 0 on success, otherwise non-zero
                              ; Modifies: r1 and RTCBuf
                              ; Stack space: 6 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              rtc_write:
 00FFE547 08EE30500                       ldx             #RTC
 00FFE54A 18E007FC0                       ldy             #RTCBuf
                                      
 00FFE54D 0C6080                          ldb             #$80
 00FFE54F 0E7002                          stb             I2C_CTRL,x              ; enable I2C
 00FFE551 0CC0900DE                       ldd             #$900DE                         ; read address, write op, STA + wr bit
 00FFE554 08DF71                          bsr             i2c_wr_cmd
 00FFE556 0C5080                          bitb    #$80
 00FFE558 026FE9                          bne             rtc_rxerr
 00FFE55A 0CC010000                       ldd             #$10000                         ; address zero, wr bit
 00FFE55D 08DF68                          bsr             i2c_wr_cmd
 00FFE55F 0C5080                          bitb    #$80
 00FFE561 026FE0                          bne             rtc_rxerr
 
 00FFE563 0C6000                          ldb             #0
                              rtcw0001:
 00FFE565 034004                          pshs    b
 00FFE567 0E6A05                          ldb             b,y
 00FFE569 086010                          lda             #$10
 00FFE56B 08DF5A                          bsr             i2c_wr_cmd
 00FFE56D 0C5080                          bitb    #$80
 00FFE56F 035004                          puls    b
 00FFE571 026FD0                          bne             rtc_rxerr
 00FFE573 05C                             incb
 00FFE574 0C105F                          cmpb    #$5F
 00FFE576 025FED                          blo             rtcw0001
 00FFE578 0E6A05                          ldb             b,y
 00FFE57A 086050                          lda             #$50                                    ; STO, wr bit
 00FFE57C 08DF49                          bsr             i2c_wr_cmd
 00FFE57E 0C5080                          bitb    #$80
 00FFE580 026FC1                          bne             rtc_rxerr
 00FFE582 04F05F                          clrd                                                            ; return 0
 00FFE584 06F002                          clr             I2C_CTRL,x              ; disable I2C and return status
 00FFE586 039                             rts
 
                              ;==============================================================================
                              ; Keyboard I/O
                              ;==============================================================================
 
                                      ;--------------------------------------------------------------------------
                                      ; PS2 scan codes to ascii conversion tables.
                                      ;--------------------------------------------------------------------------
                                      ;
                                      org     (* + 127) & $FFFFFF80
 
                              unshiftedScanCodes:
 00FFE600 02E0A902E0A50A30A10A2           fcb     $2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
 00FFE607 0AC
 00FFE608 02E0AA0A80A60A4009060           fcb     $2e,$aa,$a8,$a6,$a4,$09,$60,$2e
 00FFE60F 02E
 00FFE610 02E02E02E02E02E071031           fcb     $2e,$2e,$2e,$2e,$2e,$71,$31,$2e
 00FFE617 02E
 00FFE618 02E02E07A073061077032           fcb     $2e,$2e,$7a,$73,$61,$77,$32,$2e
 00FFE61F 02E
 00FFE620 02E063078064065034033           fcb     $2e,$63,$78,$64,$65,$34,$33,$2e
 00FFE627 02E
 00FFE628 02E020076066074072035           fcb     $2e,$20,$76,$66,$74,$72,$35,$2e
 00FFE62F 02E
 00FFE630 02E06E062068067079036           fcb     $2e,$6e,$62,$68,$67,$79,$36,$2e
 00FFE637 02E
 00FFE638 02E02E06D06A075037038           fcb     $2e,$2e,$6d,$6a,$75,$37,$38,$2e
 00FFE63F 02E
 00FFE640 02E02C06B06906F030039           fcb     $2e,$2c,$6b,$69,$6f,$30,$39,$2e
 00FFE647 02E
 00FFE648 02E02E02F06C03B07002D           fcb     $2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
 00FFE64F 02E
 00FFE650 02E02E02702E05B03D02E           fcb     $2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
 00FFE657 02E
 00FFE658 0AD02E00D05D02E05C02E           fcb     $ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
 00FFE65F 02E
 00FFE660 02E02E02E02E02E02E008           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
 00FFE667 02E
 00FFE668 02E09502E09309402E02E           fcb     $2e,$95,$2e,$93,$94,$2e,$2e,$2e
 00FFE66F 02E
 00FFE670 09807F09202E09109001B           fcb     $98,$7f,$92,$2e,$91,$90,$1b,$af
 00FFE677 0AF
 00FFE678 0AB02E09702E02E0960AE           fcb     $ab,$2e,$97,$2e,$2e,$96,$ae,$2e
 00FFE67F 02E
 
 00FFE680 02E02E02E0A702E02E02E           fcb     $2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
 00FFE687 02E
 00FFE688 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE68F 02E
 00FFE690 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE697 02E
 00FFE698 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE69F 02E
 00FFE6A0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE6A7 02E
 00FFE6A8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE6AF 02E
 00FFE6B0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE6B7 02E
 00FFE6B8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE6BF 02E
 00FFE6C0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE6C7 02E
 00FFE6C8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE6CF 02E
 00FFE6D0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE6D7 02E
 00FFE6D8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE6DF 02E
 00FFE6E0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE6E7 02E
 00FFE6E8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE6EF 02E
 00FFE6F0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE6F7 02E
 00FFE6F8 02E02E0FA02E02E02E02E           fcb     $2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
 00FFE6FF 02E
 
                              shiftedScanCodes:
 00FFE700 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE707 02E
 00FFE708 02E02E02E02E02E00907E           fcb     $2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
 00FFE70F 02E
 00FFE710 02E02E02E02E02E051021           fcb     $2e,$2e,$2e,$2e,$2e,$51,$21,$2e
 00FFE717 02E
 00FFE718 02E02E05A053041057040           fcb     $2e,$2e,$5a,$53,$41,$57,$40,$2e
 00FFE71F 02E
 00FFE720 02E043058044045024023           fcb     $2e,$43,$58,$44,$45,$24,$23,$2e
 00FFE727 02E
 00FFE728 02E020056046054052025           fcb     $2e,$20,$56,$46,$54,$52,$25,$2e
 00FFE72F 02E
 00FFE730 02E04E04204804705905E           fcb     $2e,$4e,$42,$48,$47,$59,$5e,$2e
 00FFE737 02E
 00FFE738 02E02E04D04A05502602A           fcb     $2e,$2e,$4d,$4a,$55,$26,$2a,$2e
 00FFE73F 02E
 00FFE740 02E03C04B04904F029028           fcb     $2e,$3c,$4b,$49,$4f,$29,$28,$2e
 00FFE747 02E
 00FFE748 02E03E03F04C03A05005F           fcb     $2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
 00FFE74F 02E
 00FFE750 02E02E02202E07B02B02E           fcb     $2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
 00FFE757 02E
 00FFE758 02E02E00D07D02E07C02E           fcb     $2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
 00FFE75F 02E
 00FFE760 02E02E02E02E02E02E008           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
 00FFE767 02E
 00FFE768 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE76F 02E
 00FFE770 02E07F02E02E02E02E01B           fcb     $2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
 00FFE777 02E
 00FFE778 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE77F 02E
 
 00FFE780 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE787 02E
 00FFE788 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE78F 02E
 00FFE790 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE797 02E
 00FFE798 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE79F 02E
 00FFE7A0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7A7 02E
 00FFE7A8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7AF 02E
 00FFE7B0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7B7 02E
 00FFE7B8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7BF 02E
 00FFE7C0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7C7 02E
 00FFE7C8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7CF 02E
 00FFE7D0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7D7 02E
 00FFE7D8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7DF 02E
 00FFE7E0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7E7 02E
 00FFE7E8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7EF 02E
 00FFE7F0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7F7 02E
 00FFE7F8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7FF 02E
 
                              ; control
                              keybdControlCodes:
 00FFE800 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE807 02E
 00FFE808 02E02E02E02E02E00907E           fcb     $2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
 00FFE80F 02E
 00FFE810 02E02E02E02E02E011021           fcb     $2e,$2e,$2e,$2e,$2e,$11,$21,$2e
 00FFE817 02E
 00FFE818 02E02E01A013001017040           fcb     $2e,$2e,$1a,$13,$01,$17,$40,$2e
 00FFE81F 02E
 00FFE820 02E003018004005024023           fcb     $2e,$03,$18,$04,$05,$24,$23,$2e
 00FFE827 02E
 00FFE828 02E020016006014012025           fcb     $2e,$20,$16,$06,$14,$12,$25,$2e
 00FFE82F 02E
 00FFE830 02E00E00200800701905E           fcb     $2e,$0e,$02,$08,$07,$19,$5e,$2e
 00FFE837 02E
 00FFE838 02E02E00D00A01502602A           fcb     $2e,$2e,$0d,$0a,$15,$26,$2a,$2e
 00FFE83F 02E
 00FFE840 02E03C00B00900F029028           fcb     $2e,$3c,$0b,$09,$0f,$29,$28,$2e
 00FFE847 02E
 00FFE848 02E03E03F00C03A01005F           fcb     $2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
 00FFE84F 02E
 00FFE850 02E02E02202E07B02B02E           fcb     $2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
 00FFE857 02E
 00FFE858 02E02E00D07D02E07C02E           fcb     $2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
 00FFE85F 02E
 00FFE860 02E02E02E02E02E02E008           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
 00FFE867 02E
 00FFE868 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE86F 02E
 00FFE870 02E07F02E02E02E02E01B           fcb     $2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
 00FFE877 02E
 00FFE878 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE87F 02E
 
                              keybdExtendedCodes:
 00FFE880 02E02E02E02E0A30A10A2           fcb     $2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
 00FFE887 02E
 00FFE888 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE88F 02E
 00FFE890 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE897 02E
 00FFE898 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE89F 02E
 00FFE8A0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE8A7 02E
 00FFE8A8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE8AF 02E
 00FFE8B0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE8B7 02E
 00FFE8B8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE8BF 02E
 00FFE8C0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE8C7 02E
 00FFE8C8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE8CF 02E
 00FFE8D0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE8D7 02E
 00FFE8D8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE8DF 02E
 00FFE8E0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE8E7 02E
 00FFE8E8 02E09502E09309402E02E           fcb     $2e,$95,$2e,$93,$94,$2e,$2e,$2e
 00FFE8EF 02E
 00FFE8F0 09809909202E09109002E           fcb     $98,$99,$92,$2e,$91,$90,$2e,$2e
 00FFE8F7 02E
 00FFE8F8 02E02E09702E02E09602E           fcb     $2e,$2e,$97,$2e,$2e,$96,$2e,$2e
 00FFE8FF 02E
 
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2013-2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ;       Keyboard driver routines to interface to a PS2 style keyboard
                              ; Converts the scancode to ascii
                              ;
                              ; This source file is free software: you can redistribute it and/or modify 
                              ; it under the terms of the GNU Lesser General Public License as published 
                              ; by the Free Software Foundation, either version 3 of the License, or     
                              ; (at your option) any later version.                                      
                              ;                                                                          
                              ; This source file is distributed in the hope that it will be useful,      
                              ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                              ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                              ; GNU General Public License for more details.                             
                              ;                                                                          
                              ; You should have received a copy of the GNU General Public License        
                              ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                              ;                                                                          
                              ; ============================================================================
                              ;
                              SC_F12  EQU     $07
                              SC_C    EQU             $21
                              SC_T    EQU         $2C
                              SC_Z            EQU     $1A
                              SC_DEL  EQU                     $71     ; extend
                              SC_KEYUP        EQU             $F0     ; should be $f0
                              SC_EXTEND EQU     $E0
                              SC_CTRL EQU                     $14
                              SC_RSHIFT               EQU     $59
                              SC_NUMLOCK      EQU     $77
                              SC_SCROLLLOCK           EQU     $7E
                              SC_CAPSLOCK             EQU             $58
                              SC_ALT  EQU                     $11
 
                              ;#define SC_LSHIFT      EQU             $12
                              ;SC_DEL         EQU             $71             ; extend
                              ;SC_LCTRL       EQU             $58
 
                              SC_TAB  EQU     $0D
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Recieve a byte from the keyboard, used after a command is sent to the
                              ; keyboard in order to wait for a response.
                              ;
                              ; Parameters: none
                              ; Returns: accd = recieved byte ($00 to $FF), -1 on timeout
                              ; Modifies: acc
                              ; Stack Space: 2 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdRecvByte:
 00FFE900 034010                          pshs    x
 00FFE902 08E000064                       ldx             #100                                            ; wait up to 1s
                              krb3:
 00FFE905 08D05A                          bsr             KeybdGetStatus  ; wait for response from keyboard
 00FFE907 05D                             tstb
 00FFE908 02B00B                          bmi             krb4                                            ; is input buffer full ? yes, branch
 00FFE90A 08D02D                          bsr             Wait10ms                                ; wait a bit
 00FFE90C 0301FF                          dex
 00FFE90E 026FF5                          bne             krb3                                            ; go back and try again
 00FFE910 0CCFFFFFF                       ldd             #-1                                                     ; return -1
 00FFE913 035090                          puls    x,pc
                              krb4:
 00FFE915 08D066                          bsr             KeybdGetScancode
 00FFE917 035090                          puls    x,pc
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Send a byte to the keyboard.
                              ;
                              ; Parameters: accb byte to send
                              ; Returns: none
                              ; Modifies: none
                              ; Stack Space: 0 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdSendByte:
 00FFE919 0150F7FFFE30400                 stb             KEYBD
 00FFE91E 039                             rts
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Wait until the keyboard transmit is complete
                              ;
                              ; Parameters: none
                              ; Returns: r1 = 0 if successful, r1 = -1 timeout
                              ; Modifies: r1
                              ; Stack Space: 3 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdWaitTx:
 00FFE91F 034010                          pshs    x
 00FFE921 08E000064                       ldx             #100                            ; wait a max of 1s
                              kwt1:
 00FFE924 08D03B                          bsr             KeybdGetStatus
 00FFE926 0C4040                          andb    #$40                            ; check for transmit complete bit; branch if bit set
 00FFE928 02600B                          bne             kwt2
 00FFE92A 08D00D                          bsr             Wait10ms                ; delay a little bit
 00FFE92C 0301FF                          dex
 00FFE92E 026FF4                          bne             kwt1                            ; go back and try again
 00FFE930 0CCFFFFFF                       ldd             #-1                                     ; timed out, return -1
 00FFE933 035090                          puls    x,pc
                              kwt2:
 00FFE935 04F                             clra                                                    ; wait complete, return 0
 00FFE936 05F                             clrb                                                    
 00FFE937 035090                          puls    x,pc                            
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Wait for 10 ms
                              ;
                              ; Parameters: none
                              ; Returns: none
                              ; Modifies: none
                              ; Stack Space: 2 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              Wait10ms:
 00FFE939 034006                          pshs    d
 00FFE93B 0150B6FFFFFFFE7                 lda             MSCOUNT+3
                              W10_0001:
 00FFE940 01F089                          tfr             a,b
 00FFE942 0150F0FFFFFFFE7                 subb    MSCOUNT+3
 00FFE947 0C1FFA                          cmpb    #$FFA
 00FFE949 022FF5                          bhi             W10_0001
 00FFE94B 035086                          puls    d,pc
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Wait for 300 ms (256 ms)
                              ;
                              ; Parameters: none
                              ; Returns: none
                              ; Modifies: none
                              ; Stack Space: 2 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              Wait300ms:
 00FFE94D 034006                          pshs    d
 00FFE94F 0150B6FFFFFFFE7                 lda             MSCOUNT+3
                              W300_0001:
 00FFE954 01F089                          tfr             a,b
 00FFE956 0150F0FFFFFFFE7                 subb    MSCOUNT+3
 00FFE95B 0C1F00                          cmpb    #$F00
 00FFE95D 022FF5                          bhi     W300_0001
 00FFE95F 035086                          puls    d,pc
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Get the keyboard status
                              ;
                              ; Parameters: none
                              ; Returns: d = status
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdGetStatus:
                              kbgs3:
 00FFE961 0150F6FFFE30401                 ldb             KEYBD+1
 00FFE966 0C5080                          bitb    #$80
 00FFE968 02600E                          bne             kbgs1
 00FFE96A 0C5001                          bitb    #$01            ; check parity error flag
 00FFE96C 026002                          bne             kbgs2
 00FFE96E 04F                             clra
 00FFE96F 039                             rts
                              kbgs2:
 00FFE970 0C60FE                          ldb             #$FE            ; request resend
 00FFE972 08DFA5                          bsr             KeybdSendByte
 00FFE974 08DFA9                          bsr             KeybdWaitTx
 00FFE976 020FE9                          bra             kbgs3
                              kbgs1:                                  ; return negative status
 00FFE978 0CAF00                          orb             #$F00
 00FFE97A 086FFF                          lda             #-1
 00FFE97C 039                             rts
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Get the scancode from the keyboard port
                              ;
                              ; Parameters: none
                              ; Returns: acca = scancode
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdGetScancode:
 00FFE97D 04F                             clra
 00FFE97E 0150F6FFFE30400                 ldb             KEYBD                           ; get the scan code
 00FFE983 01507FFFFE30401                 clr             KEYBD+1                 ; clear receive register (write $00 to status reg)
 00FFE988 039                             rts
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Set the LEDs on the keyboard.
                              ;
                              ; Parameters: d LED status to set
                              ; Returns: none
                              ; Modifies: none
                              ; Stack Space: 2 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdSetLED:
 00FFE989 034004                          pshs    b
 00FFE98B 0C60ED                          ldb             #$ED                                            ; set LEDs command
 00FFE98D 08DF8A                          bsr             KeybdSendByte
 00FFE98F 08DF8E                          bsr             KeybdWaitTx
 00FFE991 08DF6D                          bsr             KeybdRecvByte   ; should be an ack
 00FFE993 035004                          puls    b
 00FFE995 08DF82                          bsr             KeybdSendByte
 00FFE997 08DF86                          bsr             KeybdWaitTx
 00FFE999 08DF65                          bsr             KeybdRecvByte   ; should be an ack
 00FFE99B 039                             rts
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Get ID - get the keyboards identifier code.
                              ;
                              ; Parameters: none
                              ; Returns: d = $AB83, $00 on fail
                              ; Modifies: d, KeybdID updated
                              ; Stack Space: 2 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdGetID:
 00FFE99C 0C60F2                          ldb             #$F2
 00FFE99E 08DF79                          bsr             KeybdSendByte
 00FFE9A0 08DF7D                          bsr             KeybdWaitTx
 00FFE9A2 08DF5C                          bsr             KeybdRecvByte
 00FFE9A4 0C5080                          bitb    #$80
 00FFE9A6 026014                          bne             kgnotKbd
 00FFE9A8 0C10AB                          cmpb    #$AB
 00FFE9AA 026010                          bne             kgnotKbd
 00FFE9AC 08DF52                          bsr             KeybdRecvByte
 00FFE9AE 0C5080                          bitb    #$80
 00FFE9B0 02600A                          bne             kgnotKbd
 00FFE9B2 0C1083                          cmpb    #$83
 00FFE9B4 026006                          bne             kgnotKbd
 00FFE9B6 0CC00AB83                       ldd             #$AB83
                              kgid1:
 00FFE9B9 0DD124                          std             KeybdID
 00FFE9BB 039                             rts
                              kgnotKbd:
 00FFE9BC 04F                             clra
 00FFE9BD 05F                             clrb
 00FFE9BE 020FF9                          bra             kgid1
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Initialize the keyboard.
                              ;
                              ; Parameters:
                              ;               none
                              ;       Modifies:
                              ;               none
                              ; Returns:
                              ;               none
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdInit:
 00FFE9C0 034026                          pshs    d,y
 00FFE9C2 18E000005                       ldy             #5
 00FFE9C5 00F120                          clr             KeyState1               ; records key up/down state
 00FFE9C7 00F121                          clr             KeyState2               ; records shift,ctrl,alt state
                              kbdi0002:
 00FFE9C9 08DF6E                          bsr             Wait10ms
 00FFE9CB 01507FFFFE30401                 clr             KEYBD+1                 ; clear receive register (write $00 to status reg)
 00FFE9D0 0C6FFF                          ldb             #-1                                     ; send reset code to keyboard
 00FFE9D2 0150F7FFFE30401                 stb             KEYBD+1                 ; write $FF to status reg to clear TX state
 00FFE9D7 08DF40                          bsr             KeybdSendByte   ; now write to transmit register
 00FFE9D9 08DF44                          bsr             KeybdWaitTx             ; wait until no longer busy
 00FFE9DB 08DF23                          bsr             KeybdRecvByte   ; look for an ACK ($FA)
 00FFE9DD 0C10FA                          cmpb    #$FA
 00FFE9DF 026021                          bne             kbdiTryAgain
 00FFE9E1 08DF1D                          bsr             KeybdRecvByte   ; look for BAT completion code ($AA)
 00FFE9E3 0C10FC                          cmpb    #$FC                            ; reset error ?
 00FFE9E5 02701B                          beq             kbdiTryAgain
 00FFE9E7 0C10AA                          cmpb    #$AA                            ; reset complete okay ?
 00FFE9E9 026017                          bne             kbdiTryAgain
 
                                      ; After a reset, scan code set #2 should be active
                              .config:
 00FFE9EB 0C60F0                          ldb             #$F0                    ; send scan code select
 00FFE9ED 0150F7FFFE60001                 stb             LEDS
 00FFE9F2 08DF25                          bsr             KeybdSendByte
 00FFE9F4 08DF29                          bsr             KeybdWaitTx
 00FFE9F6 05D                             tstb
 00FFE9F7 02B009                          bmi             kbdiTryAgain
 00FFE9F9 08DF05                          bsr             KeybdRecvByte   ; wait for response from keyboard
 00FFE9FB 04D                             tsta
 00FFE9FC 02B004                          bmi             kbdiTryAgain
 00FFE9FE 0C10FA                          cmpb    #$FA                                    ; ACK
 00FFEA00 02700C                          beq             kbdi0004
                              kbdiTryAgain:
 00FFEA02 0313FF                          dey
 00FFEA04 026FC3                          bne       kbdi0002
                              .keybdErr:
 00FFEA06 0CCFFEA2E                       ldd             #msgBadKeybd
 00FFEA09 017FFF9EE                       lbsr    DisplayStringCRLF
*** warning 1: Long branch within short branch range could be optimized
 00FFEA0C 020014                          bra             ledxit
                              kbdi0004:
 00FFEA0E 0C6002                          ldb             #2                      ; select scan code set #2
 00FFEA10 08DF07                          bsr             KeybdSendByte
 00FFEA12 08DF0B                          bsr             KeybdWaitTx
 00FFEA14 05D                             tstb
 00FFEA15 02BFEB                          bmi             kbdiTryAgain
 00FFEA17 08DEE7                          bsr             KeybdRecvByte   ; wait for response from keyboard
 00FFEA19 04D                             tsta
 00FFEA1A 02BFE6                          bmi             kbdiTryAgain
 00FFEA1C 0C10FA                          cmpb    #$FA
 00FFEA1E 026FE2                          bne             kbdiTryAgain
 00FFEA20 08DF7A                          bsr             KeybdGetID
                              ledxit:
 00FFEA22 0C6007                          ldb             #$07
 00FFEA24 08DF63                          bsr             KeybdSetLED
 00FFEA26 08DF25                          bsr             Wait300ms
 00FFEA28 0C6000                          ldb             #$00
 00FFEA2A 08DF5D                          bsr             KeybdSetLED
 00FFEA2C 0350A6                          puls    d,y,pc
 
                              msgBadKeybd:
 00FFEA2E 04B06507906206F061072           fcb             "Keyboard error",0
 00FFEA35 06402006507207206F072
 00FFEA3C 000
 
                              ;------------------------------------------------------------------------------
                              ; Calculate number of character in input buffer
                              ;
                              ; Parameters:
                              ;               y = $Cn00000 where n is core id
                              ; Returns:
                              ;               d = number of bytes in buffer.
                              ;------------------------------------------------------------------------------
 
                              kbdRcvCount:
 00FFEA3D 04F                             clra
 00FFEA3E 0E6A08128                       ldb             kbdTailRcv,y
 00FFEA41 0E0A08127                       subb    kbdHeadRcv,y
 00FFEA44 02C008                          bge             krcXit
 00FFEA46 0C6040                          ldb             #$40
 00FFEA48 0E0A08127                       subb    kbdHeadRcv,y
 00FFEA4B 0EBA08128                       addb    kbdTailRcv,y
                              krcXit:
 00FFEA4E 039                             rts
 
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdIRQ:
 00FFEA4F 0150B6FFFE30401                 lda             KEYBD+1                                         ; check status
 00FFEA54 085080                          bita    #$80                                                    ; was key pressed?
 00FFEA56 027034                          beq             notKbdIRQ                                       ; if not, exit
 00FFEA58 0150F6FFFE30400                 ldb             KEYBD                                                   ; get the scan code
 00FFEA5D 01507FFFFE30401                 clr             KEYBD+1                                         ; clear receive register (write $00 to status reg)
 00FFEA62 034004                          pshs    b                                                                       ; save it off
 00FFEA64 0B6FFC010                       lda             IOFocusID                                       ; compute core memory address $Cn0000
 00FFEA67 05F                             clrb
 00FFEA68 048                             asla
 00FFEA69 048                             asla
 00FFEA6A 048                             asla
 00FFEA6B 048                             asla
 00FFEA6C 08AC00                          ora             #$C00                                                   ; address $Cn0000       
 00FFEA6E 01F002                          tfr             d,y                                                             ; y =
 00FFEA70 08DFCB                          bsr             kbdRcvCount                             ; get count of scan codes in buffer
 00FFEA72 0C1040                          cmpb    #64                                                             ; check if buffer full?
 00FFEA74 024017                          bhs             kbdBufFull                              ; if buffer full, ignore new keystroke
 00FFEA76 01F021                          tfr             y,x                                                             ; compute fifo address
 00FFEA78 0E6A08128                       ldb             kbdTailRcv,y                    ; b = buffer index
 00FFEA7B 035002                          puls    a                                                                       ; get back scancode
 00FFEA7D 030040                          leax    kbdFifo,x                                       ; x = base address for fifo
 00FFEA7F 0A7845                          sta             b,x                                                             ; store in buffer
 00FFEA81 05C                             incb                                                                            ; increment buffer index
 00FFEA82 0C403F                          andb    #$3f                                                    ; wrap around at 64 chars
 00FFEA84 0E7A08128                       stb             kbdTailRcv,y                    ; update it
 00FFEA87 08601C                          lda             #28                                                             ; Keyboard is IRQ #28
 00FFEA89 0B7FFC011                       sta             IrqSource                                       ; stuff a byte indicating the IRQ source for PEEK()
                              notKbdIRQ:
 00FFEA8C 039                             rts     
                              kbdBufFull:
 00FFEA8D 032601                          leas    1,s                                                             ; get rid of saved scancode
 00FFEA8F 039                             rts
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              DBGCheckForKey:
 00FFEA90 020ECF                          bra             KeybdGetStatus
 
 
                              ; KeyState2 variable bit meanings
                              ;1176543210
                              ; ||||||||+ = shift
                              ; |||||||+- = alt
                              ; ||||||+-- = control
                              ; |||||+--- = numlock
                              ; ||||+---- = capslock
                              ; |||+----- = scrolllock
                              ; ||+------ = <empty>
                              ; |+------- =    "
                              ; |         =    "
                              ; |         =    "
                              ; |         =    "
                              ; +-------- = extended
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Keyboard get routine.
                              ;
                              ; The routine may get characters directly from the scancode input or less
                              ; directly from the scancode buffer, if things are interrupt driven.
                              ;
                              ; Parameters:
                              ;               b:  bit 11 = blocking status 1=blocking, 0=non blocking
                              ;               b:      bit 1  = scancode source 1=scancode buffer, 0=direct
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              GetKey:
 00FFEA92 034030                          pshs    x,y
 00FFEA94 0D7126                          stb             KeybdBlock                              ; save off blocking status
                              dbgk2:
 00FFEA96 0D6126                          ldb             KeybdBlock
 00FFEA98 034004                          pshs    b
 00FFEA9A 0C5001                          bitb    #1                                                              ; what is the scancode source
 00FFEA9C 02701A                          beq             dbgk20                                          ; branch if direct read
 00FFEA9E 0150B6FFFFFFFE0                 lda             COREID                                          ; compute core memory address
 00FFEAA3 05F                             clrb
 00FFEAA4 048                             asla
 00FFEAA5 048                             asla
 00FFEAA6 048                             asla
 00FFEAA7 048                             asla
 00FFEAA8 08AC00                          ora             #$C00
 00FFEAAA 01F002                          tfr             d,y                                                             ; y = $Cn0000
 00FFEAAC 08DF8F                          bsr             kbdRcvCount
 00FFEAAE 05D                             tstb                                                                            ; anything in buffer?
 00FFEAAF 035004                          puls    b
 00FFEAB1 026018                          bne             dbgk1                                                   ; branch if something in buffer
 00FFEAB3 05D                             tstb
 00FFEAB4 02BFE0                          bmi             dbgk2                                                   ; if no key and blocking - loop
 00FFEAB6 02000E                          bra             dbgk24
                              dbgk20:
 00FFEAB8 18E000000                       ldy             #0
 00FFEABB 08DEA4                          bsr             KeybdGetStatus
 00FFEABD 0C4080                          andb    #$80                                                    ; is key available?
 00FFEABF 035004                          puls    b
 00FFEAC1 026008                          bne             dbgk1                                                   ; branch if key
 00FFEAC3 05D                             tstb                                                                            ; block?
 00FFEAC4 02BFD0                          bmi             dbgk2                                                   ; If no key and blocking - loop
                              dbgk24:
 00FFEAC6 0CCFFFFFF                       ldd             #-1                                                             ; return -1 if no block and no key
 00FFEAC9 0350B0                          puls    x,y,pc
                              dbgk1:
 00FFEACB 18C000000                       cmpy    #0
 00FFEACE 026004                          bne             dbgk22
 00FFEAD0 08DEAB                          bsr             KeybdGetScancode        ; get scancode directly
 00FFEAD2 020011                          bra             dbgk23
                              dbgk22:
                                      ; Retrieve value from scancode buffer
 00FFEAD4 01F021                          tfr             y,x
 00FFEAD6 030040                          leax    kbdFifo,x                                       ; x = fifo address
 00FFEAD8 0E6A08127                       ldb             kbdHeadRcv,y                    ; b = buffer index
 00FFEADB 0A6A0D                          lda             b,x                                                             ; get the scancode
 00FFEADD 05C                             incb                                                                            ; increment fifo index
 00FFEADE 0C403F                          andb    #$3f                                                    ; and wrap around
 00FFEAE0 0E7A08127                       stb             kbdHeadRcv,y                    ; save it back
 00FFEAE3 01F089                          tfr             a,b                                                             ; the scancode is needed in accb
                              dbgk23:
                              ;       lbsr    DispByteAsHex
                                      ; Make sure there is a small delay between scancode reads
 00FFEAE5 08E000014                       ldx             #20
                              dbgk3:
 00FFEAE8 0301FF                          dex
 00FFEAEA 026FFC                          bne             dbgk3
                                      ; switch on scan code
 00FFEAEC 0C10F0                          cmpb    #SC_KEYUP
 00FFEAEE 026004                          bne             dbgk4
 00FFEAF0 0D7120                          stb             KeyState1                                       ; make KeyState1 <> 0
 00FFEAF2 020FA2                          bra             dbgk2                                                   ; loop back
                              dbgk4:
 00FFEAF4 0C10E0                          cmpb    #SC_EXTEND
 00FFEAF6 026008                          bne             dbgk5
 00FFEAF8 096121                          lda             KeyState2
 00FFEAFA 08A800                          ora             #$800
 00FFEAFC 097121                          sta             KeyState2
 00FFEAFE 020F96                          bra             dbgk2
                              dbgk5:
 00FFEB00 0C1014                          cmpb    #SC_CTRL
 00FFEB02 026016                          bne             dbgkNotCtrl
 00FFEB04 00D120                          tst             KeyState1
 00FFEB06 026008                          bne             dbgk7
 00FFEB08 096121                          lda             KeyState2
 00FFEB0A 08A004                          ora             #4
 00FFEB0C 097121                          sta             KeyState2
 00FFEB0E 020006                          bra             dbgk8
                              dbgk7:
 00FFEB10 096121                          lda             KeyState2
 00FFEB12 084FFB                          anda    #~4
 00FFEB14 097121                          sta             KeyState2
                              dbgk8:
 00FFEB16 00F120                          clr             KeyState1
 00FFEB18 020F7C                          bra             dbgk2
                              dbgkNotCtrl:
 00FFEB1A 0C1059                          cmpb    #SC_RSHIFT
 00FFEB1C 026016                          bne             dbgkNotRshift
 00FFEB1E 00D120                          tst             KeyState1
 00FFEB20 026008                          bne             dbgk9
 00FFEB22 096121                          lda             KeyState2
 00FFEB24 08A001                          ora             #1
 00FFEB26 097121                          sta             KeyState2
 00FFEB28 020006                          bra             dbgk10
                              dbgk9:
 00FFEB2A 096121                          lda             KeyState2
 00FFEB2C 084FFE                          anda    #~1
 00FFEB2E 097121                          sta             KeyState2
                              dbgk10:
 00FFEB30 00F120                          clr             KeyState1
 00FFEB32 020F62                          bra             dbgk2
                              dbgkNotRshift:
 00FFEB34 0C1077                          cmpb    #SC_NUMLOCK
 00FFEB36 026013                          bne             dbgkNotNumlock
 00FFEB38 096121                          lda             KeyState2
 00FFEB3A 088010                          eora    #16
 00FFEB3C 097121                          sta             KeyState2
 00FFEB3E 096122                          lda             KeyLED
 00FFEB40 088002                          eora    #2
 00FFEB42 097122                          sta             KeyLED
 00FFEB44 01F089                          tfr             a,b
 00FFEB46 04F                             clra
 00FFEB47 08DE40                          bsr             KeybdSetLED
 00FFEB49 020F4B                          bra             dbgk2
                              dbgkNotNumlock:
 00FFEB4B 0C1058                          cmpb    #SC_CAPSLOCK
 00FFEB4D 026013                          bne             dbgkNotCapslock
 00FFEB4F 096121                          lda             KeyState2
 00FFEB51 088020                          eora    #32
 00FFEB53 097121                          sta             KeyState2
 00FFEB55 096122                          lda             KeyLED
 00FFEB57 088004                          eora    #4
 00FFEB59 097122                          sta             KeyLED
 00FFEB5B 01F089                          tfr             a,b
 00FFEB5D 04F                             clra
 00FFEB5E 08DE29                          bsr             KeybdSetLED
 00FFEB60 020F34                          bra             dbgk2
                              dbgkNotCapslock:
 00FFEB62 0C107E                          cmpb    #SC_SCROLLLOCK
 00FFEB64 026013                          bne             dbgkNotScrolllock
 00FFEB66 096121                          lda             KeyState2
 00FFEB68 088040                          eora    #64
 00FFEB6A 097121                          sta             KeyState2
 00FFEB6C 096122                          lda             KeyLED
 00FFEB6E 088001                          eora    #1
 00FFEB70 097122                          sta             KeyLED
 00FFEB72 01F089                          tfr             a,b
 00FFEB74 04F                             clra
 00FFEB75 08DE12                          bsr             KeybdSetLED
 00FFEB77 020F1D                          bra             dbgk2
                              dbgkNotScrolllock:
 00FFEB79 0C1011                          cmpb    #SC_ALT
 00FFEB7B 026016                          bne             dbgkNotAlt
 00FFEB7D 00D120                          tst             KeyState1
 00FFEB7F 026008                          bne             dbgk11
 00FFEB81 096121                          lda             KeyState2
 00FFEB83 08A002                          ora             #2
 00FFEB85 097121                          sta             KeyState2
 00FFEB87 020006                          bra             dbgk12
                              dbgk11:
 00FFEB89 096121                          lda             KeyState2
 00FFEB8B 084FFD                          anda    #~2
 00FFEB8D 097121                          sta             KeyState2
                              dbgk12:
 00FFEB8F 00F120                          clr             KeyState1
 00FFEB91 020F03                          bra             dbgk2
                              dbgkNotAlt:
 00FFEB93 00D120                          tst             KeyState1
 00FFEB95 027004                          beq             dbgk13
 00FFEB97 00F120                          clr             KeyState1
 00FFEB99 020EFB                          bra             dbgk2
                              dbgk13:
 00FFEB9B 096121                          lda             KeyState2               ; Check for CTRL-ALT-DEL
 00FFEB9D 084006                          anda    #6
 00FFEB9F 081006                          cmpa    #6
 00FFEBA1 026008                          bne             dbgk14
 00FFEBA3 0C1071                          cmpb    #SC_DEL 
 00FFEBA5 026004                          bne             dbgk14
 00FFEBA7 06E90FFFFFFC                    jmp             [$FFFFFC]               ; jump to NMI vector
                              dbgk14:
 00FFEBAB 00D121                          tst             KeyState2               ; extended code?
 00FFEBAD 02A00B                          bpl             dbgk15
 00FFEBAF 096121                          lda             KeyState2
 00FFEBB1 0847FF                          anda    #$7FF
 00FFEBB3 097121                          sta             KeyState2
 00FFEBB5 08EFFE880                       ldx             #keybdExtendedCodes
 00FFEBB8 020017                          bra             dbgk18
                              dbgk15:
 00FFEBBA 096121                          lda             KeyState2               ; Is CTRL down?
 00FFEBBC 085004                          bita    #4
 00FFEBBE 027005                          beq             dbgk16
 00FFEBC0 08EFFE800                       ldx             #keybdControlCodes
 00FFEBC3 02000C                          bra             dbgk18
                              dbgk16:
 00FFEBC5 085001                          bita    #1                                      ; Is shift down?
 00FFEBC7 027005                          beq             dbgk17
 00FFEBC9 08EFFE700                       ldx             #shiftedScanCodes
 00FFEBCC 020003                          bra             dbgk18
                              dbgk17:
 00FFEBCE 08EFFE600                       ldx             #unshiftedScanCodes
                              dbgk18:
 00FFEBD1 0E690FFFE600                    ldb             b,x                                     ; load accb with ascii from table
 00FFEBD5 04F                             clra
 00FFEBD6 0350B0                          puls    x,y,pc                  ; and return
                                      
 
 00FFEBD8 04B04505904204F041052           fcb             "KEYBOARD"
 00FFEBDF 044
 00FFEBE0 FFEBEA                          fcw             KeybdOpen
 00FFEBE2 FFEBEB                          fcw             KeybdClose
 00FFEBE4 FFEBEC                          fcw             KeybdRead
 00FFEBE6 FFEBED                          fcw             KeybdWrite
 00FFEBE8 FFEBEE                          fcw             KeybdSeek
 
                              ; Keyboard Open:
                              ; Initialize the keyboard buffer head and tail indexes
                              ;
                              KeybdOpen:
 00FFEBEA 039                             rts
 
                              ; Keyboard Close:
                              ; Nothing to do except maybe clear the keyboard buffer
                              ;
                              KeybdClose:
 00FFEBEB 039                             rts
                              ;
                              KeybdRead:
 00FFEBEC 039                             rts
                              ;
                              KeybdWrite:
 00FFEBED 039                             rts
 
                              KeybdSeek:
 00FFEBEE 039                             rts
 
                              ;==============================================================================
                              ; Serial I/O
                              ;==============================================================================
 
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; Serial port routines for a WDC6551 compatible circuit.
                              ;
                              ; This source file is free software: you can redistribute it and/or modify 
                              ; it under the terms of the GNU Lesser General Public License as published 
                              ; by the Free Software Foundation, either version 3 of the License, or     
                              ; (at your option) any later version.                                      
                              ;                                                                          
                              ; This source file is distributed in the hope that it will be useful,      
                              ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                              ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                              ; GNU General Public License for more details.                             
                              ;                                                                          
                              ; You should have received a copy of the GNU General Public License        
                              ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                              ;                                                                          
                              ; ============================================================================
                              ;
                              ;------------------------------------------------------------------------------
                              ; Initialize serial port.
                              ;
                              ; Clear buffer indexes. Two bytes are used for the buffer index even though
                              ; only a single byte is needed. This is for convenience in calculating the
                              ; number of characters in the buffer, done later. The upper byte remains at
                              ; zero.
                              ; The port is initialized for 9600 baud, 1 stop bit and 8 bits data sent.
                              ; The internal baud rate generator is used.
                              ;
                              ; Parameters:
                              ;               none
                              ; Modifies:
                              ;               d
                              ; Returns:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              InitSerial:
                              SerialInit:
 00FFEBEF 04F                             clra
 00FFEBF0 05F                             clrb
 00FFEBF1 0DD130                          std             SerHeadRcv-1
 00FFEBF3 0DD132                          std             SerTailRcv-1
 00FFEBF5 0DD135                          std             SerHeadXmit-1
 00FFEBF7 0DD137                          std             SerTailXmit-1
 00FFEBF9 00F139                          clr             SerRcvXon
 00FFEBFB 00F140                          clr             SerRcvXoff
 00FFEBFD 0150B6FFFFFFFE0                 lda             COREID
                              sini1:
 00FFEC02 0B1FFC010                       cmpa    IOFocusID
 00FFEC05 026FFB                          bne             sini1
 00FFEC07 0C6009                          ldb             #$09                                            ; dtr,rts active, rxint enabled, no parity
 00FFEC09 0150F7FFFE30102                 stb             ACIA+ACIA_CMD
 00FFEC0E 0C601E                          ldb             #$1E                                            ; baud 9600, 1 stop bit, 8 bit, internal baud gen
 00FFEC10 0150F7FFFE30103                 stb             ACIA+ACIA_CTRL
 00FFEC15 0C60A6                          ldb             #$0A6                                           ; diable fifos, reset fifos
 00FFEC17 0150F7FFFE3010B                 stb             ACIA+ACIA_CTRL2 
 00FFEC1C 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; SerialGetChar
                              ;
                              ; Check the serial port buffer to see if there's a char available. If there's
                              ; a char available then return it. If the buffer is almost empty then send an
                              ; XON.
                              ;
                              ; Stack Space:
                              ;               2 words
                              ; Parameters:
                              ;               none
                              ; Modifies:
                              ;               none
                              ; Returns:
                              ;               d = character or -1
                              ;------------------------------------------------------------------------------
 
                              SerialGetChar:
 00FFEC1D 034030                                  pshs    x,y
 00FFEC1F 18E000000                               ldy             #0
 00FFEC22 01A010                                  sei                                                                             ; disable interrupts
 00FFEC24 08D082                                  bsr             SerialRcvCount                  ; check number of chars in receive buffer
 00FFEC26 0C1008                                  cmpb    #8                                                      ; less than 8?
 00FFEC28 02200C                                  bhi             sgc2
 00FFEC2A 0D6139                                  ldb             SerRcvXon                               ; skip sending XON if already sent
 00FFEC2C 026008                                  bne       sgc2            ; XON already sent?
 00FFEC2E 0C6011                                  ldb             #XON                                            ; if <8 send an XON
 00FFEC30 00F140                                  clr             SerRcvXoff                      ; clear XOFF status
 00FFEC32 0D7139                                  stb             SerRcvXon                               ; flag so we don't send it multiple times
 00FFEC34 08D052                                  bsr             SerialPutChar
                              sgc2:
 00FFEC36 0D6131                                  ldb             SerHeadRcv                      ; check if anything is in buffer
 00FFEC38 0D1133                                  cmpb    SerTailRcv
 00FFEC3A 02700A                                  beq             sgcNoChars                      ; no?
 00FFEC3C 08EBFF000                               ldx             #SerRcvBuf
 00FFEC3F 04F                                     clra
 00FFEC40 0E6835                                  ldb             b,x                                                     ; get byte from buffer
 00FFEC42 00C131                                  inc             SerHeadRcv                      ; 4k wrap around
 00FFEC44 020003                                  bra             sgcXit
                              sgcNoChars:
 00FFEC46 0CCFFFFFF                               ldd             #-1
                              sgcXit:
 00FFEC49 01C0EF                                  cli
 00FFEC4B 0350B0                                  puls    x,y,pc
 
                              ;------------------------------------------------------------------------------
                              ; SerialPeekChar
                              ;
                              ; Check the serial port buffer to see if there's a char available. If there's
                              ; a char available then return it. But don't update the buffer indexes. No need
                              ; to send an XON here.
                              ;
                              ; Stack Space:
                              ;               0 words
                              ; Parameters:
                              ;               none
                              ; Modifies:
                              ;               none
                              ; Returns:
                              ;               d = character or -1
                              ;------------------------------------------------------------------------------
 
                              SerialPeekChar:
 00FFEC4D 034011                          pshs    x,ccr
 00FFEC4F 01A010                          sei
 00FFEC51 0D6131                          ldb             SerHeadRcv                              ; check if anything is in buffer
 00FFEC53 0D1133                          cmpb    SerTailRcv
 00FFEC55 027008                          beq             spcNoChars                              ; no?
 00FFEC57 08EBFF000                       ldx             #SerRcvBuf
 00FFEC5A 04F                             clra
 00FFEC5B 0E6815                          ldb             b,x                                                             ; get byte from buffer
 00FFEC5D 020003                          bra             spcXit
                              spcNoChars:
 00FFEC5F 0CCFFFFFF                       ldd             #-1
                              spcXit:
 00FFEC62 035091                          puls    x,ccr,pc
 
                              ;------------------------------------------------------------------------------
                              ; SerialPeekChar
                              ;               Get a character directly from the I/O port. This bypasses the input
                              ; buffer.
                              ;
                              ; Stack Space:
                              ;               0 words
                              ; Parameters:
                              ;               none
                              ; Modifies:
                              ;               d
                              ; Returns:
                              ;               d = character or -1
                              ;------------------------------------------------------------------------------
 
                              SerialPeekCharDirect:
 00FFEC64 0150B6FFFFFFFE0                 lda             COREID                                                  ; Ensure we have the IO Focus
 00FFEC69 0B1FFC010                       cmpa    IOFocusID
 00FFEC6C 026014                          bne             spcd0001
                                      ; Disallow interrupts between status read and rx read.
 00FFEC6E 01A010                          sei
 00FFEC70 0150F6FFFE30101                 ldb             ACIA+ACIA_STAT
 00FFEC75 0C5008                          bitb    #8                                                                      ; look for Rx not empty
 00FFEC77 027009                          beq             spcd0001
 00FFEC79 04F                             clra
 00FFEC7A 0150F6FFFE30100                 ldb             ACIA+ACIA_RX
 00FFEC7F 01C0EF                          cli
 00FFEC81 039                             rts
                              spcd0001:
 00FFEC82 0CCFFFFFF                       ldd             #-1
 00FFEC85 01C0EF                          cli
 00FFEC87 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; SerialPutChar
                              ;    Put a character to the serial transmitter. This routine blocks until the
                              ; transmitter is empty. 
                              ;
                              ; Stack Space
                              ;               0 words
                              ; Parameters:
                              ;               b = character to put
                              ; Modifies:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              SerialPutChar:
 00FFEC88 034003                          pshs    a,ccr
                              spc0001:
 00FFEC8A 0150B6FFFFFFFE0                 lda             COREID                                  ; Ensure we have the IO Focus
 00FFEC8F 0B1FFC010                       cmpa    IOFocusID
 00FFEC92 026FF6                          bne             spc0001
 00FFEC94 01C0EF                          cli                                                                             ; provide a window for an interrupt to occur
 00FFEC96 01A010                          sei
                                      ; Between the status read and the transmit do not allow an
                                      ; intervening interrupt.
 00FFEC98 0150B6FFFE30101                 lda             ACIA+ACIA_STAT  ; wait until the uart indicates tx empty
 00FFEC9D 085010                          bita    #16                                                     ; bit #4 of the status reg
 00FFEC9F 027FE9                          beq             spc0001                     ; branch if transmitter is not empty
 00FFECA1 0150F7FFFE30100                 stb             ACIA+ACIA_TX            ; send the byte
 00FFECA6 035083                          puls    a,ccr,pc
 
                              ;------------------------------------------------------------------------------
                              ; Calculate number of character in input buffer
                              ;
                              ; Parameters:
                              ;               y = 0 if current core, otherwise reference to core memory area $Cyxxxx
                              ; Returns:
                              ;               d = number of bytes in buffer.
                              ;------------------------------------------------------------------------------
 
                              SerialRcvCount:
 00FFECA8 04F                             clra
 00FFECA9 0E6A08133                       ldb             SerTailRcv,y
 00FFECAC 0E0A08131                       subb    SerHeadRcv,y
 00FFECAF 02C009                          bge             srcXit
 00FFECB1 0CC001000                       ldd             #$1000
 00FFECB4 0A3A08131                       subd    SerHeadRcv,y
 00FFECB7 0E3A08133                       addd    SerTailRcv,y
                              srcXit:
 00FFECBA 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Serial IRQ routine
                              ;
                              ; Keeps looping as long as it finds characters in the ACIA recieve buffer/fifo.
                              ; Received characters are buffered. If the buffer becomes full, new characters
                              ; will be lost.
                              ;
                              ; Parameters:
                              ;               none
                              ; Modifies:
                              ;               d,x
                              ; Returns:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              SerialIRQ:
                              sirqNxtByte:
 00FFECBB 0150F6FFFE30101                 ldb             ACIA+ACIA_STAT  ; check the status
 00FFECC0 0C5008                          bitb    #$08                                            ; bit 3 = rx full
 00FFECC2 027049                          beq             notRxInt
 00FFECC4 0150F6FFFE30100                 ldb             ACIA+ACIA_RX            ; get data from Rx buffer to clear interrupt
 00FFECC9 0C1014                          cmpb    #CTRLT                                  ; detect special keystroke
 00FFECCB 026000                          bne     sirq0001
                              ;       bsr     DumpTraceQueue
                              sirq0001:
 00FFECCD 034004                          pshs    b
                                      ; Compute receive buffer address
 00FFECCF 0B6FFC010                       lda             IOFocusID
 00FFECD2 048                             asla
 00FFECD3 048                             asla
 00FFECD4 048                             asla
 00FFECD5 048                             asla
 00FFECD6 08AC00                          ora             #$C00
 00FFECD8 05F                             clrb    
 00FFECD9 01F002                          tfr             d,y
 00FFECDB 035004                          puls    b
 00FFECDD 0A6A08133                       lda             SerTailRcv,y                    ; check if recieve buffer full
 00FFECE0 04C                             inca
 00FFECE1 0A1A08131                       cmpa    SerHeadRcv,y
 00FFECE4 027027                          beq             sirqRxFull
 00FFECE6 0A7A08133                       sta             SerTailRcv,y            ; update tail pointer
 00FFECE9 04A                             deca                                                                    ; backup
 00FFECEA 01E089                          exg             a,b
 00FFECEC 030A0A000BFF000                 leax    SerRcvBuf,y                     ; x = buffer address
 00FFECF1 0A7A0F                          sta             b,x                                                     ; store recieved byte in buffer
 00FFECF3 06DA08140                       tst             SerRcvXoff,y            ; check if xoff already sent
 00FFECF6 026FC3                          bne             sirqNxtByte
 00FFECF8 08DFAE                          bsr             SerialRcvCount  ; if more than 4080 chars in buffer
 00FFECFA 0C1FF0                          cmpb    #4080
 00FFECFC 025FBD                          blo             sirqNxtByte
 00FFECFE 0C6013                          ldb             #XOFF                                           ; send an XOFF
 00FFED00 06FA08139                       clr             SerRcvXon,y                     ; clear XON status
 00FFED03 0E7A08140                       stb             SerRcvXoff,y            ; set XOFF status
 00FFED06 0150F7FFFE30100                 stb             ACIA+ACIA_TX
 00FFED0B 020FAE                          bra             sirqNxtByte     ; check the status for another byte
                              sirqRxFull:
                              notRxInt:
 00FFED0D 039                             rts
 
                              nmeSerial:
 00FFED0E 05306507206906106C000           fcb             "Serial",0
 
                              ;------------------------------------------------------------------------------
                              ; Put a string to the serial port.
                              ;
                              ; Parameters:
                              ;               d = pointer to string
                              ; Modifies:
                              ;               none
                              ; Returns:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              SerialPutString:
 00FFED15 034016                          pshs    d,x
 00FFED17 01F001                          tfr             d,x
                              sps2:
 00FFED19 0E6804                          ldb             ,x
 00FFED1B 027006                          beq             spsXit
 00FFED1D 030001                          inx
 00FFED1F 08DF67                          bsr             SerialPutChar
 00FFED21 020FF6                          bra             sps2
                              spsXit:
 00FFED23 035096                          puls    d,x,pc
 
                              ;------------------------------------------------------------------------------
                              ; A little routine to test serial output.
                              ;
                              ; Parameters:
                              ;               none
                              ; Modifies:
                              ;               none
                              ; Returns:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              SerialOutputTest:
 00FFED25 034006                          pshs    d
 00FFED27 0CCFFED45                       ldd             #msgSerialTest
 00FFED2A 017FFF6AD                       lbsr    DisplayString
*** warning 1: Long branch within short branch range could be optimized
 00FFED2D 08DEC0                          bsr             SerialInit
                              sotst1:
 00FFED2F 0C6011                          ldb             #XON
 00FFED31 08DF55                          bsr             SerialPutChar
 00FFED33 08DF53                          bsr             SerialPutChar
 00FFED35 08DF51                          bsr             SerialPutChar
 00FFED37 0CCFFED45                       ldd             #msgSerialTest
 00FFED3A 08DFD9                          bsr             SerialPutString
 00FFED3C 01700016A                       lbsr    INCH
 00FFED3F 0C1003                          cmpb    #CTRLC
 00FFED41 026FEC                          bne             sotst1
 00FFED43 035086                          puls    d,pc
 
                              msgSerialTest:
 00FFED45 05306507206906106C020           fcb     "Serial port test",CR,LF,0
 00FFED4C 07006F072074020074065
 00FFED53 07307400D00A000
 
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; BSD 3-Clause License
                              ; Redistribution and use in source and binary forms, with or without
                              ; modification, are permitted provided that the following conditions are met:
                              ;
                              ; 1. Redistributions of source code must retain the above copyright notice, this
                              ;    list of conditions and the following disclaimer.
                              ;
                              ; 2. Redistributions in binary form must reproduce the above copyright notice,
                              ;    this list of conditions and the following disclaimer in the documentation
                              ;    and/or other materials provided with the distribution.
                              ;
                              ; 3. Neither the name of the copyright holder nor the names of its
                              ;    contributors may be used to endorse or promote products derived from
                              ;    this software without specific prior written permission.
                              ;
                              ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                              ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                              ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                              ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                              ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                              ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                              ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                              ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                              ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                              ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                              ;                                                                          
                              ; ============================================================================
                              ;
                              s19Address                      EQU             $940    ; to $943
                              s19StartAddress EQU             $944    ; to $947
                              s19Rectype                      EQU             $948
                              s19Reclen                               EQU             $949
                              s19Abort                                EQU             $94A
 
                              ; ------------------------------------------------------------------------------
                              ; Skip over input to the next record.
                              ; ------------------------------------------------------------------------------
 
                              s19NextRecord:
 00FFED58 0CCFFFFFF                       ldd             #-1                                                     ; block until input is available
 00FFED5B 03F                             swi
 00FFED5C 001                             fcb             MF_INCH                                 ; monitor input rout
 00FFED5D 0C100A                          cmpb    #LF                                                     ; line feed marks end of record
 00FFED5F 027013                          beq             s19nr1
 00FFED61 0C1003                          cmpb    #CTRLC                                  ; should not get this in a file transfer
 00FFED63 026003                          bne             s19nr2
 00FFED65 0F700094A                       stb             s19Abort
                              s19nr2:
 00FFED68 0C101A                          cmpb    #CTRLZ                                  ; end of file marker?
 00FFED6A 026003                          bne             s19nr3
 00FFED6C 0F700094A                       stb             s19Abort
                              s19nr3:
 00FFED6F 07D00094A                       tst             s19Abort
 00FFED72 027FE4                          beq             s19NextRecord
                              s19nr1:
 00FFED74 039                             rts
 
                              ; ------------------------------------------------------------------------------
                              ; Input a byte. There are three characters per byte since things are 12-bit.
                              ;
                              ;       Parameters:
                              ;               none
                              ; Returns:
                              ;               accb = byte value converted from text
                              ; ------------------------------------------------------------------------------
 
                              s19GetByte:
 00FFED75 03F                             swi
 00FFED76 001                             fcb             MF_INCH                                         ; get the first character
 00FFED77 0170004F6                       lbsr    AsciiToHexNybble        ; convert to nybble
 00FFED7A 07D00094A                       tst             s19Abort                                        ; check for abort
 00FFED7D 027002                          beq             s19gb1
 00FFED7F 04F                             clra
 00FFED80 039                             rts
                              s19gb1:                                                                         ; shift the value four bits
 00FFED81 058                             aslb
 00FFED82 058                             aslb
 00FFED83 058                             aslb
 00FFED84 058                             aslb
 00FFED85 034004                          pshs    b                                                                       ; save off value
 00FFED87 03F                             swi
 00FFED88 001                             fcb             MF_INCH                                         ; get the second character
 00FFED89 0170004E4                       lbsr    AsciiToHexNybble        ; convert to nybble
 00FFED8C 07D00094A                       tst             s19Abort                                        ; check for abort
 00FFED8F 026011                          bne             s19gb2
 00FFED91 0EAE00                          orb             ,s+                                                             ; merge new nybble into value
 00FFED93 058                             aslb                                                                            ; shift the value four more bits
 00FFED94 058                             aslb
 00FFED95 058                             aslb
 00FFED96 058                             aslb
 00FFED97 034004                          pshs    b                                                                       ; save off value
 00FFED99 03F                             swi
 00FFED9A 001                             fcb             MF_INCH                                         ; get third character
 00FFED9B 0170004D2                       lbsr    AsciiToHexNybble        ; convert to nybble
 00FFED9E 0EAE00                          orb             ,s+                                                             ; merge in value
 00FFEDA0 04F                             clra                                                                            ; make byte 000 to FFF in D
 00FFEDA1 039                             rts
                              s19gb2:
 00FFEDA2 032601                          leas    1,s                                                             ; discard saved byte
 00FFEDA4 04F                             clra
 00FFEDA5 039                             rts
 
                              ; ------------------------------------------------------------------------------
                              ; Zero out address
                              ; ------------------------------------------------------------------------------
 
                              s19ClearAddress:
 00FFEDA6 07F000940                       clr             s19Address
 00FFEDA9 07F000941                       clr             s19Address+1
 00FFEDAC 07F000942                       clr             s19Address+2
 00FFEDAF 07F000943                       clr             s19Address+3
 00FFEDB2 039                             rts
                                      
                              ; ------------------------------------------------------------------------------
                              ; Get an address composed of two bytes (24 bit)
                              ;
                              ; Side Effects:
                              ;               updates s19Address variable
                              ; Returns:
                              ;       none
                              ; ------------------------------------------------------------------------------
 
                              s19GetAddress2:
 00FFEDB3 08DFF1                          bsr             s19ClearAddress
 00FFEDB5 08DFBE                          bsr             s19GetByte
 00FFEDB7 0F7000942                       stb             s19Address+2
 00FFEDBA 07D00094A                       tst             s19Abort
 00FFEDBD 026005                          bne             s19ga1
 00FFEDBF 08DFB4                          bsr             s19GetByte
 00FFEDC1 0F7000943                       stb             s19Address+3
                              s19ga1:
 00FFEDC4 039                             rts
                                      
                              ; ------------------------------------------------------------------------------
                              ; Get an address composed of three bytes (36 bit)
                              ;
                              ; Side Effects:
                              ;               updates s19Address variable
                              ; Returns:
                              ;       none
                              ; ------------------------------------------------------------------------------
 
                              s19GetAddress3:
 00FFEDC5 08DFDF                          bsr             s19ClearAddress
 00FFEDC7 08DFAC                          bsr             s19GetByte
 00FFEDC9 0F7000941                       stb             s19Address+1
 00FFEDCC 07D00094A                       tst             s19Abort
 00FFEDCF 02600F                          bne             s19ga2
 00FFEDD1 08DFA2                          bsr             s19GetByte
 00FFEDD3 0F7000942                       stb             s19Address+2
 00FFEDD6 07D00094A                       tst             s19Abort
 00FFEDD9 026005                          bne             s19ga2
 00FFEDDB 08DF98                          bsr             s19GetByte
 00FFEDDD 0F7000943                       stb             s19Address+3
                              s19ga2:
 00FFEDE0 039                             rts
 
                              ; ------------------------------------------------------------------------------
                              ; Put a byte to memory.
                              ; ------------------------------------------------------------------------------
 
                              s19PutMem:
 00FFEDE1 05F                             clrb                                                            ; accb = current byte count
                              s19pm3:
 00FFEDE2 034004                          pshs    b                                                       ; save byte count
 00FFEDE4 08DF8F                          bsr             s19GetByte
 00FFEDE6 07D00094A                       tst             s19Abort
 00FFEDE9 02601C                          bne             s19pm1
 00FFEDEB 0150E790F000941                 stb             far [s19Address+1]      ; store the byte using far addressing
 00FFEDF0 07C000943                       inc             s19Address+3
 00FFEDF3 026008                          bne             s19pm2
 00FFEDF5 07C000942                       inc             s19Address+2
 00FFEDF8 026003                          bne             s19pm2
 00FFEDFA 07C000941                       inc             s19Address+1
                              s19pm2:
 00FFEDFD 035004                          puls    b                                                       ; get back byte count
 00FFEDFF 05C                             incb                                                            ; increment and
 00FFEE00 0F1000949                       cmpb    s19Reclen                       ; compare to record length
 00FFEE03 025FDD                          blo             s19pm3
 00FFEE05 020F6E                          bra             s19GetByte              ; get the checksum byte
                              s19pm1:
 00FFEE07 032601                          leas    1,s                                             ; faster than actual pull
 00FFEE09 020F6A                          bra             s19GetByte              ; get the checksum byte
 
                              ; ------------------------------------------------------------------------------
                              ; Processing for S1 record type.
                              ; ------------------------------------------------------------------------------
 
                              s19ProcessS1:
 00FFEE0B 08DFA6                          bsr             s19GetAddress2
 00FFEE0D 08DFD2                          bsr             s19PutMem
 00FFEE0F 020072                          bra             s19lnr
 
                              ; ------------------------------------------------------------------------------
                              ; Processing for S2 record type.
                              ; ------------------------------------------------------------------------------
 
                              s19ProcessS2:
 00FFEE11 08DFB2                          bsr             s19GetAddress3
 00FFEE13 08DFCC                          bsr             s19PutMem
 00FFEE15 02006C                          bra             s19lnr
 
                              ; S3,4,5,6 not processed
 
                              ; ------------------------------------------------------------------------------
                              ; Processing for S7 record type. Gets a two byte (24 bit) start address.
                              ; ------------------------------------------------------------------------------
 
                              s19ProcessS9:
 00FFEE17 08DF9A                          bsr             s19GetAddress2
 00FFEE19 0FC000942                       ldd             s19Address+2
 00FFEE1C 0FD000946                       std             s19StartAddress+2
 00FFEE1F 0FC000940                       ldd             s19Address+0
 00FFEE22 0FD000944                       std             s19StartAddress+0
 00FFEE25 020069                          bra             s19l2
                                      
                              ; ------------------------------------------------------------------------------
                              ; Processing for S8 record type. Gets a three byte (36 bit) start address.
                              ; ------------------------------------------------------------------------------
 
                              s19ProcessS8:
 00FFEE27 08DF9C                          bsr             s19GetAddress3
 00FFEE29 0FC000942                       ldd             s19Address+2
 00FFEE2C 0FD000946                       std             s19StartAddress+2
 00FFEE2F 0FC000940                       ldd             s19Address+0
 00FFEE32 0FD000944                       std             s19StartAddress+0
 00FFEE35 020059                          bra             s19l2
 
                              ; ------------------------------------------------------------------------------
                              ; S19 Loader
                              ;
                              ; Not all record types are processed. Some are skipped over.
                              ; ------------------------------------------------------------------------------
 
                              S19Loader:
 00FFEE37 07F00094A                       clr             s19Abort                                ; clear the abort flag
 00FFEE3A 0CCFFEE93                       ldd             #msgS19Loader           ; signon banner
 00FFEE3D 03F                             swi
 00FFEE3E 004                             fcb             MF_DisplayString
                              s19l3:
 00FFEE3F 03F                             swi                                                                             ; get a character from input
 00FFEE40 001                             fcb             MF_INCH
 00FFEE41 0C101A                          cmpb    #CTRLZ                                  ; is it CTRL-Z?
 00FFEE43 02704B                          beq             s19l2
 00FFEE45 0C1053                          cmpb    #'S'                                            ; records must start with the letter S
 00FFEE47 02603A                          bne             s19lnr
 00FFEE49 03F                             swi                                                                             ; get the next character
 00FFEE4A 001                             fcb             MF_INCH
 00FFEE4B 0C1030                          cmpb    #'0'                                            ; must be a numeric digit
 00FFEE4D 025034                          blo             s19lnr
 00FFEE4F 0C1039                          cmpb    #'9'
 00FFEE51 022030                          bhi             s19lnr
 00FFEE53 0F7000948                       stb             s19Rectype                      ; save off in record type
 00FFEE56 08DF1D                          bsr             s19GetByte                      ; get a byte indicating record length
 00FFEE58 0F7000949                       stb             s19Reclen
 00FFEE5B 07D00094A                       tst             s19Abort                                ; check for abort
 00FFEE5E 026030                          bne             s19l2
 00FFEE60 0F6000948                       ldb             s19Rectype                      ; process according to record type
 00FFEE63 0C1030                          cmpb    #'0'
 00FFEE65 02701C                          beq             s19lnr
 00FFEE67 0C1031                          cmpb    #'1'
 00FFEE69 027FA0                          beq             s19ProcessS1            ; data record with a two byte address
 00FFEE6B 0C1032                          cmpb    #'2'
 00FFEE6D 027FA2                          beq             s19ProcessS2            ; data record with a three byte address
 00FFEE6F 0C1033                          cmpb    #'3'
 00FFEE71 027010                          beq             s19lnr
 00FFEE73 0C1035                          cmpb    #'5'                                            ; record count? ignore
 00FFEE75 02700C                          beq             s19lnr
 00FFEE77 0C1037                          cmpb    #'7'                                            ; ignore record with 48 bit address
 00FFEE79 027015                          beq             s19l2
 00FFEE7B 0C1038                          cmpb    #'8'
 00FFEE7D 027FA8                          beq             s19ProcessS8            ; two byte start address
 00FFEE7F 0C1039                          cmpb    #'9'
 00FFEE81 027F94                          beq             s19ProcessS9            ; three byte start address
                              s19lnr:
 00FFEE83 0C602E                          ldb             #'.'                                            ; output a progress indicator
 00FFEE85 03F                             swi
 00FFEE86 002                             fcb             MF_OUTCH
 00FFEE87 08DECF                          bsr             s19NextRecord           ; skip to the next record
 00FFEE89 07D00094A                       tst             S19Abort                                ; check for abort
 00FFEE8C 026002                          bne             s19l2
 00FFEE8E 020FAF                          bra             s19l3                                           ; loop back to process more records
                              s19l2:
 00FFEE90 0160001A6                       lbra    Monitor
 
                              msgS19Loader:
 00FFEE93 05303103902004C06F061           fcb     "S19 Loader Active",CR,LF,0
 00FFEE9A 064065072020041063074
 00FFEEA1 06907606500D00A000
 
                                      
 
                              ;------------------------------------------------------------------------------
                              ; Check if there is a keyboard character available. If so return true (<0)
                              ; otherwise return false (0) in accb.
                              ;------------------------------------------------------------------------------
                              ;
                              KeybdCheckForKeyDirect:
 00FFEEA7 020BE7                          bra             DBGCheckForKey
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              INCH:
 00FFEEA9 034004                          pshs    b
                              INCH2:
 00FFEEAB 0150F6FFFFFFFE0                 ldb             COREID
 00FFEEB0 0F1FFC010                       cmpb    IOFocusID       ; if we do not have focus, block
 00FFEEB3 026FF6                          bne             INCH2                   
                              ;       ldb             #$800                   ; block if no key available, get scancode directly
                              ;       bra             GetKey
                              ;       jsr             [CharInVec]     ; vector is being overwritten somehow
 00FFEEB5 017FFFDAC                       lbsr    SerialPeekCharDirect
*** warning 1: Long branch within short branch range could be optimized
 00FFEEB8 04D                             tsta
 00FFEEB9 02B003                          bmi             INCH1                   ; block if no key available
 00FFEEBB 032601                          leas    1,s                             ; get rid of blocking status
 00FFEEBD 039                             rts
                              INCH1:
 00FFEEBE 035004                          puls    b                                       ; check blocking status
 00FFEEC0 05D                             tstb
 00FFEEC1 02BFE6                          bmi     INCH                    ; if blocking, loop
 00FFEEC3 0CCFFFFFF                       ldd             #-1                             ; return -1 if no char available
 00FFEEC6 039                             rts
 
                              INCHE:
 00FFEEC7 08DFE0                          bsr             INCH
 00FFEEC9 020009                          bra             INCHEK3
 
                              INCHEK:
 00FFEECB 08DFDC                          bsr             INCH
 00FFEECD 01507DFFFFFCA00                 tst             KeybdEcho
 00FFEED2 02700C                          beq             INCHEK1
                              INCHEK3:
 00FFEED4 08100D                          cmpa    #CR
 00FFEED6 026005                          bne             INCHEK2
 00FFEED8 017FFE1F7                       lbsr            CRLF
*** warning 1: Long branch within short branch range could be optimized
 00FFEEDB 020003                          bra             INCHEK1
                              INCHEK2:
 00FFEEDD 017FFF439                       lbsr    DisplayChar
*** warning 1: Long branch within short branch range could be optimized
                              INCHEK1:
 00FFEEE0 039                             rts
 
                              OUTCH:
 00FFEEE1 06E90F000800                    jmp             [CharOutVec]
 
                              ;------------------------------------------------------------------------------
                              ; r1 0=echo off, non-zero = echo on
                              ;------------------------------------------------------------------------------
                              ;
                              SetKeyboardEcho:
 00FFEEE5 0150F7FFFFFCA00                 stb             KeybdEcho
 00FFEEEA 039                             rts
 
 
                              ;------------------------------------------------------------------------------
                              ; Parameters:
                              ;               x,d     bitmap of sprites to enable
                              ;------------------------------------------------------------------------------
 
                              ShowSprites:
 00FFEEEB 0150BFFFFE103C0                 stx             SPRITE_CTRL+SPRITE_EN
 00FFEEF0 0150FDFFFE103C2                 std             SPRITE_CTRL+SPRITE_EN+2
 00FFEEF5 039                             rts
 
                              ;==============================================================================
                              ; Femtiki Operating System.
                              ;==============================================================================
 
                              OSCallTbl:
 00FFEEF6 000000                          fcw             0
 00FFEEF8 000000                          fcw             0
 00FFEEFA 000000                          fcw             0
 00FFEEFC 000000                          fcw             0
 00FFEEFE 000000                          fcw             0
 00FFEF00 000000                          fcw             0
 00FFEF02 000000                          fcw             0
 00FFEF04 000000                          fcw             0
 00FFEF06 000000                          fcw             0
 00FFEF08 000000                          fcw             0
 00FFEF0A 000000                          fcw             0
 00FFEF0C 000000                          fcw             0
 00FFEF0E 000000                          fcw             0
 00FFEF10 000000                          fcw             0
 00FFEF12 000000                          fcw             0
 00FFEF14 000000                          fcw             0
 00FFEF16 000000                          fcw             0
 00FFEF18 000000                          fcw             0
 00FFEF1A 000000                          fcw             0
 00FFEF1C 000000                          fcw             0
 00FFEF1E 000000                          fcw             0
 00FFEF20 000000                          fcw             0
 00FFEF22 FFEF3F                          fcw             ReleaseIOFocus
 00FFEF24 000000                          fcw             0
 00FFEF26 FFEF28                          fcw             RequestIOFocus
 
                              NumOSFuncs      EQU     (*-OSCallTbl)/2
 
                              RequestIOFocus:
 00FFEF28 0150F6FFFFFFFE0                 ldb             COREID
 00FFEF2D 08EFFC000                       ldx             #IOFocusList
 00FFEF30 03A                             abx
 00FFEF31 0A7804                          sta             ,x
 00FFEF33 07DFFC010                       tst             IOFocusID
 00FFEF36 1260007D1                       lbne    oscx
 00FFEF39 0F7FFC010                       stb             IOFocusID
 00FFEF3C 0160007CB                       lbra    oscx
 
                              ReleaseIOFocus:
 00FFEF3F 0150F6FFFFFFFE0                 ldb             COREID
 00FFEF44 08EFFC000                       ldx             #IOFocusList
 00FFEF47 03A                             abx
 00FFEF48 06F804                          clr             ,x                                              ; clear the request indicator
 00FFEF4A 017FFF2BC                       lbsr    CopyScreenToVirtualScreen
*** warning 1: Long branch within short branch range could be optimized
 00FFEF4D 0F1FFC010                       cmpb    IOFocusID                       ; are we the one with the focus?
 00FFEF50 1260007B7                       lbne    oscx
                                      ; We had the focus, so now a new core needs the focus.
                                      ; Search the focus list for a requestor. If no requester
                                      ; is found, give focus to core #1.
 00FFEF53 08600F                          lda             #15
                              riof2:
 00FFEF55 05C                             incb
 00FFEF56 0C400F                          andb    #15
 00FFEF58 03A                             abx
 00FFEF59 06D804                          tst             ,x
 00FFEF5B 026009                          bne             riof1
 00FFEF5D 04A                             deca
 00FFEF5E 026FF5                          bne             riof2
                                      ; If no focus is requested by anyone, give to core #1
 00FFEF60 0C6001                          ldb             #1
 00FFEF62 086018                          lda             #24
 00FFEF64 0A7804                          sta             ,x
                              riof1:
 00FFEF66 0F7FFC010                       stb             IOFocusID
 00FFEF69 017FFF266                       lbsr    CopyVirtualScreenToScreen
*** warning 1: Long branch within short branch range could be optimized
 00FFEF6C 01600079B                       lbra    oscx
                                              
                                      
                              ;==============================================================================
                              ;==============================================================================
 
                              ;------------------------------------------------------------------------------
                              ; Seed the random number generator. All channels are seeded with the same
                              ; value.
                              ;
                              ; Parameters:
                              ;               d = 'z' part of seed
                              ;               x = 'w' part of seed
                              ; Returns:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              mon_srand:
 00FFEF6F 18E000000                       ldy     #0
                              mon_srand1:
 00FFEF72 0151BFFFFE30604                 sty     PRNG+4                          ; select channel
 00FFEF77 01507FFFFE30608                 clr     PRNG+8
 00FFEF7C 01507FFFFE30609                 clr PRNG+9
 00FFEF81 0150FDFFFE3060A                 std     PRNG+10                         ; update low half of value
 00FFEF86 01507FFFFE3060C                 clr PRNG+12
 00FFEF8B 01507FFFFE3060D                 clr PRNG+13
 00FFEF90 0150BFFFFE3060E                 stx     PRNG+14                         ; update low half of value
 00FFEF95 031201                          iny
 00FFEF97 18C000400                       cmpy    #$400                           ; 1k channels
 00FFEF9A 025FD6                          blo             mon_srand1
 00FFEF9C 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Get a random number and generate the next one.
                              ;
                              ; Parameters:
                              ;               d = channel to use
                              ; Returns:
                              ;               x,d = 36 bit random value
                              ;------------------------------------------------------------------------------
 
                              mon_rand:
 00FFEF9D 0150FDFFFE30604                 std     PRNG+4                          ; select channel
 00FFEFA2 0150BEFFFE30600                 ldx     PRNG+0
 00FFEFA7 0150FCFFFE30602                 ldd     PRNG+2
 00FFEFAC 0150F7FFFE30603                 stb     PRNG+3                          ; trigger calc of next number
 00FFEFB1 039                             rts
 
                              ;==============================================================================
                              ; System Monitor
                              ;==============================================================================
 
                              ; Command Tables
 
                              cmdTable1:
 00FFEFB2 03C83E                          fcb             '<','>'+$800
 00FFEFB4 062873                          fcb             'b','s'+$800
 00FFEFB6 062863                          fcb             'b','c'+$800
 00FFEFB8 044852                          fcb             'D','R'+$800
 00FFEFBA 844                             fcb             'D'+$800
 00FFEFBB 83A                             fcb             ':'+$800
 00FFEFBC 046049847                       fcb             "FI",'G'+$800
 00FFEFBF 04604984C                       fcb             "FI",'L'+$800
 00FFEFC2 04684C                          fcb             'F','L'+$800
 00FFEFC4 84A                             fcb             'J'+$800
 00FFEFC5 05204104D054045053854           fcb             "RAMTES",'T'+$800
 00FFEFCC 053050844                       fcb             "SP",'D'+$800
 00FFEFCF 054049852                       fcb             "TI",'R'+$800
 00FFEFD2 855                             fcb             'U'+$800
 00FFEFD3 065078069874                    fcb             "exi",'t'+$800
 00FFEFD7 83F                             fcb             '?'+$800
 00FFEFD8 04304C853                       fcb             "CL",'S'+$800
 00FFEFDB 053031839                       fcb             "S1",'9'+$800
 00FFEFDE 04A044834                       fcb             "JD",'4'+$800
 00FFEFE1 000000                          fcw             0
 
                              cmdTable2:
 00FFEFE3 FFF0F8                          fcw             Redirect
 00FFEFE5 FFF13A                          fcw             MonArmBreakpoint
 00FFEFE7 FFF145                          fcw             MonDisarmBreakpoint
 00FFEFE9 FFF54A                          fcw             DumpRegs
 00FFEFEB FFF484                          fcw             DumpMemory
 00FFEFED FFF4E0                          fcw             EditMemory
 00FFEFEF FE0000                          fcw             $FE0000                                 ; FIG forth
 00FFEFF1 FFF520                          fcw             FillMemory
 00FFEFF3 FFF60B                          fcw             DumpIOFocusList
 00FFEFF5 FFF595                          fcw             jump_to_code
 00FFEFF7 FFD400                          fcw             $FFD400
 00FFEFF9 FF8000                          fcw             $FF8000                                 ; sprite demo
 00FFEFFB FFE4F4                          fcw             rtc_read
 00FFEFFD FF8003                          fcw             $FF8003                                 ; unassembler
 00FFEFFF FFF6F3                          fcw             xitMonitor
 00FFF001 FFF11E                          fcw             PromptHelp
 00FFF003 FFF126                          fcw             PromptClearscreen
 00FFF005 FFEE37                          fcw             S19Loader
 00FFF007 FFD400                          fcw             $FFD400
 
                              CmdPrompt:
 00FFF009 017FFE0C6                       lbsr    CRLF
*** warning 1: Long branch within short branch range could be optimized
 00FFF00C 0C6024                          ldb             #'$'
 00FFF00E 017FFFED0                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 00FFF011 016FFFECD                       lbra    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 
                              msgF09Starting:
 00FFF014 04606506D07406906B069           fcb             "Femtiki F09 Multi-core OS Starting",CR,LF,0
 00FFF01B 02004603003902004D075
 00FFF022 06C07406902D06306F072
 00FFF029 06502004F053020053074
 00FFF030 06107207406906E06700D
 00FFF037 00A000
 
                              Monitor:
 00FFF039 0FC00092C                       ldd             mon_init                        ; check special code to see if monitor has been initialized
 00FFF03C 18312D687                       cmpd    #1234567
 00FFF03F 02704D                          beq             mon1
 00FFF041 07F000810                       clr             BreakpointFlag
 00FFF044 07F000811                       clr             NumSetBreakpoints
 00FFF047 0CC00007B                       ldd             #123
 00FFF04A 08E00028E                       ldx             #654
 00FFF04D 017FFFF1F                       lbsr    mon_srand
*** warning 1: Long branch within short branch range could be optimized
 00FFF050 0CCFFF014                       ldd             #msgF09Starting
 00FFF053 017FFF384                       lbsr    DisplayString
*** warning 1: Long branch within short branch range could be optimized
 00FFF056 0CCFFF2CF                       ldd             #HelpMsg
 00FFF059 017FFF37E                       lbsr    DisplayString
*** warning 1: Long branch within short branch range could be optimized
 00FFF05C 0CCFFF009                       ldd             #CmdPrompt
 00FFF05F 0FD000808                       std             CmdPromptJI
 00FFF062 0CCFFF2B6                       ldd             #DisplayErr
 00FFF065 0FD00080C                       std             MonErrVec
 00FFF068 0CC0063FF                       ldd             #$63FF                  ; default app stack
 00FFF06B 0FD000908                       std             mon_SSAVE
 00FFF06E 07F00090E                       clr             mon_DPRSAVE     ;
 00FFF071 01F0A8                          tfr             ccr,a
 00FFF073 0B700090F                       sta             mon_CCRSAVE
 00FFF076 07F00090A                       clr             mon_PCSAVE
 00FFF079 0CCFFF039                       ldd             #Monitor
 00FFF07C 0FD00090B                       std             mon_PCSAVE+1
 00FFF07F 07F000902                       clr             mon_XSAVE
 00FFF082 07F000904                       clr             mon_YSAVE
 00FFF085 07F000906                       clr             mon_USAVE
 00FFF088 0CC12D687                       ldd             #1234567
 00FFF08B 0FD00092C                       std             mon_init
                              mon1:
 00FFF08E 03280F006FFF                    leas    $6FFF                           ; reset stack pointer
 00FFF092 05F                             clrb                                                    ; turn off keyboard echo
 00FFF093 017FFFE4F                       lbsr    SetKeyboardEcho
*** warning 1: Long branch within short branch range could be optimized
                                      ; Reset IO vectors
 00FFF096 0CCFFEC64                       ldd             #SerialPeekCharDirect
 00FFF099 0FD000804                       std             CharInVec
 00FFF09C 0CCFFE319                       ldd             #DisplayChar
 00FFF09F 0FD000800                       std             CharOutVec
 00FFF0A2 0CCFFF009                       ldd             #CmdPrompt
 00FFF0A5 0FD000808                       std             CmdPromptJI
                              ;       jsr             RequestIOFocus
                              PromptLn:
 00FFF0A8 0AD90F000808                    jsr             [CmdPromptJI]
 
                              ; Get characters until a CR is keyed
                                      
                              Prompt3:
 00FFF0AC 0CCFFFFFF                       ldd             #-1                                     ; block until key present
 00FFF0AF 017FFFDF7                       lbsr    INCH
*** warning 1: Long branch within short branch range could be optimized
 00FFF0B2 0C100D                          cmpb    #CR                                     ; carriage return?
 00FFF0B4 027005                          beq             Prompt1 
 00FFF0B6 017FFFE28                       lbsr    OUTCH                           ; spit out the character
*** warning 1: Long branch within short branch range could be optimized
 00FFF0B9 020FF1                          bra             Prompt3                 ; and keep going
 
                              ; Process the screen line that the CR was keyed on
                              ;
                              Prompt1:
 00FFF0BB 0CC005050                       ldd             #$5050
 00FFF0BE 0150FDFFFE60001                 std             LEDS
                              ;       ldb             RunningID
                              ;       cmpb    #61
                              ;       bhi             Prompt3
 00FFF0C3 00F111                          clr             CursorCol                       ; go back to the start of the line
 00FFF0C5 017FFF22A                       lbsr    CalcScreenLoc   ; calc screen memory location
*** warning 1: Long branch within short branch range could be optimized
 00FFF0C8 01F002                          tfr             d,y
                              skipDollar:
 00FFF0CA 08D067                          bsr             MonGetNonSpace
 00FFF0CC 0C1024                          cmpb    #'$'
 00FFF0CE 027FFA                          beq             skipDollar              ; skip over '$' prompt character
 
                              ; Dispatch based on command
                              ;
 00FFF0D0 0313FF                          dey
 00FFF0D2 01F023                          tfr             y,u                                                     ; save off input position
 00FFF0D4 05F                             clrb
 00FFF0D5 08EFFEFB2                       ldx             #cmdTable1
                              parseCmd1:
 00FFF0D8 0A6A00                          lda             ,y+                                                     ; get input character
 00FFF0DA 06D804                          tst             ,x                                                      ; test for end of command
 00FFF0DC 02B00F                          bmi             endOfWord                               ;
 00FFF0DE 0A1800                          cmpa    ,x+                                                     ; does input match command?
 00FFF0E0 027FF6                          beq             parseCmd1
                              scanNextWord:
 00FFF0E2 06D800                          tst             ,x+
 00FFF0E4 027F53                          beq             Monitor                                 ; if end of table reached, not a command
 00FFF0E6 02AFFA                          bpl             scanNextWord
 00FFF0E8 05C                             incb
 00FFF0E9 01F032                          tfr             u,y                                                     ; reset input pointer
 00FFF0EB 020FEB                          bra             parseCmd1                               ; try again
                              endOfWord:
 00FFF0ED 0A8804                          eora    ,x
 00FFF0EF 048                             asla
 00FFF0F0 026FF0                          bne             scanNextWord
                                      ; we found the command in the table
 00FFF0F2 058                             aslb                                                                    ; b = word index
 00FFF0F3 08EFFEFE3                       ldx             #cmdTable2
 00FFF0F6 06E905                          jmp             [b,x]                                           ; execute command
 
                              Redirect:
 00FFF0F8 08D034                          bsr             MonGetch
 00FFF0FA 0C1073                          cmpb    #'s'
 00FFF0FC 02600E                          bne             Prompt2a
 00FFF0FE 0CCFFEC64                       ldd             #SerialPeekCharDirect
 00FFF101 0FD000804                       std             CharInVec
 00FFF104 0CCFFEC88                       ldd             #SerialPutChar
 00FFF107 0FD000800                       std             CharOutVec
 00FFF10A 020F2D                          bra             Monitor
                              Prompt2a:
 00FFF10C 0C1063                          cmpb    #'c'
 00FFF10E 026F29                          bne             Monitor
 00FFF110 0CCFFEA92                       ldd             #GetKey
 00FFF113 0FD000804                       std             CharInVec
 00FFF116 0CCFFE319                       ldd             #DisplayChar
 00FFF119 0FD000800                       std             CharOutVec
 00FFF11C 020F1B                          bra             Monitor
 
                              PromptHelp:
 00FFF11E 0CCFFF2CF                       ldd             #HelpMsg
 00FFF121 017FFF2B6                       lbsr    DisplayString
*** warning 1: Long branch within short branch range could be optimized
 00FFF124 020F13                          bra             Monitor
 
                              PromptClearscreen:
 00FFF126 017FFF110                       lbsr    ClearScreen
*** warning 1: Long branch within short branch range could be optimized
 00FFF129 017FFF184                       lbsr    HomeCursor
*** warning 1: Long branch within short branch range could be optimized
 00FFF12C 020F0B                          bra             Monitor
 
                              MonGetch:
 00FFF12E 0E6A04                          ldb             ,y
 00FFF130 031201                          iny
 00FFF132 039                             rts
 
                              MonGetNonSpace:
 00FFF133 08DFF9                          bsr             MonGetCh
 00FFF135 0C1020                          cmpb    #' '
 00FFF137 027FFA                          beq             MonGetNonSpace
 00FFF139 039                             rts
 
                              MonArmBreakpoint:
 00FFF13A 017000611                       lbsr    ArmBreakpoint
 00FFF13D 0C6FFF                          ldb             #$FFF
 00FFF13F 0F7000810                       stb             BreakpointFlag
 00FFF142 016FFFEF4                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              MonDisarmBreakpoint:
 00FFF145 017000632                       lbsr    DisarmBreakpoint
 00FFF148 016FFFEEE                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
 
                              ;------------------------------------------------------------------------------
                              ; Ignore blanks in the input
                              ; Y = text pointer
                              ; D destroyed
                              ;------------------------------------------------------------------------------
                              ;
                              ignBlanks:
                              ignBlanks1:
 00FFF14B 08DFE1                          bsr             MonGetch
 00FFF14D 0C1020                          cmpb    #' '
 00FFF14F 027FFA                          beq             ignBlanks1
 00FFF151 0313FF                          dey
 00FFF153 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Multiply number in work area by 10.
                              ;------------------------------------------------------------------------------
                              Times10:
 00FFF154 034006                          pshs    d
 00FFF156 0FC000910                       ldd             mon_numwka              ; make a copy of the number
 00FFF159 0FD000918                       std             mon_numwka+8
 00FFF15C 0FC000912                       ldd             mon_numwka+2
 00FFF15F 0FD00091A                       std             mon_numwka+10
 00FFF162 08D05B                          bsr             shl_numwka              ; shift left = *2
 00FFF164 08D059                          bsr             shl_numwka              ; shift left = *4
 00FFF166 0FC000912                       ldd             mon_numwka+2    ; add in original value
 00FFF169 0F300091A                       addd    mon_numwka+10   ; = *5
 00FFF16C 0F6000911                       ldb             mon_numwka+1
 00FFF16F 0F9000919                       adcb    mon_numwka+9
 00FFF172 0F7000911                       stb             mon_numwka+1
 00FFF175 0B6000910                       lda             mon_numwka+0
 00FFF178 0B9000918                       adca    mon_numwka+8
 00FFF17B 0B7000910                       sta             mon_numwka+0
 00FFF17E 08D03F                          bsr             shl_numwka              ; shift left = * 10
 00FFF180 035086                          puls    d,pc
                                      
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              GetTwoParams:
 00FFF182 08DFC7                          bsr             ignBlanks
 00FFF184 08D0DC                          bsr             GetNumber                       ; get start address of dump
 00FFF186 0FC000910                       ldd             mon_numwka
 00FFF189 0FD000920                       std             mon_r1
 00FFF18C 0FC000912                       ldd             mon_numwka+2
 00FFF18F 0FD000922                       std             mon_r1+2
 00FFF192 08DFB7                          bsr             ignBlanks
 00FFF194 08D0CC                          bsr             GetNumber                       ; get end address of dump
 00FFF196 0FC000910                       ldd             mon_numwka
 00FFF199 0FD000924                       std             mon_r2
 00FFF19C 0FC000912                       ldd             mon_numwka+2
 00FFF19F 0FD000926                       std             mon_r2+2
 00FFF1A2 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Get a range, the end must be greater or equal to the start.
                              ;------------------------------------------------------------------------------
                              GetRange:
 00FFF1A3 08DFDD                          bsr             GetTwoParams
 00FFF1A5 0FC000926                       ldd             mon_r2+2
 00FFF1A8 0B3000922                       subd    mon_r1+2
 00FFF1AB 0FC000924                       ldd             mon_r2
 00FFF1AE 0F2000921                       sbcb    mon_r1+1
 00FFF1B1 0B2000920                       sbca    mon_r1
 00FFF1B4 124000007                       lbcc    grng1
 00FFF1B7 0AD90F00080C                    jsr             [MonErrVec]
 00FFF1BB 016FFFE7B                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              grng1:
 00FFF1BE 039                             rts
 
                              shl_numwka:
 00FFF1BF 078000913                       asl             mon_numwka+3
 00FFF1C2 079000912                       rol             mon_numwka+2
 00FFF1C5 079000911                       rol             mon_numwka+1
 00FFF1C8 079000910                       rol             mon_numwka
 00FFF1CB 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Get a hexidecimal number. Maximum of twelve digits.
                              ;
                              ; Modifies:
                              ;       Y = text pointer (updated)
                              ;       D = number of digits
                              ;       mon_numwka contains number
                              ;------------------------------------------------------------------------------
                              ;
                              GetHexNumber:
 00FFF1CC 04F05F                          clrd
 00FFF1CE 0FD000910                       std             mon_numwka      ; zero out work area
 00FFF1D1 0FD000912                       std             mon_numwka+2
 00FFF1D4 034010                          pshs    x
 00FFF1D6 08E000000                       ldx             #0                                      ; max 12 eight digits
                              gthxn2:
 00FFF1D9 08DF53                          bsr             MonGetch
 00FFF1DB 08D093                          bsr             AsciiToHexNybble
 00FFF1DD 0C1FFF                          cmpb    #-1
 00FFF1DF 027017                          beq             gthxn1
 00FFF1E1 08DFDC                          bsr             shl_numwka
 00FFF1E3 08DFDA                          bsr             shl_numwka
 00FFF1E5 08DFD8                          bsr             shl_numwka
 00FFF1E7 08DFD6                          bsr             shl_numwka
 00FFF1E9 0C400F                          andb    #$0f
 00FFF1EB 0FA000913                       orb             mon_numwka+3
 00FFF1EE 0F7000913                       stb             mon_numwka+3
 00FFF1F1 030001                          inx
 00FFF1F3 08C00000C                       cmpx    #12
 00FFF1F6 025FE1                          blo             gthxn2
                              gthxn1:
 00FFF1F8 01F010                          tfr             x,d
 00FFF1FA 035090                          puls    x,pc
 
                              GetBinNumber:
 00FFF1FC 04F05F                          clrd
 00FFF1FE 0FD000910                       std             mon_numwka
 00FFF201 0FD000912                       std             mon_numwka+2
 00FFF204 034010                          pshs    x
 00FFF206 08E000000                       ldx             #0
                              gtbin2:
 00FFF209 08DF23                          bsr             MonGetch
 00FFF20B 08D099                          bsr             AsciiToBinDigit
 00FFF20D 05D                             tstb
 00FFF20E 02B00F                          bmi             gtbin1
 00FFF210 08DFAD                          bsr             shl_numwka
 00FFF212 0FA000913                       orb             mon_numwka+3
 00FFF215 0F7000913                       stb             mon_numwka+3
 00FFF218 030001                          inx
 00FFF21A 08C000030                       cpx             #48
 00FFF21D 025FEA                          blo             gtbin2
                              gtbin1:
 00FFF21F 01F010                          tfr             x,d
 00FFF221 035090                          puls    x,pc
                                      
                              GetDecNumber:
 00FFF223 04F05F                          clrd
 00FFF225 0FD000910                       std             mon_numwka
 00FFF228 0FD000912                       std             mon_numwka+2
 00FFF22B 034010                          pshs    x
 00FFF22D 08E000000                       ldx             #0
                              gtdec2:
 00FFF230 08DEFC                          bsr             MonGetch
 00FFF232 08D064                          bsr             AsciiToDecDigit
 00FFF234 05D                             tstb
 00FFF235 02B027                          bmi             gtdec1
 00FFF237 08DF1B                          bsr             Times10
 00FFF239 0FB000913                       addb    mon_numwka+3
 00FFF23C 0F7000913                       stb             mon_numwka+3
 00FFF23F 0F6000912                       ldb             mon_numwka+2
 00FFF242 0C9000                          adcb    #0
 00FFF244 0F7000912                       stb             mon_numwka+2
 00FFF247 0F6000911                       ldb             mon_numwka+1
 00FFF24A 0C9000                          adcb    #0
 00FFF24C 0F7000911                       stb             mon_numwka+1
 00FFF24F 0F6000910                       ldb             mon_numwka+0
 00FFF252 0C9000                          adcb    #0
 00FFF254 0F7000910                       stb             mon_numwka+0
 00FFF257 030001                          inx
 00FFF259 08C00000F                       cpx             #15
 00FFF25C 025FD2                          blo             gtdec2
                              gtdec1:
 00FFF25E 01F010                          tfr             x,d
 00FFF260 035090                          puls    x,pc
 
                              GetNumber:
 00FFF262 08DECA                          bsr             MonGetch
 00FFF264 0C102B                          cmpb    #'+'
 00FFF266 027FBB                          beq             GetDecNumber
 00FFF268 0C1025                          cmpb    #'%'
 00FFF26A 027F90                          beq             GetBinNumber
 00FFF26C 0313FF                          dey
 00FFF26E 020F5C                          bra             GetHexNumber
 
                              ;       phx
                              ;       push    r4
                              ;       push    r5
                              ;       ldx             #0
                              ;       ld              r4,#10
                              ;       ld              r5,#10
                              ;gtdcn2:
                              ;       jsr             MonGetch
                              ;       jsr             AsciiToDecNybble
                              ;       cmp             #-1
                              ;       beq             gtdcn1
                              ;       mul             r2,r2,r5
                              ;       add             r2,r1
                              ;       dec             r4
                              ;       bne             gtdcn2
                              ;gtdcn1:
                              ;       txa
                              ;       pop             r5
                              ;       pop             r4
                              ;       plx
                              ;       rts
 
                              ;------------------------------------------------------------------------------
                              ; Convert ASCII character in the range '0' to '9', 'a' to 'f' or 'A' to 'F'
                              ; to a hex nybble.
                              ;------------------------------------------------------------------------------
                              ;
                              AsciiToHexNybble:
 00FFF270 0C1030                          cmpb    #'0'
 00FFF272 025021                          blo             gthx3
 00FFF274 0C1039                          cmpb    #'9'
 00FFF276 022003                          bhi             gthx5
 00FFF278 0C0030                          subb    #'0'
 00FFF27A 039                             rts
                              gthx5:
 00FFF27B 0C1041                          cmpb    #'A'
 00FFF27D 025016                          blo             gthx3
 00FFF27F 0C1046                          cmpb    #'F'
 00FFF281 022005                          bhi             gthx6
 00FFF283 0C0041                          subb    #'A'
 00FFF285 0CB00A                          addb    #10
 00FFF287 039                             rts
                              gthx6:
 00FFF288 0C1061                          cmpb    #'a'
 00FFF28A 025009                          blo             gthx3
 00FFF28C 0C107A                          cmpb    #'z'
 00FFF28E 022005                          bhi             gthx3
 00FFF290 0C0061                          subb    #'a'
 00FFF292 0CB00A                          addb    #10
 00FFF294 039                             rts
                              gthx3:
 00FFF295 0C6FFF                          ldb             #-1             ; not a hex number
 00FFF297 039                             rts
 
                              AsciiToDecDigit:
 00FFF298 0C1030                          cmpb    #'0'
 00FFF29A 025007                          blo             gtdc3
 00FFF29C 0C1039                          cmpb    #'9'
 00FFF29E 022003                          bhi             gtdc3
 00FFF2A0 0C0030                          subb    #'0'
 00FFF2A2 039                             rts
                              gtdc3:
 00FFF2A3 0C6FFF                          ldb             #-1
 00FFF2A5 039                             rts
 
                              AsciiToBinDigit:
 00FFF2A6 0C1030                          cmpb    #'0'
 00FFF2A8 026002                          bne             abd1
 00FFF2AA 05F                             clrb
 00FFF2AB 039                             rts
                              abd1:
 00FFF2AC 0C1031                          cmpb    #'1'
 00FFF2AE 026003                          bne             abd2
 00FFF2B0 0C6001                          ldb             #1
 00FFF2B2 039                             rts
                              abd2:
 00FFF2B3 0C6FFF                          ldb             #-1
 00FFF2B5 039                             rts
 
                              DisplayErr:
 00FFF2B6 0CCFFF2C7                       ldd             #msgErr
 00FFF2B9 017FFF11E                       lbsr    DisplayString
*** warning 1: Long branch within short branch range could be optimized
 00FFF2BC 07EFFF039                       jmp             Monitor
 
                              DisplayStringDX
 00FFF2BF 0DD024                          std             Strptr
 00FFF2C1 09F026                          stx             Strptr+2
 00FFF2C3 0BDFFE3DA                       jsr             DisplayString
 00FFF2C6 039                             rts
 
                              msgErr:
 00FFF2C7 02A02A04507207200D00A           fcb     "**Err",CR,LF,0
 00FFF2CE 000
 
                              HelpMsg:
 00FFF2CF 03F02003D020044069073           fcb             "? = Display help",CR,LF
 00FFF2D6 07006C061079020068065
 00FFF2DD 06C07000D00A
 00FFF2E1 04304C05302003D020063           fcb     "CLS = clear screen",CR,LF
 00FFF2E8 06C065061072020073063
 00FFF2EF 07206506506E00D00A
 00FFF2F5 06207302003D020073065           fcb     "bs = set breakpoint",CR,LF
 00FFF2FC 07402006207206506106B
 00FFF303 07006F06906E07400D00A
 00FFF30A 06206302003D02006306C           fcb     "bc = clear breakpoint",CR,LF
 00FFF311 065061072020062072065
 00FFF318 06106B07006F06906E074
 00FFF31F 00D00A
                              ;       db      "S = Boot from SD Card",CR,LF
 00FFF321 03A02003D020045064069           fcb     ": = Edit memory bytes",CR,LF
 00FFF328 07402006D06506D06F072
 00FFF32F 079020062079074065073
 00FFF336 00D00A
                              ;       db      "L = Load sector",CR,LF
                              ;       db      "W = Write sector",CR,LF
 00FFF338 04405202003D020044075           fcb "DR = Dump registers",CR,LF
 00FFF33F 06D070020072065067069
 00FFF346 07307406507207300D00A
 00FFF34D 04402003D02004407506D           fcb     "D = Dump memory",CR,LF
 00FFF354 07002006D06506D06F072
 00FFF35B 07900D00A
 00FFF35E 04602003D02004606906C           fcb     "F = Fill memory",CR,LF
 00FFF365 06C02006D06506D06F072
 00FFF36C 07900D00A
 00FFF36F 04604C02003D020044075           fcb "FL = Dump I/O Focus List",CR,LF
 00FFF376 06D07002004902F04F020
 00FFF37D 04606F06307507302004C
 00FFF384 06907307400D00A
                              ;       fcb "FIG = start FIG Forth",CR,LF
                              ;       db      "KILL n = kill task #n",CR,LF
                              ;       db      "B = start tiny basic",CR,LF
                              ;       db      "b = start EhBasic 6502",CR,LF
 00FFF389 04A02003D02004A07506D           fcb     "J = Jump to code",CR,LF
 00FFF390 07002007406F02006306F
 00FFF397 06406500D00A
 00FFF39B 04A04403402003D02004A           fcb     "JD4 = Jump to $FFD400",CR,LF
 00FFF3A2 07506D07002007406F020
 00FFF3A9 024046046044034030030
 00FFF3B0 00D00A
 00FFF3B2 05204104D054045053054           fcb "RAMTEST = test RAM",CR,LF
 00FFF3B9 02003D020074065073074
 00FFF3C0 02005204104D00D00A
                              ;       db      "R[n] = Set register value",CR,LF
                              ;       db      "r = random lines - test bitmap",CR,LF
                              ;       db      "e = ethernet test",CR,LF
 00FFF3C6 07302003D020073065072           fcb     "s = serial output test",CR,LF
 00FFF3CD 06906106C02006F075074
 00FFF3D4 070075074020074065073
 00FFF3DB 07400D00A
 00FFF3DE 05303103902003D020072           fcb     "S19 = run S19 loader",CR,LF
 00FFF3E5 07506E020053031039020
 00FFF3EC 06C06F06106406507200D
 00FFF3F3 00A
 00FFF3F4 05305002003D020073070           fcb     "SP = sprite demo",CR,LF
 00FFF3FB 072069074065020064065
 00FFF402 06D06F00D00A
                              ;       db      "T = Dump task list",CR,LF
                              ;       db      "TO = Dump timeout list",CR,LF
 00FFF406 05404902003D020064069           fcb     "TI = display date/time",CR,LF
 00FFF40D 07307006C061079020064
 00FFF414 06107406502F07406906D
 00FFF41B 06500D00A
                              ;       db      "TEMP = display temperature",CR,LF
 00FFF41E 05502003D02007506E061           fcb     "U = unassemble",CR,LF
 00FFF425 07307306506D06206C065
 00FFF42C 00D00A
                              ;       db      "P = Piano",CR,LF
 00FFF42E 07802003D020065078069           fcb     "x = exit monitor",CR,LF
 00FFF435 07402006D06F06E069074
 00FFF43C 06F07200D00A
 00FFF440 000                             fcb             0
 
                              msgRegHeadings
 00FFF441 00D00A02002004402F041           fcb     CR,LF,"  D/AB     X      Y      U      S       PC    DP  CCR",CR,LF,0
 00FFF448 042020020020020020058
 00FFF44F 020020020020020020059
 00FFF456 020020020020020020055
 00FFF45D 020020020020020020053
 00FFF464 020020020020020020020
 00FFF46B 050043020020020020044
 00FFF472 05002002004304305200D
 00FFF479 00A000
 
                              nHEX4:
 00FFF47B 0BDFFD2D2                       jsr             HEX4
 00FFF47E 039                             rts
 
                              nXBLANK:
 00FFF47F 0C6020                          ldb             #' '
 00FFF481 016FFFA5D                       lbra    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 
                              ;------------------------------------------------------------------------------
                              ; Dump Memory
                              ;
                              ; Usage:
                              ;       $D FFFC12 FFFC20
                              ;
                              ; Dump formatted to look like:
                              ;               :FFFC12 012 012 012 012 555 666 777 888
                              ;
                              ;------------------------------------------------------------------------------
 
                              DumpMemory:
 00FFF484 08DD1D                          bsr             GetRange
 00FFF486 18E000000                       ldy             #0
 00FFF489 1BE000922                       ldy             mon_r1+2
                              dmpm2:
 00FFF48C 017FFDC43                       lbsr    CRLF
*** warning 1: Long branch within short branch range could be optimized
 00FFF48F 0C603A                          ldb             #':'
 00FFF491 017FFFA4D                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 00FFF494 01F020                          tfr             y,d
                                      ;addd   mon_r1+2                                        ; output the address
 00FFF496 017FFEF95                       lbsr    DispWordAsHex
*** warning 1: Long branch within short branch range could be optimized
 00FFF499 0C6020                          ldb             #' '
 00FFF49B 017FFFA43                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 00FFF49E 08E000008                       ldx             #8                                                              ; number of bytes to display
                              dmpm1:
                              ;       ldb             far [mon_r1+1],y
                                      ;ldb            [mon_r1+2],y
 00FFF4A1 0E6A04                          ldb             ,y
 00FFF4A3 031201                          iny
 00FFF4A5 017FFEF8F                       lbsr    DispByteAsHex                   ; display byte
*** warning 1: Long branch within short branch range could be optimized
 00FFF4A8 0C6020                          ldb             #' '                                                    ; followed by a space
 00FFF4AA 017FFFA34                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 00FFF4AD 05F                             clrb
 00FFF4AE 04F                             clra
 00FFF4AF 017FFF9F7                       lbsr    INCH
*** warning 1: Long branch within short branch range could be optimized
 00FFF4B2 0C1003                          cmpb    #CTRLC
 00FFF4B4 027024                          beq             dmpm3
 00FFF4B6 0301FF                          dex
 00FFF4B8 026FE7                          bne             dmpm1
                                      ; Now output ascii
 00FFF4BA 0C6020                          ldb             #' '
 00FFF4BC 017FFFA22                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 00FFF4BF 08E000008                       ldx             #8                                                              ; 8 chars to output
 00FFF4C2 0313F8                          leay    -8,y                                                    ; backup pointer
                              dmpm5:
                              ;       ldb             far [mon_r1+1],y        ; get the char
                              ;       ldb             [mon_r1+2],y                    ; get the char
 00FFF4C4 0E6A04                          ldb             ,y
 00FFF4C6 0C1020                          cmpb    #$20                                                    ; is it a control char?
 00FFF4C8 024002                          bhs             dmpm4
 00FFF4CA 0C602E                          ldb             #'.'
                              dmpm4:
 00FFF4CC 017FFFA12                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 00FFF4CF 031201                          iny
 00FFF4D1 0301FF                          dex
 00FFF4D3 026FEF                          bne             dmpm5
 00FFF4D5 1BC000926                       cmpy    mon_r2+2
 00FFF4D8 025FB2                          blo             dmpm2
                              dmpm3:
 00FFF4DA 017FFDBF5                       lbsr    CRLF
*** warning 1: Long branch within short branch range could be optimized
 00FFF4DD 016FFFB59                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
 
                              ;------------------------------------------------------------------------------
                              ; Edit Memory
                              ;
                              ; Usage:
                              ;       $$:FFFC12 8 "Hello World!" 0
                              ;
                              ; Dump formatted to look like:
                              ;               :FFFC12 012 012 012 012 555 666 777 888
                              ;
                              ;------------------------------------------------------------------------------
 
                              EditMemory:
 00FFF4E0 0CE000008                       ldu             #8                                              ; set max byte count
 00FFF4E3 017FFFCE6                       lbsr    GetHexNumber    ; get the start address
*** warning 1: Long branch within short branch range could be optimized
 00FFF4E6 0BE000912                       ldx             mon_numwka+2
                              EditMem2:
 00FFF4E9 017FFFC5F                       lbsr    ignBlanks                       ; skip over blanks
*** warning 1: Long branch within short branch range could be optimized
 00FFF4EC 017FFFCDD                       lbsr    GetHexNumber    ; get the byte value
*** warning 1: Long branch within short branch range could be optimized
 00FFF4EF 05D                             tstb                                                            ; check for valid value
 00FFF4F0 02700C                          beq             EditMem1                        ; if invalid, quit
 00FFF4F2 0F6000913                       ldb             mon_numwka+3    ; get value
 00FFF4F5 0E7800                          stb             ,x+                                             ; update memory at address
 00FFF4F7 0335FF                          leau    -1,u                                    ; decremeent byte count
 00FFF4F9 283000000                       cmpu    #0
 00FFF4FC 026FEB                          bne             EditMem2                        ; go back for annother byte
                              EditMem1:
 00FFF4FE 017FFFC2D                       lbsr    MonGetch                        ; see if a string is being entered
*** warning 1: Long branch within short branch range could be optimized
 00FFF501 0C1022                          cmpb    #'"'
 00FFF503 026018                          bne             EditMem3                        ; no string, we're done
 00FFF505 0CE000028                       ldu             #40                                             ; string must be less than 40 chars
                              EditMem4:
 00FFF508 017FFFC23                       lbsr    MonGetch                        ; look for close quote
*** warning 1: Long branch within short branch range could be optimized
 00FFF50B 0C1022                          cmpb    #'"'
 00FFF50D 026005                          bne             EditMem6                        ; end of string?
 00FFF50F 0CE000008                       ldu             #8                                              ; reset the byte count
 00FFF512 020FD5                          bra             EditMem2
                              EditMem6:                       
 00FFF514 0E7800                          stb             ,x+                                             ; store the character in memory
 00FFF516 0335FF                          leau    -1,u                                    ; decrement byte count
 00FFF518 283000000                       cmpu    #0
 00FFF51B 022FEB                          bhi             EditMem4                        ; max 40 chars
                              EditMem3:
 00FFF51D 016FFFB19                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                                      
 
                              ;------------------------------------------------------------------------------
                              ; Fill Memory
                              ;
                              ; Usage:
                              ;       $$F FFFC12 FFFC30 89F
                              ;
                              ;------------------------------------------------------------------------------
 
                              FillMemory:
 00FFF520 017FFFC80                       lbsr    GetRange                        ; get address range to fill
*** warning 1: Long branch within short branch range could be optimized
 00FFF523 017FFFC25                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 00FFF526 017FFFCA3                       lbsr    GetHexNumber    ; get target byte to write
*** warning 1: Long branch within short branch range could be optimized
 00FFF529 0F6000913                       ldb             mon_numwka+3
 00FFF52C 0BE000922                       ldx             mon_r1+2
 00FFF52F 04F                             clra
                              fillm1:                                                         ; Check for a CTRL-C every page of memory
 00FFF530 04D                             tsta
 00FFF531 02600D                          bne             fillm2
 00FFF533 05F                             clrb                                                            ; we want a non-blocking check
 00FFF534 04F                             clra
 00FFF535 017FFF971                       lbsr    INCH
*** warning 1: Long branch within short branch range could be optimized
 00FFF538 0C1003                          cmpb    #CTRLC
 00FFF53A 127FFFAFC                       lbeq    Monitor
*** warning 1: Long branch within short branch range could be optimized
 00FFF53D 0F6000913                       ldb             mon_numwka+3    ; reset target byte
                              fillm2:
 00FFF540 0E7800                          stb             ,x+
 00FFF542 0BC000926                       cmpx    mon_r2+2
 00FFF545 023FE9                          bls             fillm1
                              fillm3:
 00FFF547 016FFFAEF                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                                      
                              ;------------------------------------------------------------------------------
                              ; Dump Registers
                              ;
                              ;       Usage:
                              ;               $DR
                              ;------------------------------------------------------------------------------
 
                              DumpRegs:
 00FFF54A 0CCFFF441                       ldd             #msgRegHeadings
 00FFF54D 017FFEE8A                       lbsr    DisplayString
*** warning 1: Long branch within short branch range could be optimized
 00FFF550 08DF2D                          bsr             nXBLANK
 00FFF552 0FC000900                       ldd             mon_DSAVE
 00FFF555 08DF24                          bsr             nHEX4
 00FFF557 08DF26                          bsr             nXBLANK
 00FFF559 0FC000902                       ldd             mon_XSAVE
 00FFF55C 08DF1D                          bsr             nHEX4
 00FFF55E 08DF1F                          bsr             nXBLANK
 00FFF560 0FC000904                       ldd             mon_YSAVE
 00FFF563 08DF16                          bsr             nHEX4
 00FFF565 08DF18                          bsr             nXBLANK
 00FFF567 0FC000906                       ldd             mon_USAVE
 00FFF56A 08DF0F                          bsr             nHEX4
 00FFF56C 08DF11                          bsr             nXBLANK
 00FFF56E 0FC000908                       ldd             mon_SSAVE
 00FFF571 08DF08                          bsr             nHEX4
 00FFF573 08DF0A                          bsr             nXBLANK
 00FFF575 0F600090B                       ldb             mon_PCSAVE+1
 00FFF578 017FFEEBC                       lbsr    DispByteAsHex   
*** warning 1: Long branch within short branch range could be optimized
 00FFF57B 0FC00090C                       ldd             mon_PCSAVE+2
 00FFF57E 08DEFB                          bsr             nHEX4
 00FFF580 08DEFD                          bsr             nXBLANK
 00FFF582 0FC00090E                       ldd             mon_DPRSAVE
 00FFF585 0BDFFD2CE                       jsr             HEX2
 00FFF588 08DEF5                          bsr             nXBLANK
 00FFF58A 0B600090F                       lda             mon_CCRSAVE
 00FFF58D 017FFDD3E                       lbsr    HEX2
*** warning 1: Long branch within short branch range could be optimized
 00FFF590 08DEED                          bsr             nXBLANK
 00FFF592 016FFFAA4                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
 
                              ;------------------------------------------------------------------------------
                              ; Jump to code
                              ;
                              ; Registers are loaded with values from the monitor register save area before
                              ; the code is jumped to.
                              ;
                              ; J <address>
                              ;------------------------------------------------------------------------------
 
                              jump_to_code:
 00FFF595 08DCCB                          bsr             GetNumber
 00FFF597 01A010                          sei
 00FFF599 1FE000908                       lds             mon_SSAVE
 00FFF59C 0CCFFF5D0                       ldd             #jtc_exit               ; setup stack for RTS back to monitor
 00FFF59F 034006                          pshs    d
 00FFF5A1 0C6000                          ldb             #0
 00FFF5A3 034004                          pshs    b
 00FFF5A5 0FC000912                       ldd             mon_numwka+2    ; get the address parameter
 00FFF5A8 034006                          pshs    d
 00FFF5AA 0F6000911                       ldb             mon_numwka+1
 00FFF5AD 034004                          pshs    b
 00FFF5AF 0FC000906                       ldd             mon_USAVE
 00FFF5B2 034006                          pshs    d
 00FFF5B4 0FC000904                       ldd             mon_YSAVE
 00FFF5B7 034006                          pshs    d
 00FFF5B9 0FC000902                       ldd             mon_XSAVE
 00FFF5BC 034006                          pshs    d
 00FFF5BE 0B600090E                       lda             mon_DPRSAVE
 00FFF5C1 034002                          pshs    a
 00FFF5C3 0FC000900                       ldd             mon_DSAVE
 00FFF5C6 034006                          pshs    d
 00FFF5C8 0B600090F                       lda             mon_CCRSAVE
 00FFF5CB 034002                          pshs    a
 00FFF5CD 0150350FF                       puls    far ccr,d,dpr,x,y,u,pc
                              jtc_exit:
 00FFF5D0 1FF000908                       sts             >mon_SSAVE              ; need to use extended addressing, no direct page setting
 00FFF5D3 03280F006FFF                    leas    $6FFF                                   ; reset stack to system area, dont modify flags register!
 00FFF5D7 034001                          pshs    ccr                                             ; now the stack can be used
 00FFF5D9 034002                          pshs    a                                                       ; save acca register so we can use it
 00FFF5DB 01F0B8                          tfr             dpr,a                                   ; a = outgoing dpr value
 00FFF5DD 0B700090E                       sta             >mon_DPRSAVE    ; force extended addressing mode usage here dpr is not set
 00FFF5E0 04F                             clra                                                            ; dpg register must be set to zero before values are 
 00FFF5E1 01F08B                          tfr             a,dpr                                   ; saved in the monitor register save area.
 00FFF5E3 035002                          puls    a                                                       ; get back acca
 00FFF5E5 0FD000900                       std             mon_DSAVE                       ; save regsters, can use direct addressing now
 00FFF5E8 0BF000902                       stx             mon_XSAVE
 00FFF5EB 1BF000904                       sty             mon_YSAVE
 00FFF5EE 0FF000906                       stu             mon_USAVE
 00FFF5F1 035002                          puls    a                                                       ; get back ccr
 00FFF5F3 0B700090F                       sta             mon_CCRSAVE             ; and save it too
                                      ; Reset vectors in case they got toasted.
 00FFF5F6 0CCFFEC64                       ldd             #SerialPeekCharDirect
 00FFF5F9 0FD000804                       std             CharInVec
 00FFF5FC 0CCFFE319                       ldd             #DisplayChar
 00FFF5FF 0FD000800                       std             CharOutVec
 00FFF602 0FCFFF2B6                       ldd             DisplayErr
 00FFF605 0FD00080C                       std             MonErrVec
                                      ; todo set according to coreid
 00FFF608 016FFFF3F                       lbra    DumpRegs                        ; now go do a register dump
*** warning 1: Long branch within short branch range could be optimized
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
 
                              DumpIOFocusList:
 00FFF60B 08E000000                       ldx             #0
                              dfl2:
 00FFF60E 0E680A000FFC000                 ldb             IOFocusList,x
 00FFF613 0C1018                          cmpb    #24
 00FFF615 02600A                          bne             dfl1
 00FFF617 01F010                          tfr             x,d
 00FFF619 017FFEE1B                       lbsr    DispByteAsHex
*** warning 1: Long branch within short branch range could be optimized
 00FFF61C 0C6020                          ldb             #' '
 00FFF61E 017FFF8C0                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
                              dfl1:
 00FFF621 030001                          inx
 00FFF623 08C000010                       cmpx    #16
 00FFF626 025FE6                          blo             dfl2
 00FFF628 017FFDAA7                       lbsr    CRLF
*** warning 1: Long branch within short branch range could be optimized
 00FFF62B 016FFFA0B                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                                      
                              bootpg:
 00FFF62E 000                             fcb             $000
                              boot_stack:
 00FFF62F FFC0FF                          fcw             $FFC0FF
                              numBreakpoints:
 00FFF631 008                             fcb             8
                              mon_rom_vectab:
 00FFF632 FFF634                          fcw             mon_rom_vecs
                              mon_rom_vecs:
 00FFF634 FFF039                          fcw             Monitor                                         ; enter monitor program
 00FFF636 FFEEA9                          fcw             INCH                                                    ; input a character
 00FFF638 FFEEE1                          fcw             OUTCH                                                   ; output a character
 00FFF63A FFD0D2                          fcw             CRLF                                                    ; output carriage-return, line feed
 00FFF63C FFE3DA                          fcw             DisplayString
 00FFF63E FFE437                          fcw             DispByteAsHex
 00FFF640 FFE42E                          fcw             DispWordAsHex
 00FFF642 FFEEEB                          fcw             ShowSprites
 00FFF644 FFEF6F                          fcw             mon_srand
 00FFF646 FFEF9D                          fcw             mon_rand
 00FFF648 000000                          fcw             0                                                                       ; operating system call
 00FFF64A FFF1A3                          fcw             GetRange
 00FFF64C FFF262                          fcw             GetNumber
 
                              NumFuncs        EQU     (*-mon_rom_vectab)/2
 
                              ; The following table indicates which routines need to return values in the
                              ; D and possibly X registers.
 
                              mon_rettab:
 00FFF64E 000                             fcb             0                       ; monitor
 00FFF64F 800                             fcb             $800    ; INCH
 00FFF650 000                             fcb             0                       ; OUTCH
 00FFF651 000                             fcb             0                       ; CRLF
 00FFF652 000                             fcb             0                       ; DisplayString
 00FFF653 000                             fcb             0                       ; DisplayByte
 00FFF654 000                             fcb             0                       ; DisplayWord
 00FFF655 000                             fcb             0                       ; show sprites
 00FFF656 000                             fcb             0                       ; srand
 00FFF657 C00                             fcb             $C00    ; rand
 00FFF658 C00                             fcb             $C00    ; OS call
 00FFF659 000                             fcb             0                       ; GetRange
 00FFF65A 800                             fcb             $800    ; GetNumber
                                      
                              ;------------------------------------------------------------------------------
                              ; SWI routine.
                              ;
                              ; SWI is used to call ROM monitor routines and process breakpoints.
                              ;
                              ;       swi
                              ;       fcb <desired function>
                              ;------------------------------------------------------------------------------
 
                              swi_rout:
 00FFF65B 0E680CFD0                       ldb             bootpg,pcr                      ; reset direct page
 00FFF65E 01F09B                          tfr             b,dp
                              swi_rout1:
 00FFF660 0EE60B                          ldu             11,s                                            ; get program counter (low order 2 bytes)
 00FFF662 0335FF                          leau    -1,u                                            ; backup a byte
 00FFF664 07D000810                       tst             BreakpointFlag  ; are we in breakpoint mode?
 00FFF667 02700F                          beq             swiNotBkpt
 00FFF669 0CE000820                       ldu             #Breakpoints
 00FFF66C 0F6000811                       ldb             NumSetBreakpoints
 00FFF66F 027007                          beq             swiNotBkpt
                              swi_rout2:
 00FFF671 2A3A01                          cmpu    ,y++    
 00FFF673 02704B                          beq             processBreakpoint
 00FFF675 05A                             decb
 00FFF676 026FF9                          bne             swi_rout2
                              swiNotBkpt:
 00FFF678 07F000810                       clr             BreakpointFlag
 00FFF67B 037006                          pulu    d                                                               ; get function #, increment PC
 00FFF67D 0C100E                          cmpb    #NumFuncs
 00FFF67F 122FFFC34                       lbhi    DisplayErr
*** warning 1: Long branch within short branch range could be optimized
 00FFF682 0EF60B                          stu             11,s                                            ; save updated PC on stack
 00FFF684 0C100A                          cmpb    #MF_OSCALL
 00FFF686 02706D                          beq             swiCallOS
 00FFF688 058                             aslb                                                                    ; 2 bytes per vector
 00FFF689 0AE80CFA6                       ldx             mon_rom_vectab,pcr
 00FFF68C 03A                             abx
 00FFF68D 0AE804                          ldx             ,x
 00FFF68F 0BF000928                       stx             jmpvec
 00FFF692 054                             lsrb
 00FFF693 08EFFF64E                       ldx             #mon_rettab
 00FFF696 03A                             abx
 00FFF697 0E6804                          ldb             ,x
 00FFF699 0F7000930                       stb             mon_retflag
 00FFF69C 1FF000908                       sts             mon_SSAVE                               ; save the stack pointer
 00FFF69F 0EC601                          ldd             1,s                                                     ; get back D
 00FFF6A1 0AE604                          ldx             4,s                                                     ; get back X
 00FFF6A3 1AE606                          ldy             6,s                                                     ; get back Y
 00FFF6A5 0EE608                          ldu             8,s                                                     ; get back U
 00FFF6A7 1EE80CF85                       lds             boot_stack,pcr  ; and use our own stack
 00FFF6AA 0AD90F000928                    jsr             [jmpvec]                                ; call the routine
                              swi_rout3:
 00FFF6AE 1FE000908                       lds             mon_SSAVE                               ; restore stack
 00FFF6B1 07D000930                       tst             mon_retflag
 00FFF6B4 02A009                          bpl             swi_rout4
 00FFF6B6 0ED601                          std             1,s                                                     ; return value in D
 00FFF6B8 078000930                       asl             mon_retflag
 00FFF6BB 02A002                          bpl             swi_rout4
 00FFF6BD 0AF604                          stx             4,s                                                     ; return value in X
                              swi_rout4:
 00FFF6BF 03B                             rti
 
                              processBreakpoint:
 00FFF6C0 0A6E04                          lda             ,s
 00FFF6C2 0B700090F                       sta             mon_CCRSAVE
 00FFF6C5 0EC601                          ldd             1,s
 00FFF6C7 0FD000900                       std             mon_DSAVE
 00FFF6CA 0E6603                          ldb             3,s
 00FFF6CC 0F700090E                       stb             mon_DPRSAVE
 00FFF6CF 0EC604                          ldd             4,s
 00FFF6D1 0FD000902                       std             mon_XSAVE
 00FFF6D4 0EC606                          ldd             6,s
 00FFF6D6 0FD000904                       std             mon_YSAVE
 00FFF6D9 0EC608                          ldd             8,s
 00FFF6DB 0FD000906                       std             mon_USAVE
 00FFF6DE 1FF000908                       sts             mon_SSAVE
 00FFF6E1 0EC60B                          ldd             11,s
 00FFF6E3 0FD00090A                       std             mon_PCSAVE
 00FFF6E6 1EE80CF46                       lds             boot_stack,pcr
 00FFF6E9 0CCFFF6AE                       ldd             #swi_rout3                      ; setup so monitor can return
 00FFF6EC 034006                          pshs    d
 00FFF6EE 08D01F                          bsr             DisarmAllBreakpoints
 00FFF6F0 016FFFE57                       lbra    DumpRegs
*** warning 1: Long branch within short branch range could be optimized
 
                              xitMonitor:
 00FFF6F3 020039                          bra             ArmAllBreakpoints
 
                              swiCallOS:      
 00FFF6F5 033401                          leau    1,u                                                     ; next byte is func number
 00FFF6F7 0E6C00                          ldb             ,u+
 00FFF6F9 0C1019                          cmpb    #NumOSFuncs                     ; check for valid range
 00FFF6FB 122FFFBB8                       lbhi    DisplayErr
*** warning 1: Long branch within short branch range could be optimized
 00FFF6FE 0EF60B                          stu             11,s                                            ; save updateed PC on stack
 00FFF700 058                             aslb                                                                    ; compute vector address
 00FFF701 08EFFEEF6                       ldx             #OSCallTbl
 00FFF704 06DE0F                          tst             b,x                                                     ; check for non-zero vector
 00FFF706 027FA6                          beq             swi_rout3
                              osc1:
                              ;       tst             OSSEMA+1                                ; wait for availability
                              ;       beq             osc1
 00FFF708 0ADF0F                          jsr             [b,x]                                           ; call the OS routine
                              oscx:
 00FFF70A 07FEF0011                       clr             OSSEMA+1
 00FFF70D 020F9F                          bra             swi_rout3
 
                              DisarmAllBreakpoints:
 00FFF70F 034036                          pshs    d,x,y
 00FFF711 18E000000                       ldy             #0
 00FFF714 05F                             clrb
 00FFF715 08E000830                       ldx             #BreakpointBytes        ; x = breakpoint byte table address
                              disarm2:
 00FFF718 0C1631                          cmpb    #numBreakpoints         ; safety check
 00FFF71A 024010                          bhs             disarm1
 00FFF71C 0F1000811                       cmpb    NumSetBreakpoints
 00FFF71F 02400B                          bhs             disarm1
 00FFF721 0A6837                          lda             b,x                                                             ; get memory byte
 00FFF723 0A7B09000820                    sta             [Breakpoints,y]         ; and store it back to memory
 00FFF727 031202                          leay    2,y                                                             ; increment for next address
 00FFF729 05C                             incb                                                                            ; increment to next byte
 00FFF72A 020FEC                          bra             disarm2                                         ; loop back
                              disarm1:
 00FFF72C 0350B6                          puls    d,x,y,pc
 
                              ArmAllBreakpoints:
 00FFF72E 034036                          pshs    d,x,y
 00FFF730 18E000000                       ldy             #0
 00FFF733 05F                             clrb
 00FFF734 08E000830                       ldx             #BreakpointBytes        ; x = breakpoint byte table address
                              arm2:
 00FFF737 0F1FFF631                       cmpb    numBreakpoints          ; safety check
 00FFF73A 024010                          bhs             arm1
 00FFF73C 0F1000811                       cmpb    NumSetBreakpoints
 00FFF73F 02400B                          bhs             arm1
 00FFF741 0A6B09000820                    lda             [Breakpoints,y]         ; load byte at memory address
 00FFF745 0A7B0D                          sta             b,x                                                             ; save in table
 00FFF747 031202                          leay    2,y                                                             ; increment for next address
 00FFF749 05C                             incb                                                                            ; increment to next byte
 00FFF74A 020FEB                          bra             arm2                                                    ; loop back
                              arm1:
 00FFF74C 0350B6                          puls    d,x,y,pc
 
                              ArmBreakpoint:
 00FFF74E 034036                          pshs    d,x,y
 00FFF750 0B6000811                       lda             NumSetBreakpoints               ; check if too many breakpoints set
 00FFF753 0B1FFF631                       cmpa    numBreakpoints
 00FFF756 124FFFB5D                       lbhs    DisplayErr
*** warning 1: Long branch within short branch range could be optimized
 00FFF759 017FFFA70                       lbsr    GetHexNumber                            ; get address parameter
*** warning 1: Long branch within short branch range could be optimized
 00FFF75C 0F6000811                       ldb             NumSetBreakpoints               ; bv= number of set breakpoints
 00FFF75F 1BE000912                       ldy             mon_numwka+2                            ; get address
 00FFF762 0A6A04                          lda             ,y                                                                      ; get byte at address
 00FFF764 08E000830                       ldx             #BreakpointBytes                ; and store byte in a table
 00FFF767 0A7A05                          sta             b,x                                                                     ; record
 00FFF769 08603F                          lda             #OPC_SWI                                                ; put a SWI instruction in place
 00FFF76B 0A7A04                          sta             ,y
 00FFF76D 08E000820                       ldx             #Breakpoints                            ; also store the address in a table
 00FFF770 058                             aslb                                                                                    ; index for 2 byte values
 00FFF771 1AFA05                          sty             b,x
 00FFF773 054                             lsrb                                                                                    ; size back to single byte
 00FFF774 05C                             incb
 00FFF775 0F7000811                       stb             NumSetBreakpoints
 00FFF778 0350B6                          puls    d,x,y,pc
 
                              DisarmBreakpoint:
 00FFF77A 034076                          pshs    d,x,y,u
 00FFF77C 017FFFA4D                       lbsr    GetHexNumber
*** warning 1: Long branch within short branch range could be optimized
 00FFF77F 05F                             clrb
 00FFF780 05F                             clrb
 00FFF781 01F001                          tfr             d,x                                                                     ; x = zero too
                              disarm6:
 00FFF783 0F1FFF631                       cmpb    numBreakpoints                  ; no more than this many may be set
 00FFF786 024041                          bhs             disarm4
 00FFF788 0F1000811                       cmpb    NumSetBreakpoints               ; number actually set
 00FFF78B 02403C                          bhs             disarm4
 00FFF78D 1AE809000820                    ldy             Breakpoints,x                           ; y = breakpoint address
 00FFF791 1BC000912                       cmpy    mon_numwka+2                            ; is it the one we want?
 00FFF794 02602E                          bne             disarm3                                                 ; if not, go increment to next
 00FFF796 0BE000912                       ldx             mon_numwka+2                            ; x = memory address
 00FFF799 18E000830                       ldy             #BreakpointBytes
 00FFF79C 0A6A0D                          lda             b,y                                                                     ; get saved byte from table
 00FFF79E 0A7804                          sta             ,x                                                                      ; set the byte at the memory address
                                      ; compress breakpoint table by removing breakpoint
 00FFF7A0 07A000811                       dec             NumSetBreakpoints               ; set the new number of set breakpoints
 00FFF7A3 034004                          pshs    b                                                                               ; save the position we're removing from
                              disarm7:
 00FFF7A5 05C                             incb                                                                                    ; set index for next byte
 00FFF7A6 0A6A05                          lda             b,y                                                                     ; get byte
 00FFF7A8 05A                             decb                                                                                    ; and store it back
 00FFF7A9 0A7A05                          sta             b,y
 00FFF7AB 05C                             incb                                                                                    ; move to next position
 00FFF7AC 0F1FFF631                       cmpb    numBreakpoints                  ; hit end of table?
 00FFF7AF 025FF4                          blo             disarm7
 00FFF7B1 035004                          puls    b                                                                               ; get back position
 00FFF7B3 058                             aslb                                                                                    ; times two for word index
 00FFF7B4 04F                             clra
 00FFF7B5 01F002                          tfr             d,y
 00FFF7B7 054                             lsrb                                                                                    ; back to byte index value
                              disarm8:
 00FFF7B8 0EE202                          ldu             2,y                                                                     ; get next breakpoint address
 00FFF7BA 0EFA01                          stu             ,y++                                                            ; store in current pos, increment
 00FFF7BC 05C                             incb                                                                                    ; increment count
 00FFF7BD 0F1FFF631                       cmpb    numBreakpoints                  ; hit end of table?
 00FFF7C0 025FF6                          blo             disarm8
 00FFF7C2 0350F6                          puls    d,x,y,u,pc
                              disarm3:
 00FFF7C4 030002                          leax    2,x
 00FFF7C6 05C                             incb
 00FFF7C7 020FBA                          bra             disarm6
                              disarm4:
 00FFF7C9 0350F6                          puls    d,x,y,u,pc
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              swi3_rout:
 00FFF7CB 01A010                          sei
 00FFF7CD 0A6E04                          lda             ,s
 00FFF7CF 0B700090F                       sta             mon_CCRSAVE
 00FFF7D2 0EC601                          ldd             1,s
 00FFF7D4 0FD000900                       std             mon_DSAVE
 00FFF7D7 0E6603                          ldb             3,s
 00FFF7D9 0F700090E                       stb             mon_DPRSAVE
 00FFF7DC 0EC604                          ldd             4,s
 00FFF7DE 0FD000902                       std             mon_XSAVE
 00FFF7E1 0EC606                          ldd             6,s
 00FFF7E3 0FD000904                       std             mon_YSAVE
 00FFF7E6 0EC608                          ldd             8,s
 00FFF7E8 0FD000906                       std             mon_USAVE
 00FFF7EB 1FF000908                       sts             mon_SSAVE
 00FFF7EE 0EC60B                          ldd             11,s
 00FFF7F0 0FD00090A                       std             mon_PCSAVE
 00FFF7F3 1FF000908                       sts             mon_SSAVE
 00FFF7F6 1CE003FFF                       lds             #$3FFF
 00FFF7F9 0CCFFF803                       ldd             #swi3_exit
 00FFF7FC 034006                          pshs    d
 00FFF7FE 01C0EF                          cli
 00FFF800 07EFFF54A                       jmp             DumpRegs
                              swi3_exit:
 00FFF803 1FE000908                       lds             mon_SSAVE
 00FFF806 03B                             rti
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              firq_rout:
 00FFF807 03B                             rti
 
                              irq_rout:
                              ;       lbsr    SerialIRQ       ; check for recieved character
 00FFF808 017FFEC85                       lbsr    TimerIRQ
*** warning 1: Long branch within short branch range could be optimized
 
                                      ; Reset the edge sense circuit in the PIC
                              ;       lda             #31                                                     ; Timer is IRQ #31
                              ;       sta             IrqSource               ; stuff a byte indicating the IRQ source for PEEK()
                              ;       sta             PIC+16                                  ; register 16 is edge sense reset reg   
                              ;       lda             VIA+VIA_IFR
                              ;       bpl             notTimerIRQ2
                              ;       bita    #$800
                              ;       beq             notTimerIRQ2
                              ;       clr             VIA+VIA_T3LL
                              ;       clr             VIA+VIA_T3LH
                              ;       inc             $E00037                                 ; update timer IRQ screen flag
                              ;notTimerIRQ2:
 
 00FFF80B 0B6FFC014                       lda             IrqBase                 ; get the IRQ flag byte
 00FFF80E 044                             lsra
 00FFF80F 0BAFFC014                       ora             IrqBase
 00FFF812 084FE0                          anda    #$FE0
 00FFF814 0B7FFC014                       sta             IrqBase
 
                              ;       inc             TEXTSCR+54              ; update IRQ live indicator on screen
                                      
                                      ; flash the cursor
                                      ; only bother to flash the cursor for the task with the IO focus.
                              ;       lda             COREID
                              ;       cmpa    IOFocusID
                              ;       bne             tr1a
                              ;       lda             CursorFlash             ; test if we want a flashing cursor
                              ;       beq             tr1a
                              ;       lbsr    CalcScreenLoc   ; compute cursor location in memory
                              ;       tfr             d,y
                              ;       lda             $2000,y                 ; get color code $2000 higher in memory
                              ;       ldb             IRQFlag                 ; get counter
                              ;       lsrb
                              ;       lsra
                              ;       lsra
                              ;       lsra
                              ;       lsra
                              ;       lsrb
                              ;       rola
                              ;       lsrb
                              ;       rola
                              ;       lsrb
                              ;       rola
                              ;       lsrb
                              ;       rola
                              ;       sta             $E00000,y               ; store the color code back to memory
                              tr1a:
 00FFF817 03B                             rti
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              nmi_rout:
 00FFF818 0150F6FFFFFFFE0                 ldb             COREID
 00FFF81D 086049                          lda             #'I'
 00FFF81F 08EE00028                       ldx             #TEXTSCR+40
 00FFF822 0A7807                          sta             b,x
                              rti_insn:
 00FFF824 03B                             rti
 
                              ; Special Register Area
                                      org             $FFFFE0
 
                              ; Interrupt vector table
 
                                      org             $FFFFF0
 00FFFFF0 FFF824                          fcw             rti_insn                ; reserved
 00FFFFF2 FFF7CB                          fcw             swi3_rout               ; SWI3
 00FFFFF4 FFF824                          fcw             rti_insn                ; SWI2
 00FFFFF6 FFF807                          fcw             firq_rout               ; FIRQ
 00FFFFF8 FFF808                          fcw             irq_rout                ; IRQ
 00FFFFFA FFF65B                          fcw             swi_rout                ; SWI
 00FFFFFC FFF818                          fcw             nmi_rout                ; NMI
 00FFFFFE FFE023                          fcw             start                           ; RST

66 warning(s) in pass 2.

SYMBOL TABLE
      ABD1 02 00FFF2AC      ABD2 02 00FFF2B3      ACIA 00 FFE30100  ACIA_CMD 00 00000002
 ACIA_CTRL 00 00000003 ACIA_CTRL2 00 0000000B   ACIA_RX 00 00000000 ACIA_STAT 00 00000001
   ACIA_TX 00 00000000      ARM1 02 00FFF74C      ARM2 02 00FFF737 ARMALLBREAKPOINTS 02 00FFF72E
 ARMBREAKPOINT 02 00FFF74E ASCIITOBINDIGIT 02 00FFF2A6 ASCIITODECDIGIT 02 00FFF298 ASCIITOHEXNYBBLE 02 00FFF270
    ASMBUF 00 00000160 BIOS_SCREENS 00 17000000 BLANKLINE 02 00FFE280 BLKCPYDST 00 00000020
 BLKCPYSRC 00 0000001C   BLNKLN1 02 00FFE293    BOOTPG 02 00FFF62E BOOT_STACK 02 00FFF62F
 BREAKPOINTBYTES 00 00000830 BREAKPOINTFLAG 00 00000810 BREAKPOINTS 00 00000820 CALCSCREENLOC 02 00FFE2F2
 CHARCOLOR 00 00000112 CHARINVEC 00 00000804 CHAROUTVEC 00 00000800 CHECKPOINT 02 00FFE13D
 CLEARSCREEN 02 00FFE239 CLEARSCREENJMP 02 00FFD300 CMDPROMPT 02 00FFF009 CMDPROMPTJI 00 00000808
 CMDTABLE1 02 00FFEFB2 CMDTABLE2 02 00FFEFE3 COLORCODELOCATION 00 00000014      COLS 00 00000040
 COPYSCREENTOVIRTUALSCREEN 02 00FFE209 COPYVIRTUALSCREENTOSCREEN 02 00FFE1D2    COREID 00 FFFFFFE0        CR 00 0000000D
      CRLF 02 00FFD0D2     CRLF1 02 00FFD0D2    CRLFST 02 00FFE422       CS1 02 00FFE246
       CS2 02 00FFE25D     CS2V1 02 00FFE215       CS3 02 00FFE263      CSL1 02 00FFE311
     CTRLC 00 00000003     CTRLH 00 00000008     CTRLI 00 00000009     CTRLJ 00 0000000A
     CTRLK 00 0000000B     CTRLM 00 0000000D     CTRLS 00 00000013     CTRLT 00 00000014
     CTRLX 00 00000018     CTRLZ 00 0000001A CURSORCOL 00 00000111 CURSORFLASH 00 00000114
 CURSORROW 00 00000110     CV2S1 02 00FFE1E7 DBGCHECKFORKEY 02 00FFEA90     DBGK1 02 00FFEACB
    DBGK10 02 00FFEB30    DBGK11 02 00FFEB89    DBGK12 02 00FFEB8F    DBGK13 02 00FFEB9B
    DBGK14 02 00FFEBAB    DBGK15 02 00FFEBBA    DBGK16 02 00FFEBC5    DBGK17 02 00FFEBCE
    DBGK18 02 00FFEBD1     DBGK2 02 00FFEA96    DBGK20 02 00FFEAB8    DBGK22 02 00FFEAD4
    DBGK23 02 00FFEAE5    DBGK24 02 00FFEAC6     DBGK3 02 00FFEAE8     DBGK4 02 00FFEAF4
     DBGK5 02 00FFEB00     DBGK7 02 00FFEB10     DBGK8 02 00FFEB16     DBGK9 02 00FFEB2A
 DBGKNOTALT 02 00FFEB93 DBGKNOTCAPSLOCK 02 00FFEB62 DBGKNOTCTRL 02 00FFEB1A DBGKNOTNUMLOCK 02 00FFEB4B
 DBGKNOTRSHIFT 02 00FFEB34 DBGKNOTSCROLLLOCK 02 00FFEB79      DCCR 02 00FFE329      DCLF 02 00FFE3B3
     DCX10 02 00FFE363     DCX11 02 00FFE373     DCX12 02 00FFE36F     DCX13 02 00FFE37F
     DCX14 02 00FFE326      DCX3 02 00FFE3A1      DCX4 02 00FFE3B5      DCX5 02 00FFE390
      DCX6 02 00FFE33A      DCX7 02 00FFE336      DCX8 02 00FFE347      DCX9 02 00FFE354
   DELAY3S 02 00FFE1B5      DFL1 02 00FFF621      DFL2 02 00FFF60E   DISARM1 02 00FFF72C
   DISARM2 02 00FFF718   DISARM3 02 00FFF7C4   DISARM4 02 00FFF7C9   DISARM6 02 00FFF783
   DISARM7 02 00FFF7A5   DISARM8 02 00FFF7B8 DISARMALLBREAKPOINTS 02 00FFF70F DISARMBREAKPOINT 02 00FFF77A
 DISPBYTEASHEX 02 00FFE437 DISPDWORDASHEX 02 00FFE425 DISPLAYCHAR 02 00FFE319 DISPLAYERR 02 00FFF2B6
 DISPLAYSTRING 02 00FFE3DA DISPLAYSTRINGCRLF 02 00FFE3FA DISPLAYSTRINGDX 02 00FFF2BF   DISPNYB 02 00FFE44F
  DISPNYB1 02 00FFE45E DISPWORDASHEX 02 00FFE42E    DLY3S1 02 00FFE1B8    DLY3S2 02 00FFE1BC
     DMPM1 02 00FFF4A1     DMPM2 02 00FFF48C     DMPM3 02 00FFF4DA     DMPM4 02 00FFF4CC
     DMPM5 02 00FFF4C4 DRAM_BASE 00 10000000    DSPJ1B 02 00FFE3EC     DSPJ2 02 00FFE3E7
    DSRETB 02 00FFE3F5 DUMPIOFOCUSLIST 02 00FFF60B DUMPMEMORY 02 00FFF484  DUMPREGS 02 00FFF54A
    DUMRTS 02 00FFE022  EDITMEM1 02 00FFF4FE  EDITMEM2 02 00FFF4E9  EDITMEM3 02 00FFF51D
  EDITMEM4 02 00FFF508  EDITMEM6 02 00FFF514 EDITMEMORY 02 00FFF4E0 ENDOFWORD 02 00FFF0ED
   FARFLAG 00 0000015F    FILLM1 02 00FFF530    FILLM2 02 00FFF540    FILLM3 02 00FFF547
 FILLMEMORY 02 00FFF520 FIRQ_ROUT 02 00FFF807 FIRST_CORE 00 00000001   FREEMBX 02 00000002
   FREEMSG 02 00000006   FREETCB 00 0000078A GETBINNUMBER 02 00FFF1FC GETDECNUMBER 02 00FFF223
 GETHEXNUMBER 02 00FFF1CC    GETKEY 02 00FFEA92 GETNUMBER 02 00FFF262  GETRANGE 02 00FFF1A3
 GETSCREENLOCATION 02 00FFE29A GETTWOPARAMS 02 00FFF182     GRNG1 02 00FFF1BE      GSL1 02 00FFE2AC
    GTBIN1 02 00FFF21F    GTBIN2 02 00FFF209     GTDC3 02 00FFF2A3    GTDEC1 02 00FFF25E
    GTDEC2 02 00FFF230     GTHX3 02 00FFF295     GTHX5 02 00FFF27B     GTHX6 02 00FFF288
    GTHXN1 02 00FFF1F8    GTHXN2 02 00FFF1D9       HC1 02 00FFE2CA   HELPMSG 02 00FFF2CF
      HEX2 02 00FFD2CE      HEX4 02 00FFD2D2 HOMECURSOR 02 00FFE2B0 HOMECURSORJMP 02 00FFD308
     I2CW1 02 00FFE4BF    I2CWR1 02 00FFE4EC   I2C_CMD 00 00000004  I2C_CTRL 00 00000002
  I2C_INIT 02 00FFE4B3  I2C_PREH 00 00000001  I2C_PREL 00 00000000   I2C_RXR 00 00000003
  I2C_STAT 00 00000004   I2C_TXR 00 00000003 I2C_WAIT_RX_NACK 02 00FFE4EA I2C_WAIT_TIP 02 00FFE4BD
 I2C_WR_CMD 02 00FFE4C7 I2C_XMIT1 02 00FFE4D0      ICC1 02 00FFE3D6      ICC2 02 00FFE3D8
      ICR1 02 00FFE3C8 IGNBLANKS 02 00FFF14B IGNBLANKS1 02 00FFF14B INCCURSORPOS 02 00FFE3B7
 INCCURSORROW 02 00FFE3C6      INCH 02 00FFEEA9     INCH1 02 00FFEEBE     INCH2 02 00FFEEAB
     INCHE 02 00FFEEC7    INCHEK 02 00FFEECB   INCHEK1 02 00FFEEE0   INCHEK2 02 00FFEEDD
   INCHEK3 02 00FFEED4      INIT 02 00FFE0A8     INIT1 02 00FFE0B0     INIT2 02 00FFE0F8
 INITSERIAL 02 00FFEBEF IOFOCUSID 00 00FFC010 IOFOCUSLIST 00 00FFC000 IOFOCUSNDX 00 00000100
   IRQBASE 00 00FFC014   IRQFLAG 00 00FFC012 IRQSOURCE 00 00FFC011  IRQ_ROUT 02 00FFF808
    JMPVEC 00 00000928  JTC_EXIT 02 00FFF5D0 JUMP_TO_CODE 02 00FFF595 KBDBUFFULL 02 00FFEA8D
   KBDFIFO 00 00000040 KBDFIFOALIAS 00 00C00040 KBDHEADRCV 00 00000127  KBDI0002 02 00FFE9C9
  KBDI0004 02 00FFEA0E KBDITRYAGAIN 02 00FFEA02 KBDRCVCOUNT 02 00FFEA3D KBDTAILRCV 00 00000128
     KBGS1 02 00FFE978     KBGS2 02 00FFE970     KBGS3 02 00FFE961     KEYBD 00 FFE30400
  KEYBDACK 00 FFFFCC00  KEYBDBAD 00 FFFFCB00 KEYBDBLOCK 00 00000126 KEYBDBUFFER 00 FFFFC000
 KEYBDCHECKFORKEYDIRECT 02 00FFEEA7 KEYBDCLOSE 02 00FFEBEB  KEYBDCLR 00 FFE30402 KEYBDCONTROLCODES 02 00FFE800
 KEYBDECHO 00 FFFFCA00 KEYBDEXTENDEDCODES 02 00FFE880 KEYBDGETID 02 00FFE99C KEYBDGETSCANCODE 02 00FFE97D
 KEYBDGETSTATUS 02 00FFE961 KEYBDHEAD 00 FFFFC800   KEYBDID 00 00000124 KEYBDINIT 02 00FFE9C0
  KEYBDIRQ 02 00FFEA4F KEYBDLOCKS 00 FFFFCD00 KEYBDOPEN 02 00FFEBEA KEYBDREAD 02 00FFEBEC
 KEYBDRECVBYTE 02 00FFE900 KEYBDSEEK 02 00FFEBEE KEYBDSENDBYTE 02 00FFE919 KEYBDSETLED 02 00FFE989
 KEYBDTAIL 00 FFFFC900 KEYBDWAITTX 02 00FFE91F KEYBDWRITE 02 00FFEBED    KEYLED 00 00000122
 KEYSTATE1 00 00000120 KEYSTATE2 00 00000121     KGID1 02 00FFE9B9  KGNOTKBD 02 00FFE9BC
      KRB3 02 00FFE905      KRB4 02 00FFE915    KRCXIT 02 00FFEA4E      KWT1 02 00FFE924
      KWT2 02 00FFE935      LEDS 00 FFE60001    LEDXIT 02 00FFEA22    LETTER 02 00FFD2C1
        LF 00 0000000A MAX_TASKNO 00 0000003F   MF_CRLF 00 00000003 MF_DISPLAYBYTEASHEX 00 00000005
 MF_DISPLAYSTRING 00 00000004 MF_DISPLAYWORDASHEX 00 00000006 MF_GETNUMBER 00 0000000C MF_GETRANGE 00 0000000B
   MF_INCH 00 00000001 MF_MONITOR 00 00000000 MF_OSCALL 00 0000000A  MF_OUTCH 00 00000002
 MF_RANDOM 00 00000009 MF_SHOWSPRITES 00 00000007  MF_SRAND 00 00000008      MON1 02 00FFF08E
 MONARMBREAKPOINT 02 00FFF13A MONDISARMBREAKPOINT 02 00FFF145 MONERRVEC 00 0000080C  MONGETCH 02 00FFF12E
 MONGETNONSPACE 02 00FFF133   MONITOR 02 00FFF039 MON_CCRSAVE 00 0000090F MON_DPRSAVE 00 0000090E
 MON_DSAVE 00 00000900  MON_INIT 00 0000092C MON_NUMWKA 00 00000910 MON_PCSAVE 00 0000090A
    MON_R1 00 00000920    MON_R2 00 00000924  MON_RAND 02 00FFEF9D MON_RETFLAG 00 00000930
 MON_RETTAB 02 00FFF64E MON_ROM_VECS 02 00FFF634 MON_ROM_VECTAB 02 00FFF632 MON_SRAND 02 00FFEF6F
 MON_SRAND1 02 00FFEF72 MON_SSAVE 00 00000908 MON_USAVE 00 00000906 MON_VECTB 00 00000880
 MON_XSAVE 00 00000902 MON_YSAVE 00 00000904   MSCOUNT 00 FFFFFFE4 MSGBADKEYBD 02 00FFEA2E
    MSGERR 02 00FFF2C7 MSGF09STARTING 02 00FFF014 MSGREGHEADINGS 02 00FFF441 MSGS19LOADER 02 00FFEE93
 MSGSERIALTEST 02 00FFED45 MSGSTARTUP 02 00FFE11C MULTI_SIEVE 02 00FFE153 MULTI_SIEVE1 02 00FFE176
 MULTI_SIEVE2 02 00FFE172 MULTI_SIEVE3 02 00FFE160 MULTI_SIEVE4 02 00FFE189     NHEX4 02 00FFF47B
  NMAILBOX 02 00000004 NMESERIAL 02 00FFED0E   NMIBASE 00 00FFC013  NMI_ROUT 02 00FFF818
   NMSGBLK 02 00000008 NOTKBDIRQ 02 00FFEA8C  NOTRXINT 02 00FFED0D NOTTIMERIRQ 02 00FFE4B2
 NUMBREAKPOINTS 02 00FFF631  NUMFUNCS 00 0000000E NUMOSFUNCS 00 00000019 NUMSETBREAKPOINTS 00 00000811
   NXBLANK 02 00FFF47F    ONEKEY 02 00FFD1DC   OPC_SWI 00 0000003F      OSC1 02 00FFF708
 OSCALLTBL 02 00FFEEF6      OSCX 02 00FFF70A    OSSEMA 00 00EF0010     OUTCH 02 00FFEEE1
   OUTSEMA 00 00EF0000 PARSECMD1 02 00FFF0D8     PCRLF 02 00FFE40E     PDATA 02 00FFE41B
       PIC 00 FFE3F000    PICPTR 00 00000028     PRINT 02 00FFE418      PRNG 00 FFE30600
 PROCESSBREAKPOINT 02 00FFF6C0   PROMPT1 02 00FFF0BB  PROMPT2A 02 00FFF10C   PROMPT3 02 00FFF0AC
 PROMPTCLEARSCREEN 02 00FFF126 PROMPTHELP 02 00FFF11E  PROMPTLN 02 00FFF0A8    PSTRNG 02 00FFE40A
     QNDX0 00 00000780     QNDX1 00 00000782     QNDX2 00 00000784     QNDX3 00 00000786
     QNDX4 00 00000788    RAMERR 02 00FFD42C   RAMERR1 02 00FFD445   RAMTEST 02 00FFD400
  RAMTEST1 02 00FFD40D  RAMTEST3 02 00FFD417  REDIRECT 02 00FFF0F8 RELEASEIOFOCUS 02 00FFEF3F
 REQUESTIOFOCUS 02 00FFEF28     RIOF1 02 00FFEF66     RIOF2 02 00FFEF55  ROMTORAM 02 00FFE143
 ROMTORAM1 02 00FFE149      ROWS 00 00000020       RTC 00 FFE30500    RTCBUF 00 00007FC0
  RTCR0001 02 00FFE51A  RTCW0001 02 00FFE565  RTC_READ 02 00FFE4F4 RTC_RXERR 02 00FFE543
 RTC_WRITE 02 00FFE547  RTI_INSN 02 00FFF824 RUNNINGID 00 00FFC013 RUNNINGTCB 06 00000000
  S19ABORT 00 0000094A S19ADDRESS 00 00000940 S19CLEARADDRESS 02 00FFEDA6    S19GA1 02 00FFEDC4
    S19GA2 02 00FFEDE0    S19GB1 02 00FFED81    S19GB2 02 00FFEDA2 S19GETADDRESS2 02 00FFEDB3
 S19GETADDRESS3 02 00FFEDC5 S19GETBYTE 02 00FFED75     S19L2 02 00FFEE90     S19L3 02 00FFEE3F
    S19LNR 02 00FFEE83 S19LOADER 02 00FFEE37 S19NEXTRECORD 02 00FFED58    S19NR1 02 00FFED74
    S19NR2 02 00FFED68    S19NR3 02 00FFED6F    S19PM1 02 00FFEE07    S19PM2 02 00FFEDFD
    S19PM3 02 00FFEDE2 S19PROCESSS1 02 00FFEE0B S19PROCESSS2 02 00FFEE11 S19PROCESSS8 02 00FFEE27
 S19PROCESSS9 02 00FFEE17 S19PUTMEM 02 00FFEDE1 S19RECLEN 00 00000949 S19RECTYPE 00 00000948
 S19STARTADDRESS 00 00000944 SCANNEXTWORD 02 00FFF0E2 SCREENCOLOR 00 00000113 SCREENLOCATION 00 00000010
 SCREENLOCATION2 00 00000018  SCROLLUP 02 00FFE265    SCRUP1 02 00FFE272    SC_ALT 00 00000011
      SC_C 00 00000021 SC_CAPSLOCK 00 00000058   SC_CTRL 00 00000014    SC_DEL 00 00000071
 SC_EXTEND 00 000000E0    SC_F12 00 00000007  SC_KEYUP 00 000000F0 SC_NUMLOCK 00 00000077
 SC_RSHIFT 00 00000059 SC_SCROLLLOCK 00 0000007E      SC_T 00 0000002C    SC_TAB 00 0000000D
      SC_Z 00 0000001A   SEMAABS 00 00001000 SERHEADRCV 00 00000131 SERHEADXMIT 00 00000136
  SERHZERO 00 00000130 SERIALGETCHAR 02 00FFEC1D SERIALINIT 02 00FFEBEF SERIALIRQ 02 00FFECBB
 SERIALOUTPUTTEST 02 00FFED25 SERIALPEEKCHAR 02 00FFEC4D SERIALPEEKCHARDIRECT 02 00FFEC64 SERIALPUTCHAR 02 00FFEC88
 SERIALPUTSTRING 02 00FFED15 SERIALRCVCOUNT 02 00FFECA8 SERRCVBUF 00 00BFF000 SERRCVXOFF 00 00000140
 SERRCVXON 00 00000139 SERTAILRCV 00 00000133 SERTAILXMIT 00 00000138  SERTZERO 00 00000132
 SETKEYBOARDECHO 02 00FFEEE5      SGC2 02 00FFEC36 SGCNOCHARS 02 00FFEC46    SGCXIT 02 00FFEC49
 SHIFTEDSCANCODES 02 00FFE700 SHIFTLEFT5 02 00FFE1C7 SHL_NUMWKA 02 00FFF1BF SHOWSPRITES 02 00FFEEEB
     SIEVE 02 00FFE18D    SIEVE1 02 00FFE1A5    SIEVE2 02 00FFE1A1    SIEVE3 02 00FFE192
    SIEVE4 02 00FFE1B4     SINI1 02 00FFEC02  SIRQ0001 02 00FFECCD SIRQNXTBYTE 02 00FFECBB
 SIRQRXFULL 02 00FFED0D SKIPDOLLAR 02 00FFF0CA SKIP_INIT 02 00FFE10A    SOTST1 02 00FFED2F
   SPC0001 02 00FFEC8A  SPCD0001 02 00FFEC82 SPCNOCHARS 02 00FFEC5F    SPCXIT 02 00FFEC62
 SPRITE_CTRL 00 FFE10000 SPRITE_EN 00 000003C0      SPS2 02 00FFED19    SPSXIT 02 00FFED23
    SRCXIT 02 00FFECBA       ST1 02 00FFE0B5      ST10 02 00FFE118      ST11 02 00FFE060
       ST3 02 00FFE09F       ST6 02 00FFE03C       ST7 02 00FFE046       ST8 02 00FFE046
       ST9 02 00FFE069     START 02 00FFE023    STRPTR 00 00000024 SWI3_EXIT 02 00FFF803
 SWI3_ROUT 02 00FFF7CB SWICALLOS 02 00FFF6F5 SWINOTBKPT 02 00FFF678  SWI_ROUT 02 00FFF65B
 SWI_ROUT1 02 00FFF660 SWI_ROUT2 02 00FFF671 SWI_ROUT3 02 00FFF6AE SWI_ROUT4 02 00FFF6BF
       TAB 00 00000009 TCB_CURSORCOL 00 00000021 TCB_CURSORROW 00 00000020  TCB_HJCB 00 0000001C
 TCB_HWAITMBX 00 00000022 TCB_IOF_NEXT 00 0000002C TCB_IOF_PREV 00 00000030 TCB_MBQ_NEXT 00 00000024
 TCB_MBQ_PREV 00 00000028 TCB_MMU_MAP 00 00000038 TCB_MSGPTR_D1 00 00000014 TCB_MSGPTR_D2 00 00000018
 TCB_NXTRDY 00 00000000 TCB_NXTTCB 00 00000008 TCB_PRIORITY 00 00000010 TCB_PRVRDY 00 00000004
 TCB_SPSAVE 00 00000034 TCB_STATUS 00 0000001E TCB_TIMEOUT 00 0000000C TEXTCLOSE 02 00FFE235
  TEXTOPEN 02 00FFE234  TEXTREAD 02 00FFE236   TEXTREG 00 FFE07F00   TEXTSCR 00 FFE00000
  TEXTSEEK 02 00FFE238 TEXTWRITE 02 00FFE237 TEXT_COLS 00 00000000 TEXT_CURPOS 00 00000022
 TEXT_ROWS 00 00000001 TIMEOUTLIST 00 0000078C TIMERINIT 02 00FFE465  TIMERIRQ 02 00FFE490
   TIMES10 02 00FFF154      TR1A 02 00FFF817      UCP1 02 00FFE2F0 UNSHIFTEDSCANCODES 02 00FFE600
 UPDATECURSORPOS 02 00FFE2CC       VIA 00 FFE60000   VIA_ACR 00 0000000B  VIA_DDRA 00 00000003
   VIA_IER 00 0000000E   VIA_IFR 00 0000000D    VIA_PA 00 00000001 VIA_T3CMPH 00 00000015
 VIA_T3CMPL 00 00000014  VIA_T3LH 00 00000013  VIA_T3LL 00 00000012  W10_0001 02 00FFE940
 W300_0001 02 00FFE954  WAIT10MS 02 00FFE939 WAIT300MS 02 00FFE94D    XBLANK 02 00FFD0AF
 XITMONITOR 02 00FFF6F3      XOFF 00 00000013       XON 00 00000011
575 SYMBOLS

3 error(s), 592 warning(s)
