3 error(s), 1118 warning(s) unlisted in pass 1
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2013-2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; BSD 3-Clause License
                              ; Redistribution and use in source and binary forms, with or without
                              ; modification, are permitted provided that the following conditions are met:
                              ;
                              ; 1. Redistributions of source code must retain the above copyright notice, this
                              ;    list of conditions and the following disclaimer.
                              ;
                              ; 2. Redistributions in binary form must reproduce the above copyright notice,
                              ;    this list of conditions and the following disclaimer in the documentation
                              ;    and/or other materials provided with the distribution.
                              ;
                              ; 3. Neither the name of the copyright holder nor the names of its
                              ;    contributors may be used to endorse or promote products derived from
                              ;    this software without specific prior written permission.
                              ;
                              ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                              ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                              ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                              ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                              ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                              ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                              ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                              ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                              ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                              ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                              ;                                                                          
                              ; ============================================================================
                              ;
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2013-2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; BSD 3-Clause License
                              ; Redistribution and use in source and binary forms, with or without
                              ; modification, are permitted provided that the following conditions are met:
                              ;
                              ; 1. Redistributions of source code must retain the above copyright notice, this
                              ;    list of conditions and the following disclaimer.
                              ;
                              ; 2. Redistributions in binary form must reproduce the above copyright notice,
                              ;    this list of conditions and the following disclaimer in the documentation
                              ;    and/or other materials provided with the distribution.
                              ;
                              ; 3. Neither the name of the copyright holder nor the names of its
                              ;    contributors may be used to endorse or promote products derived from
                              ;    this software without specific prior written permission.
                              ;
                              ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                              ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                              ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                              ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                              ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                              ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                              ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                              ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                              ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                              ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                              ;                                                                          
                              ; ============================================================================
                              ;
                              ; ASCII control characters.
                              SOH             equ 1
                              EOT             equ 4
                              ACK             equ 6
                              BS              equ 8
                              NAK             equ 21
                              ETB             equ     $17
                              CAN             equ 24
                              DEL             equ 127
 
                              CR      EQU     $0D             ;ASCII equates
                              LF      EQU     $0A
                              TAB     EQU     $09
                              CTRLC   EQU     $03
                              CTRLH   EQU     $08
                              CTRLI   EQU     $09
                              CTRLJ   EQU     $0A
                              CTRLK   EQU     $0B
                              CTRLM   EQU $0D
                              CTRLS   EQU     $13
                              CTRLT EQU $14
                              CTRLX   EQU     $18
                              CTRLZ   EQU     $1A
                              XON             EQU     $11
                              XOFF    EQU     $13
 
                              FIRST_CORE      EQU     1
                              MAX_TASKNO      EQU 63
                              DRAM_BASE       EQU $10000000
 
                              ; ROM monitor functions
                              ;
                              MF_Monitor      EQU             0
                              MF_INCH                 EQU             1
                              MF_OUTCH                EQU     2
                              MF_CRLF                 EQU             3
                              MF_DisplayString        EQU             4
                              MF_DisplayByteAsHex             EQU     5
                              MF_DisplayWordAsHex             EQU     6
                              MF_ShowSprites  EQU             7
                              MF_Srand                EQU             8
                              MF_Random               EQU             9
                              MF_OSCALL               EQU             10
                              MF_GetRange     EQU             11      ; gets a pair of numbers last>first
                              MF_GetNumber    EQU     12
                              MF_SerialPutchar        EQU     13
 
                              mon_numwka      EQU             $910
                              mon_r1          EQU             $920
                              mon_r2          EQU             $924
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) S2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; BSD 3-Clause License
                              ; Redistribution and use in source and binary forms, with or without
                              ; modification, are permitted provided that the following conditions are met:
                              ;
                              ; 1. Redistributions of source code must retain the above copyright notice, this
                              ;    list of conditions and the following disclaimer.
                              ;
                              ; 2. Redistributions in binary form must reproduce the above copyright notice,
                              ;    this list of conditions and the following disclaimer in the documentation
                              ;    and/or other materials provided with the distribution.
                              ;
                              ; 3. Neither the name of the copyright holder nor the names of its
                              ;    contributors may be used to endorse or promote products derived from
                              ;    this software without specific prior written permission.
                              ;
                              ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                              ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                              ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                              ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                              ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                              ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                              ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                              ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                              ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                              ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                              ;                                                                          
                              ; ============================================================================
 
                              IO_PAGE         EQU $FFFE00000
                              ; Special Registers
                              BRKAD0          EQU     $FFFFFFF00
                              BRKAD1          EQU     $FFFFFFF04
                              BRKAD2          EQU     $FFFFFFF08
                              BRKAD3          EQU     $FFFFFFF0C
                              BRKCTRL0        EQU     $FFFFFFF10
                              BRKCTRL1        EQU     $FFFFFFF11
                              BRKCTRL2        EQU     $FFFFFFF12
                              BRKCTRL3        EQU     $FFFFFFF13
                              COREID  EQU             $FFFFFFF14
                              CHECKPT EQU             $FFFFFFF15
                              MMU_AKEY        EQU     $FFFFFFF16
                              MMU_OKEY        EQU     $FFFFFFF17
                              MSCOUNT EQU             $FFFFFFF18
 
                              LEDS            EQU             $FFFE60001
                              VIA_MMU EQU             $F306FF                 ; constant to map VIA into address space
                              VIA                     EQU             $FFFE60000
                              VIA_PA          EQU             1
                              VIA_DDRA        EQU             3
                              VIA_ACR                 EQU             11
                              VIA_IFR                 EQU             13
                              VIA_IER                 EQU             14
                              VIA_T3CL                EQU             16
                              VIA_T3CH                EQU             17
                              VIA_T3LL                EQU             18
                              VIA_T3LH                EQU             19
                              VIA_T3CMPL      EQU             20
                              VIA_T3CMPH      EQU             21
                              TEXTSCR         EQU             $FFFE00000
                              TEXTREG         EQU             $FFFE07F00
                              TEXT_COLS       EQU             0
                              TEXT_ROWS       EQU             1
                              TEXT_CURPOS     EQU             34
                              COLS            EQU             64
                              ROWS            EQU             32
                              ACIA_MMU        EQU     $F196FF         ; constant to map ACIA into address space
                              ACIA            EQU             $FFFE32000
                              ACIA_TX         EQU             0
                              ACIA_RX         EQU             0
                              ACIA_STAT       EQU             1
                              ACIA_CMD        EQU             2
                              ACIA_CTRL       EQU             3
                              ACIA_IRQS       EQU             4
                              ACIA_CTRL2      EQU             11
                              RTC                             EQU             $FFFE34000      ; I2C
                              RTCBuf          EQU             $7FC0
                              PRNG_MMU        EQU             $71B6FF
                              PRNG            EQU             $FFFE36000
                              KEYBD           EQU             $FFFE30000
                              KEYBDCLR        EQU             $FFFE30002
                              PIC_MMU EQU             $F1F6FF                         ; constant to map PIC into address space
                              PIC                     EQU             $FFFE3E000
                              SPRITE_MMU              EQU             $F086FF ; constant to map SPRITE into address space
                              SPRITE_CTRL             EQU             $FFFE10000
                              SPRITE_EN                       EQU             $3C0
                              MMU                     EQU             $FFFE38000
 
                              SEMA_MMU        EQU             $F786FF
                              OUTSEMA EQU     $FFFEF0000
                              SEMAABS EQU     $1000
                              OSSEMA  EQU     $FFFEF0010
 
                              OPC_SWI                         EQU             $03F
                              ScreenLocation          EQU             $10
                              ColorCodeLocation       EQU             $14
                              ScreenLocation2         EQU             $18
                              BlkcpySrc                       EQU             $1C
                              BlkcpyDst                       EQU             $20
                              Strptr                          EQU             $24
                              PICptr                          EQU             $28
                              ; Forth Area
                              ; 0x30-0x60
 
                              ; Task control blocks, room for 256 tasks
                              TCB_NxtRdy              EQU             $00     ; next task on ready / timeout list
                              TCB_PrvRdy              EQU             $04     ; previous task on ready / timeout list
                              TCB_NxtTCB              EQU             $08
                              TCB_Timeout             EQU             $0C
                              TCB_Priority    EQU             $10
                              TCB_MSGPTR_D1   EQU             $14
                              TCB_MSGPTR_D2   EQU             $18
                              TCB_hJCB                        EQU             $1C
                              TCB_Status              EQU             $1E
                              TCB_CursorRow   EQU             $20
                              TCB_CursorCol   EQU             $21
                              TCB_hWaitMbx    EQU             $22     ; handle of mailbox task is waiting at
                              TCB_mbq_next    EQU             $24     ; mailbox queue next
                              TCB_mbq_prev    EQU             $28     ; mailbox queue previous
                              TCB_iof_next    EQU             $2C
                              TCB_iof_prev    EQU             $30
                              TCB_SPSave              EQU             $34     ; TCB_SPSave area
                              TCB_mmu_map             EQU             $38
 
                              KeybdHead               EQU             $FFC800
                              KeybdTail               EQU             $FFC900
                              KeybdEcho               EQU             $FFCA00
                              KeybdBad                EQU             $FFCB00
                              KeybdAck                EQU             $FFCC00
                              KeybdLocks              EQU             $FFCD00
                              KeybdBuffer             EQU             $FFC000 ; buffer is 16 chars
 
                              BIOS_SCREENS    EQU     $17000000       ; $17000000 to $171FFFFF
 
                              ; EhBASIC vars:
                              ;
                              NmiBase         EQU             $FFC01E
                              IrqBase         EQU             $FFC01F
 
                              IOFocusNdx      EQU             $100
 
                              ; These variables in global OS storage area
 
                              IOFocusList     EQU             $FFC000 ; to $FF000F
                              IOFocusID               EQU             $FFC010
                              IrqSource               EQU             $FFC011
                              IRQFlag                 EQU             $FFC012
                              RunningID               EQU             $FFC013
                              milliseconds    EQU             $FFC014
 
                              ; One copy of serial buffer management
                              ; 1 serial buffer for system.
                              SerHeadRcv      EQU     $FFC018
                              SerTailRcv      EQU     $FFC019
                              SerHeadXmit     EQU     $FFC01A
                              SerTailXmit     EQU     $FFC01B
                              SerRcvXon               EQU     $FFC01C
                              SerRcvXoff      EQU     $FFC01D
                              SerRcvBuf               EQU     $FFB000 ; 4kB serial recieve buffer
 
                              ; Top of boot stack is at $FFC0FF
 
                              ; These variables use direct page access
                              CursorRow       EQU             $110
                              CursorCol       EQU             $111
                              CharColor       EQU             $112
                              ScreenColor     EQU             $113
                              CursorFlash     EQU             $114
                              KeyState1       EQU     $120
                              KeyState2       EQU     $121
                              KeyLED          EQU     $122
                              KeybdID         EQU     $124
                              KeybdBlock      EQU     $126
                              kbdHeadRcv      EQU     $127
                              kbdTailRcv      EQU     $128
                              kbdFifo                 EQU     $40                             ; in local RAM
                              kbdFifoAlias    EQU     $C00040 ; to $C0007F    ; alias for $40 to $7F
                              SerhZero                EQU     $130
                              SertZero                EQU     $132
 
 
                              farflag EQU             $15F
                              asmbuf  EQU             $160    ; to $17F
 
                              QNdx0           EQU             $780
                              QNdx1           EQU             QNdx0+2
                              QNdx2           EQU             QNdx1+2
                              QNdx3           EQU             QNdx2+2
                              QNdx4           EQU             QNdx3+2
                              FreeTCB         EQU             QNdx4+2
                              TimeoutList     EQU             FreeTCB+2
                              FreeMbx         EQU             RunningTCB + 2
                              nMailbox        EQU             FreeMbx + 2
                              FreeMsg         EQU             nMailbox + 2
                              nMsgBlk         EQU             FreeMsg + 2
 
 
                              CharOutVec      EQU             $800
                              CharInVec       EQU             $804
                              CmdPromptJI     EQU     $808
                              MonErrVec       EQU             $80C
                              BreakpointFlag  EQU             $810
                              NumSetBreakpoints       EQU     $811    ; to 812
                              Breakpoints                     EQU             $820    ; to $83F
                              BreakpointBytes EQU             $850    ; to $85F
                              mon_vectb                               EQU             $880
 
                              ; Register save area for monitor
                              mon_DSAVE       EQU             $900
                              mon_XSAVE       EQU             $902
                              mon_YSAVE       EQU             $904
                              mon_USAVE       EQU             $906
                              mon_SSAVE       EQU             $908
                              mon_PCSAVE      EQU             $90A
                              mon_DPRSAVE     EQU             $90E
                              mon_CCRSAVE     EQU             $90F
 
                              mon_numwka      EQU             $910
                              mon_r1          EQU             $920
                              mon_r2          EQU             $924
                              jmpvec          EQU             $928
                              mon_init        EQU             $92C
                              mon_retflag     EQU     $930
 
                              ; The ORG directive must set an address a multiple of 4 in order for the Verilog
                              ; output to work correctly.
 
                                      org             $FFFFFD0AC
 FFFFD0AC 012                             nop
 FFFFD0AD 012                             nop
 FFFFD0AE 012                             nop
                              XBLANK
 FFFFD0AF 0C6020                          ldb             #' '
 FFFFD0B1 017002159                       lbsr    OUTCH
 FFFFD0B4 039                             rts
 
                                      org             $FFFFFD0D0
 FFFFD0D0 012                             nop
 FFFFD0D1 012                             nop
                              CRLF
                              CRLF1:
 FFFFD0D2 0C600D                          ldb             #CR
 FFFFD0D4 017002136                       lbsr    OUTCH
 FFFFD0D7 0C600A                          ldb             #LF
 FFFFD0D9 017002131                       lbsr    OUTCH
 FFFFD0DC 039                             rts
 
                                      org             $FFFFFD0F0
 FFFFD0F0 012                             nop
 FFFFD0F1 020FDF                          bra             CRLF1
 
                                      org             $FFFFFD1DC
                              ONEKEY
 FFFFD1DC 06E90F000804                    jmp             [CharInVec]
 
                                      org             $FFFFFD2C0
 FFFFD2C0 012                             nop
                              LETTER
 FFFFD2C1 017001F49                       lbsr    OUTCH
 FFFFD2C4 039                             rts
 
                                      org             $FFFFFD2CC
 FFFFD2CC 012                             nop
 FFFFD2CD 012                             nop
                              HEX2
 FFFFD2CE 017001176                       lbsr    DispByteAsHex
 FFFFD2D1 039                             rts
                              HEX4
 FFFFD2D2 017001169                       lbsr    DispWordAsHex
 FFFFD2D5 039                             rts
 
                                      org             $FFFFFD300
                              ClearScreenJmp
 FFFFD300 016000F44                       lbra    ClearScreen
                                      org             $FFFFFD308
                              HomeCursorJmp
 FFFFD308 016000FB3                       lbra    HomeCursor
 
                                      org             $FFFFFD400
 
                              ; Local RAM test routine
                              ; Checkerboard testing.
                              ; There is 70kB of local RAM
                              ; Does not use any RAM including no stack
 
                              ramtest:
 FFFFD400 18E000000                       ldy             #0
 FFFFD403 086001                          lda             #1
 FFFFD405 0150B7FFFE60001                 sta             LEDS
 FFFFD40A 0CCAAA555                       ldd             #$AAA555
                              ramtest1:
 FFFFD40D 0EDA01                          std             ,y++
 FFFFD40F 18C008000                       cmpy    #$8000
 FFFFD412 025FF9                          blo             ramtest1
                                      ; now readback values and compare
 FFFFD414 18E000000                       ldy             #0
                              ramtest3:
 FFFFD417 0ECA01                          ldd             ,y++
 FFFFD419 183AAA555                       cmpd    #$AAA555
 FFFFD41C 02600E                          bne             ramerr
 FFFFD41E 18C008000                       cmpy    #$8000
 FFFFD421 025FF4                          blo             ramtest3
 FFFFD423 086002                          lda             #2
 FFFFD425 0150B7FFFE60001                 sta             LEDS
 FFFFD42A 06EC04                          jmp             ,u
                              ramerr:
 FFFFD42C 086080                          lda             #$80
 FFFFD42E 0150B7FFFE60001                 sta             LEDS
 FFFFD433 0150F6FFFFFFF14                 ldb             COREID
 FFFFD438 0C1020                          cmpb    #$20
 FFFFD43A 027009                          beq             ramerr1
 FFFFD43C 08EE00000                       ldx             #TEXTSCR
 FFFFD43F 03A                             abx
 FFFFD440 086046                          lda             #'F'
 FFFFD442 0A7804                          sta             ,x
 FFFFD444 013                             sync
                              ramerr1:
 FFFFD445 06EC04                          jmp             ,u
 
                              BCDArith:
 FFFFD447 0170020A3                       lbsr    ignBlanks
 FFFFD44A 017002121                       lbsr    GetHexNumber
 FFFFD44D 0FC000912                       ldd             mon_numwka+2
 FFFFD450 0FD000922                       std             mon_r1+2
 FFFFD453 017002097                       lbsr    ignBlanks
 FFFFD456 017002077                       lbsr    MonGetch
 FFFFD459 0F7000920                       stb             mon_r1
 FFFFD45C 01700208E                       lbsr    ignblanks
 FFFFD45F 01700210C                       lbsr    GetHexNumber
 FFFFD462 0FC000912                       ldd             mon_numwka+2
 FFFFD465 0FD000926                       std             mon_r2+2
 FFFFD468 017FFFC67                       lbsr    CRLF
*** warning 1: Long branch within short branch range could be optimized
 FFFFD46B 0F6000920                       ldb             mon_r1
 FFFFD46E 0C102B                          cmpb    #'+'
 FFFFD470 02700B                          beq             bcdDoAdd
 FFFFD472 0C102D                          cmpb    #'-'
 FFFFD474 02701A                          beq             bcdDoSub
 FFFFD476 0C102A                          cmpb    #'*'
 FFFFD478 027029                          beq             bcdDoMul
 FFFFD47A 0160021D8                       lbra    DisplayErr
                              bcdDoAdd:
 FFFFD47D 01A100                          orcc    #$100
 FFFFD47F 0FC000922                       ldd             mon_r1+2
 FFFFD482 0F3000926                       addd    mon_r2+2
 FFFFD485 01CEFF                          andcc   #$EFF
 FFFFD487 017000FB4                       lbsr    DispWordAsHex
 FFFFD48A 017FFFC45                       lbsr    CRLF
*** warning 1: Long branch within short branch range could be optimized
 FFFFD48D 016001F32                       lbra    Monitor
                              bcdDoSub:
 FFFFD490 01A100                          orcc    #$100
 FFFFD492 0FC000922                       ldd             mon_r1+2
 FFFFD495 0B3000926                       subd    mon_r2+2
 FFFFD498 01CEFF                          andcc   #$EFF
 FFFFD49A 017000FA1                       lbsr    DispWordAsHex
 FFFFD49D 017FFFC32                       lbsr    CRLF
*** warning 1: Long branch within short branch range could be optimized
 FFFFD4A0 016001F1F                       lbra    Monitor
                              bcdDoMul:
 FFFFD4A3 01A100                          orcc    #$100
 FFFFD4A5 0B6000923                       lda             mon_r1+3
 FFFFD4A8 0F6000927                       ldb             mon_r2+3
 FFFFD4AB 03D                             mul
 FFFFD4AC 01CEFF                          andcc   #$EFF
 FFFFD4AE 017000F8D                       lbsr    DispWordAsHex
 FFFFD4B1 017FFFC1E                       lbsr    CRLF
*** warning 1: Long branch within short branch range could be optimized
 FFFFD4B4 016001F0B                       lbra    Monitor
 
                              ;------------------------------------------------------------------------------
                              ; Set MAP #0 up as a linear memory map
                              ; - semaphore memory is mapped
                              ; - ROMs are mapped
                              ; - The text screen memory is mapped.
                              ;------------------------------------------------------------------------------
 
                              InitMMU:
 FFFFD4B7 05F                             clrb
 FFFFD4B8 0150F7FFFFFFF16                 stb             MMU_AKEY
 FFFFD4BD 08E000000                       ldx             #0
 FFFFD4C0 0CCF00000                       ldd             #$F00000        ; CRWX=1111
 FFFFD4C3 24F                             clre
                              immu1:
 FFFFD4C4 0E7809E38000                    stb             MMU,x
 FFFFD4C8 0A7809E38001                    sta             MMU+1,x
 FFFFD4CC 030002                          leax    2,x
 FFFFD4CE 05C                             incb
 FFFFD4CF 24C                             ince
 FFFFD4D0 281800                          cmpe    #2048                   ; number of entries to update
 FFFFD4D2 025FF0                          blo             immu1
                                      ; Map the MMU table into the address space.
                                      ; (requires only 1 page)
 FFFFD4D4 08E000E38                       ldx             #$E38                   ; E38000 = page 71C * 2 bytes per record
 FFFFD4D7 0CCF1C6FF                       ldd             #$F1C6FF        ; high order bits are all ones, plus CRWX=0110
 FFFFD4DA 0ED809E38000                    std             MMU,x
                                      ; Map semaphore memory into address space.
 FFFFD4DE 08E000EF0                       ldx             #$EF0
 FFFFD4E1 0CCF786FF                       ldd             #SEMA_MMU
 FFFFD4E4 0ED809E38000                    std             MMU,x
                                      ; Map LEDs (VIA) into address space
 FFFFD4E8 08E000E60                       ldx             #$E60
 FFFFD4EB 0CCF306FF                       ldd             #VIA_MMU
 FFFFD4EE 0ED809E38000                    std             MMU,x
                                      ; Map ROMs into address space
 FFFFD4F2 08E000F00                       ldx             #$F00
 FFFFD4F5 086F80                          lda             #$F80
 FFFFD4F7 0C6DFF                          ldb             #$DFF                   ; D=cachable, readable, executable
 FFFFD4F9 24F                             clre
                              immu2:
 FFFFD4FA 0A7809E38000                    sta             MMU,x
 FFFFD4FE 0E7809E38001                    stb             MMU+1,x
 FFFFD502 030002                          leax    2,x
 FFFFD504 04C                             inca
 FFFFD505 24C                             ince
 FFFFD506 281080                          cmpe    #128
 FFFFD508 025FF0                          blo             immu2
                                      ; Map Text Screen
 FFFFD50A 08E000E00                       ldx             #$E00
 FFFFD50D 086F00                          lda             #$F00
 FFFFD50F 0C66FF                          ldb             #$6FF                   ; 6 = readable, writable
 FFFFD511 24F                             clre                                            ; e = 0
                              immu3:
 FFFFD512 0A7809E38000                    sta             MMU,x
 FFFFD516 0E7809E38001                    stb             MMU+1,x
 FFFFD51A 030002                          leax    2,x
 FFFFD51C 04C                             inca
 FFFFD51D 24C                             ince
 FFFFD51E 281080                          cmpe    #128
 FFFFD520 025FF0                          blo             immu3
 
 FFFFD522 0C6800                          ldb             #$800
 FFFFD524 0150F7FFFFFFF17                 stb             MMU_OKEY        ; turn on mapping
 FFFFD529 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                                      org             $FFFFFE000
 FFFFE000 FFF3C2                          FDB Monitor
 FFFFE002 FFE022                          FDB DumRts      ;       NEXTCMD
 FFFFE004 FFF1D7                          FDB INCH
 FFFFE006 FFF1F5                          FDB INCHE
 FFFFE008 FFF1F9                          FDB INCHEK
 FFFFE00A FFF20D                          FDB OUTCH
 FFFFE00C FFE42B                          FDB PDATA
 FFFFE00E FFE41E                          FDB PCRLF
 FFFFE010 FFE41A                          FDB PSTRNG
 FFFFE012 FFE022                          FDB DumRts                      ; LRA
 FFFFE014 FFE022                          FDB DumRts
 FFFFE016 FFE022                          FDB DumRts
 FFFFE018 FFE022                          FDB DumRts
 FFFFE01A FFE022                          FDB DumRts                      ; VINIZ
 FFFFE01C FFE325                          FDB DisplayChar ;       VOUTCH
 FFFFE01E FFE022                          FDB DumRts                      ; ACINIZ
 FFFFE020 FFE022                          FDB DumRts                      ; AOUTCH
 
                              DumRts:
 FFFFE022 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
 
                              start:
 FFFFE023 23D007                          ldmd    #7                              ; switch to native mode, firq stacks all, and ipl
 FFFFE025 086FFF                          lda             #$FFF                   ; all cores can do this
 FFFFE027 0150B7FFFE60003                 sta             VIA+VIA_DDRA
 FFFFE02C 086055                          lda             #$55                    ; see if we can at least set LEDs
 FFFFE02E 0150B7FFFE60001                 sta             LEDS
 FFFFE033 086001                          lda             #1                              ; prime OS semaphore
 FFFFE035 0150B7FFFEF1010                 sta             OSSEMA+$1000
 FFFFE03A 0150B7FFFEF1000                 sta             OUTSEMA+$1000
 FFFFE03F 0CEFFE042                       ldu             #st6                    ; U = return address
                              ;       jmp             ramtest         ; JMP dont JSR
                              st6:
 FFFFE042 1CE006FFF                       lds             #$6FFF          ; boot up stack area
 FFFFE045 0150B6FFFFFFF14                 lda             COREID
 FFFFE04A 081001                          cmpa    #FIRST_CORE
                              ;       beq             st8
                              ;       sync                                            ; halt cores other than 2
                              st8:
                              ;       bne             skip_init
                              ;       bsr             romToRam
                              ;       ldd             #st7 & $FFFF
                              ;       tfr             d,x
                              ;       jmp             ,x                              ; jump to the BIOS now in local RAM
                              st7:
 FFFFE04C 017FFF468                       lbsr    InitMMU
*** warning 1: Long branch within short branch range could be optimized
 FFFFE04F 08D172                          bsr             Delay3s         ; give some time for devices to reset
 FFFFE051 07F000810                       clr             BreakpointFlag
 FFFFE054 07F000811                       clr             NumSetBreakpoints
 FFFFE057 0860AA                          lda             #$AA
 FFFFE059 0150B7FFFE60001                 sta             LEDS
 FFFFE05E 0150B6FFFFFFF14                 lda             COREID
 FFFFE063 081020                          cmpa    #$20
 FFFFE065 027002                          beq             st11
 FFFFE067 086001                          lda             #FIRST_CORE
                              st11:
 FFFFE069 0B7FFC010                       sta             IOFocusID       ; core #2 has focus
 FFFFE06C 0B7FFC013                       sta             RunningID
                                      ; Clear IO focus list
 FFFFE06F 08E000000                       ldx             #0
                              st9:
 FFFFE072 06F80A000FFC000                 clr             IOFocusList,x
 FFFFE077 030001                          inx
 FFFFE079 08C000010                       cmpx    #16
 FFFFE07C 025FF4                          blo             st9
 FFFFE07E 086018                          lda             #24
 FFFFE080 0B7FFC001                       sta             IOFocusList+FIRST_CORE
 
 FFFFE083 0860CE                          lda             #$0CE
 FFFFE085 097113                          sta             ScreenColor
 FFFFE087 097112                          sta             CharColor
 FFFFE089 08D1BC                          bsr             ClearScreen
 FFFFE08B 0CCFFE325                       ldd             #DisplayChar
 FFFFE08E 0FD000800                       std             CharOutVec
 FFFFE091 0CCFFEC8F                       ldd             #SerialPeekCharDirect
 FFFFE094 0FD000804                       std             CharInVec
                              ;       swi
                              ;       fcb             MF_OSCALL
                              ;       fcb             24                                      ; request IO focus
 FFFFE097 0150F6FFFFFFF14                 ldb             COREID
 FFFFE09C 0C1001                          cmpb    #FIRST_CORE
 FFFFE09E 027011                          beq             init
 FFFFE0A0 0C1020                          cmpb    #$20                            ; CmodA709 core?
 FFFFE0A2 027060                          beq             init2
 FFFFE0A4 020072                          bra             skip_init
 FFFFE0A6 0200B9                          bra             multi_sieve
                              st3:
 FFFFE0A8 0860FF                          lda             #$FF
 FFFFE0AA 0150B7FFFE60001                 sta             LEDS
 FFFFE0AF 020FF7                          bra             st3
 
                                      ; initialize interrupt controller
                                      ; first, zero out all the vectors
                              init:
                              ;       lbsr    rtc_read        ; get clock values
 FFFFE0B1 08E000127                       ldx             #kbdHeadRcv
 FFFFE0B4 0C6020                          ldb             #32                             ; number of bytes to zero out
                              init1:
 FFFFE0B6 06F800                          clr             ,x+
 FFFFE0B8 05A                             decb
 FFFFE0B9 026FFB                          bne             init1
 FFFFE0BB 08E000080                       ldx             #128                    ; register to start at
 FFFFE0BE 01A010                          sei
 FFFFE0C0 0CCF1F6FF                       ldd             #PIC_MMU
 FFFFE0C3 0150FDFFFE38000                 std             MMU
                              st1:
 FFFFE0C8 06F804                          clr             ,x                              ; cause code
 FFFFE0CA 0A7001                          sta             1,x
 FFFFE0CC 0E7002                          stb             2,x
 FFFFE0CE 030004                          leax    4,x
 FFFFE0D0 08C000100                       cmpx    #256                    ; max reg
 FFFFE0D3 025FF3                          blo             st1
 FFFFE0D5 0860C1                          lda             #$C1                    ; make irq edge sensitive (bit 7), enable interupt (bit 6), irq (bit 0)
 FFFFE0D7 0970FD                          sta             $FD
 FFFFE0D9 086041                          lda             #$41                    ; level sensitive, enabled, irq
 FFFFE0DB 0970D1                          sta             $D1                             ; serial irq is #20
 FFFFE0DD 0CC000F00                       ldd             #$000F00
 FFFFE0E0 0150FDFFFE38000                 std             MMU
 FFFFE0E5 086040                          lda             #COLS
 FFFFE0E7 0150B7FFFE07F00                 sta             TEXTREG+TEXT_COLS
 FFFFE0EC 086020                          lda             #ROWS
 FFFFE0EE 0150B7FFFE07F01                 sta             TEXTREG+TEXT_ROWS
 FFFFE0F3 08D152                          bsr             ClearScreen
 FFFFE0F5 08D1C7                          bsr             HomeCursor
 FFFFE0F7 08E000000                       ldx             #0
 FFFFE0FA 0CC000000                       ldd             #0
 FFFFE0FD 017001115                       lbsr    ShowSprites
                              ;       lbsr    KeybdInit
 FFFFE100 0DC124                          ldd             KeybdID
 FFFFE102 08D33A                          bsr             DispWordAsHex
                              init2:
 FFFFE104 01700036E                       lbsr    TimerInit
 FFFFE107 017000AE5                       lbsr    InitSerial
 FFFFE10A 08E000080                       ldx             #128
 FFFFE10D 086001                          lda             #1                      ; set irq(bit0), clear firq (bit1), disable int (bit 6), clear edge sense(bit 7)
 FFFFE10F 0C6001                          ldb             #FIRST_CORE                     ; serving core id
                              ;       lda             #4                              ; make the timer interrupt edge sensitive
                              ;       sta             PIC+4                   ; reg #4 is the edge sensitivity setting
                              ;       sta             PIC                             ; reg #0 is interrupt enable
 FFFFE111 0C6001                          ldb             #1
 FFFFE113 0150F7FFFEF1000                 stb             OUTSEMA+SEMAABS ; set semaphore to 1 available slot
                              skip_init:
 FFFFE118 01C0EF                          andcc   #$EF                    ; unmask irq
 FFFFE11A 086005                          lda             #5
 FFFFE11C 0150B7FFFE60001                 sta             LEDS
 FFFFE121 0CCFFE12A                       ldd             #msgStartup
 FFFFE124 08D2C0                          bsr             DisplayString
                              st10:
 FFFFE126 03F                             swi
 FFFFE127 000                             fcb             MF_Monitor
 FFFFE128 020FFC                          bra             st10
 
                              msgStartup
 FFFFE12A 072066036038030039020           fcb             "rf6809 12-bit System Starting.",CR,LF,0
 FFFFE131 03103202D062069074020
 FFFFE138 05307907307406506D020
 FFFFE13F 05307406107207406906E
 FFFFE146 06702E00D00A000
 
                              ;------------------------------------------------------------------------------
                              ; The checkpoint register must be cleared within 1 second or a NMI interrupt
                              ; will occur. checkpoint should be called with a JSR so that the global ROM
                              ; routine is called.
                              ;
                              ; Modifies:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              checkpoint:
 FFFFE14B 01507FFFFFFFFE1                 clr             $FFFFFFFE1      ; writing any value will do
 FFFFE150 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Copy the system ROM to local RAM
                              ; Running the code from local RAM is probably an order of magnitude faster
                              ; then running from the global ROM. It also reduces the network traffic to
                              ; run from local RAM.
                              ;
                              ; Modifies:
                              ;               d,x,y
                              ;------------------------------------------------------------------------------
 
                              romToRam:
 FFFFE151 08EFFC000                       ldx             #$FFC000
 FFFFE154 18E00C000                       ldy             #$00C000
                              romToRam1:
 FFFFE157 0EC801                          ldd             ,x++
 FFFFE159 0EDA01                          std             ,y++
 FFFFE15B 08C000000                       cmpx    #0
 FFFFE15E 026FF7                          bne             romToRam1
 FFFFE160 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Multi-core sieve program.
                              ;------------------------------------------------------------------------------
 
                              ; First fill screen chars with 'P' indicating prime positions
                              ; Each core is responsible for the Nth position where N is the
                              ; core number minus two.
                              ;
                              multi_sieve:
 FFFFE161 086050                          lda             #'P'                                    ; indicate prime
 FFFFE163 0150F6FFFFFFF14                 ldb             COREID                          ; find out which core we are
 FFFFE168 0C0001                          subb    #FIRST_CORE
 FFFFE16A 08E000000                       ldx             #0                                              ; start at first char of screen
 FFFFE16D 03A                             abx
                              multi_sieve3:
 FFFFE16E 0A7809E00000                    sta             TEXTSCR,x                       ; store 'P'
 FFFFE172 030008                          leax    8,x                                             ; advance to next position
 FFFFE174 08C000FFF                       cmpx    #4095
 FFFFE177 025FF5                          blo             multi_sieve3
 FFFFE179 0BDFFE14B                       jsr             checkpoint
*** warning 1: Long branch within short branch range could be optimized
 FFFFE17C 0CB002                          addb    #2                                              ; start sieve at 2 (core id)
 FFFFE17E 08604E                          lda             #'N'                                    ; flag position value of 'N' for non-prime
                              multi_sieve2:
 FFFFE180 08E000000                       ldx             #0
 FFFFE183 03A                             abx                                                                     ; skip the first position - might be prime
                              multi_sieve1:
 FFFFE184 03A                             abx                                                                     ; increment
 FFFFE185 0A7809E00000                    sta             TEXTSCR,x
 FFFFE189 08C000FFF                       cmpx    #4095
 FFFFE18C 025FF6                          blo             multi_sieve1
 FFFFE18E 0BDFFE14B                       jsr             checkpoint
*** warning 1: Long branch within short branch range could be optimized
 FFFFE191 0CB008                          addb    #8                                              ; number of cores working on it
 FFFFE193 0C1FF0                          cmpb    #4080
 FFFFE195 025FE9                          blo             multi_sieve2
                              multi_sieve4:                                   ; hang machine
 FFFFE197 013                             sync
 FFFFE198 016001227                       lbra    Monitor
 
                              ;------------------------------------------------------------------------------
                              ; Single core sieve.
                              ;------------------------------------------------------------------------------
 
                              sieve:
 FFFFE19B 086050                          lda             #'P'                                    ; indicate prime
 FFFFE19D 08E000000                       ldx             #0                                              ; start at first char of screen
                              sieve3:
 FFFFE1A0 0A7809E00000                    sta             TEXTSCR,x                       ; store 'P'
 FFFFE1A4 030001                          inx                                                                     ; advance to next position
 FFFFE1A6 08C000FFF                       cmpx    #4095
 FFFFE1A9 025FF5                          blo             sieve3
 FFFFE1AB 0C6002                          ldb             #2                                              ; start sieve at 2
 FFFFE1AD 08604E                          lda             #'N'                                    ; flag position value of 'N' for non-prime
                              sieve2:
 FFFFE1AF 08E000000                       ldx             #0
 FFFFE1B2 03A                             abx                                                                     ; skip the first position - might be prime
                              sieve1:
 FFFFE1B3 03A                             abx                                                                     ; increment
 FFFFE1B4 0A7809E00000                    sta             TEXTSCR,x
 FFFFE1B8 08C000FFF                       cmpx    #4095
 FFFFE1BB 025FC7                          blo             multi_sieve1
 FFFFE1BD 05C                             incb                                                            ; number of cores working on it
 FFFFE1BE 0C1FF0                          cmpb    #4080
 FFFFE1C0 025FED                          blo             sieve2
                              sieve4:                                                         ; hang machine
 FFFFE1C2 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Three second delay for user convenience and to allow some devices time to
                              ; reset.
                              ;------------------------------------------------------------------------------
 
                              Delay3s:
 FFFFE1C3 0CC895440                       ldd             #9000000
                              dly3s1:
 FFFFE1C6 0C10FF                          cmpb    #$FF
 FFFFE1C8 026000                          bne             dly3s2
                              dly3s2:
 FFFFE1CA 0150B7FFFE60001                 sta             LEDS
 FFFFE1CF 083000001                       subd    #1
 FFFFE1D2 026FF2                          bne             dly3s1
 FFFFE1D4 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              ShiftLeft5:
 FFFFE1D5 058                             aslb
 FFFFE1D6 049                             rola
 FFFFE1D7 058                             aslb
 FFFFE1D8 049                             rola
 FFFFE1D9 058                             aslb
 FFFFE1DA 049                             rola
 FFFFE1DB 058                             aslb
 FFFFE1DC 049                             rola
 FFFFE1DD 058                             aslb
 FFFFE1DE 049                             rola
 FFFFE1DF 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Parameters:
                              ;               b = core id of core to copy
                              ;------------------------------------------------------------------------------
                              ;
                              CopyVirtualScreenToScreen:
 FFFFE1E0 034076                          pshs    d,x,y,u
                                      ; Compute virtual screen location for core passed in accb.
 FFFFE1E2 01F098                          tfr             b,a
 FFFFE1E4 048                             asla
 FFFFE1E5 048                             asla
 FFFFE1E6 048                             asla
 FFFFE1E7 048                             asla
 FFFFE1E8 08AC00                          ora             #$C00
 FFFFE1EA 05F                             clrb
 FFFFE1EB 01F001                          tfr             d,x
 FFFFE1ED 034006                          pshs    d
 FFFFE1EF 18EE00000                       ldy             #TEXTSCR
 FFFFE1F2 0CE000400                       ldu             #COLS*ROWS/2
                              cv2s1:
 FFFFE1F5 0EC801                          ldd             ,x++
 FFFFE1F7 0EDA01                          std             ,y++
 FFFFE1F9 0335FF                          leau    -1,u
 FFFFE1FB 283000000                       cmpu    #0
 FFFFE1FE 026FF5                          bne             cv2s1
                                      ; reset the cursor position in the text controller
 FFFFE200 035010                          puls    x
 FFFFE202 0E6808110                       ldb             CursorRow,x
 FFFFE205 086040                          lda             #COLS
 FFFFE207 03D                             mul
 FFFFE208 01F002                          tfr             d,y
 FFFFE20A 0E6808111                       ldb             CursorCol,x
 FFFFE20D 01F021                          tfr             y,x
 FFFFE20F 03A                             abx
 FFFFE210 0150BFFFFE07F22                 stx             TEXTREG+TEXT_CURPOS
 FFFFE215 0350F6                          puls    d,x,y,u,pc
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              ;
                              CopyScreenToVirtualScreen:
 FFFFE217 034076                          pshs    d,x,y,u
 FFFFE219 08D08D                          bsr             GetScreenLocation
 FFFFE21B 01F002                          tfr             d,y
 FFFFE21D 08EE00000                       ldx             #TEXTSCR
 FFFFE220 0CE000400                       ldu             #COLS*ROWS/2
                              cs2v1:
 FFFFE223 0EC801                          ldd             ,x++
 FFFFE225 0EDA01                          std             ,y++
 FFFFE227 0335FF                          leau    -1,u
 FFFFE229 283000000                       cmpu    #0
 FFFFE22C 026FF5                          bne             cs2v1
 FFFFE22E 0350F6                          puls    d,x,y,u,pc
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
 FFFFE230 054045058054053043052           fcb             "TEXTSCR "
 FFFFE237 020
 FFFFE238 FFE242                          fcw             TextOpen
 FFFFE23A FFE243                          fcw             TextClose
 FFFFE23C FFE244                          fcw             TextRead
 FFFFE23E FFE245                          fcw             TextWrite
 FFFFE240 FFE246                          fcw             TextSeek
 
                              TextOpen:
 FFFFE242 039                             rts
                              TextClose:
 FFFFE243 039                             rts
                              TextRead:
 FFFFE244 039                             rts
                              TextWrite:
 FFFFE245 039                             rts
                              TextSeek:
 FFFFE246 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Clear the screen and the screen color memory
                              ; We clear the screen to give a visual indication that the system
                              ; is working at all.
                              ;
                              ; Modifies:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              ClearScreen:
 FFFFE247 034076                          pshs    d,x,y,u
 FFFFE249 08E000800                       ldx             #COLS*ROWS
 FFFFE24C 01F013                          tfr             x,u
 FFFFE24E 08D058                          bsr             GetScreenLocation
 FFFFE250 01F002                          tfr             d,y
 FFFFE252 0C6020                          ldb             #' '                            ; space char
                              cs1:
 FFFFE254 0E7A00                          stb             ,y+                                     ; set text to space
 FFFFE256 0301FF                          dex                                                             ; decrement x
 FFFFE258 026FFA                          bne             cs1
 FFFFE25A 0150F6FFFFFFF14                 ldb             COREID                  ; update colors only if we have focus
 FFFFE25F 0F1FFC010                       cmpb    IOFocusID
 FFFFE262 02000D                          bra             cs3
 FFFFE264 18EE02000                       ldy             #TEXTSCR+$2000
                              ;       lda             CharColor
 FFFFE267 0860CE                          lda             #$0CE
 FFFFE269 01F031                          tfr             u,x                                     ; get back count
                              cs2:
 FFFFE26B 0A7A00                          sta             ,y+
 FFFFE26D 0301FF                          dex                                                             ; decrement x
 FFFFE26F 026FFA                          bne             cs2
                              cs3:
 FFFFE271 0350F6                          puls    d,x,y,u,pc
 
                              ;------------------------------------------------------------------------------
                              ; Scroll text on the screen upwards
                              ;
                              ; Modifies:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              ScrollUp:
 FFFFE273 034076                          pshs    d,x,y,u
 FFFFE275 18E0003FF                       ldy             #(COLS*ROWS-1)/2        ; y = num chars/2 to move
 FFFFE278 08D02E                          bsr             GetScreenLocation
 FFFFE27A 01F001                          tfr             d,x
 FFFFE27C 01F003                          tfr             d,u
 FFFFE27E 030040                          leax    COLS,x          ; x = index to source row
                              scrup1:
 FFFFE280 0EC801                          ldd             ,x++                    ; move 2 characters
 FFFFE282 0EDC01                          std             ,u++
 FFFFE284 0313FF                          dey
 FFFFE286 026FF8                          bne             scrup1
 FFFFE288 08601F                          lda             #ROWS-1
 FFFFE28A 08D002                          bsr             BlankLine
 FFFFE28C 0350F6                          puls    d,x,y,u,pc
 
                              ;------------------------------------------------------------------------------
                              ; Blank out a line on the display
                              ;
                              ; Modifies:
                              ;               none
                              ; Parameters:
                              ;       acca = line number to blank
                              ;------------------------------------------------------------------------------
 
                              BlankLine:
 FFFFE28E 034016                          pshs    d,x
 FFFFE290 034002                          pshs    a
 FFFFE292 08D014                          bsr             GetScreenLocation
 FFFFE294 01F001                          tfr             d,x
 FFFFE296 035002                          puls    a
 FFFFE298 0C6040                          ldb             #COLS   ; b = # chars to blank out from video controller
 FFFFE29A 03D                             mul                                     ; d = screen index (row# * #cols)
 FFFFE29B 03080B                          leax    d,x
 FFFFE29D 086020                          lda             #' '
 FFFFE29F 0C6040                          ldb             #COLS   ; b = # chars to blank out from video controller
                              blnkln1:
 FFFFE2A1 0A7800                          sta             ,x+
 FFFFE2A3 05A                             decb
 FFFFE2A4 026FFB                          bne             blnkln1
 FFFFE2A6 035096                          puls    d,x,pc
 
                              ;------------------------------------------------------------------------------
                              ; Get the location of the screen memory. The location
                              ; depends on whether or not the task has the output focus.
                              ;
                              ; Modifies:
                              ;               d
                              ; Retuns:
                              ;               d = screen location
                              ;------------------------------------------------------------------------------
 
                              GetScreenLocation:
 FFFFE2A8 0150B6FFFFFFF14                 lda             COREID                  ; which core are we?
 FFFFE2AD 0B1FFC010                       cmpa    IOFocusID               ; do we have the IO focus
 FFFFE2B0 026008                          bne             gsl1                            ; no, go pick virtual screen address
 FFFFE2B2 081020                          cmpa    #$20                            ; CmodA709?
 FFFFE2B4 027004                          beq             gsl1
 FFFFE2B6 0CCE00000                       ldd             #TEXTSCR                ; yes, we update the real screen
 FFFFE2B9 039                             rts
                              gsl1:
 FFFFE2BA 0CC007800                       ldd             #$7800
 FFFFE2BD 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; HomeCursor
                              ; Set the cursor location to the top left of the screen.
                              ;
                              ; Modifies:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              HomeCursor:
 FFFFE2BE 034016                          pshs    d,x
 FFFFE2C0 00F110                          clr             CursorRow
 FFFFE2C2 00F111                          clr             CursorCol
 FFFFE2C4 0150F6FFFFFFF14                 ldb             COREID
 FFFFE2C9 0F1FFC010                       cmpb    IOFocusID
 FFFFE2CC 02600A                          bne             hc1
 FFFFE2CE 0C1020                          cmpb    #$20
 FFFFE2D0 027006                          beq             hc1
 FFFFE2D2 04F                             clra
 FFFFE2D3 0150B7FFFE07F22                 sta             TEXTREG+TEXT_CURPOS
                              hc1:
 FFFFE2D8 035096                          puls    d,x,pc
 
                              ;------------------------------------------------------------------------------
                              ; Update the cursor position in the text controller based on the
                              ;  CursorRow,CursorCol.
                              ;
                              ; Modifies:
                              ;               none
                              ;------------------------------------------------------------------------------
                              ;
                              UpdateCursorPos:
 FFFFE2DA 034016                          pshs    d,x
 FFFFE2DC 0150F6FFFFFFF14                 ldb             COREID                          ; update cursor position in text controller
 FFFFE2E1 0F1FFC010                       cmpb    IOFocusID                       ; only for the task with the output focus
 FFFFE2E4 026018                          bne             ucp1
 FFFFE2E6 0C1020                          cmpb    #$20                                    ; and not for CmodA709
 FFFFE2E8 027014                          beq             ucp1                                    
 FFFFE2EA 096110                          lda             CursorRow
 FFFFE2EC 08403F                          anda    #$3F                                    ; limit of 63 rows
 FFFFE2EE 0150F6FFFE07F00                 ldb             TEXTREG+TEXT_COLS
 FFFFE2F3 03D                             mul
 FFFFE2F4 01F001                          tfr             d,x
 FFFFE2F6 0D6111                          ldb             CursorCol
 FFFFE2F8 03A                             abx
 FFFFE2F9 0150BFFFFE07F22                 stx             TEXTREG+TEXT_CURPOS
                              ucp1:
 FFFFE2FE 035096                          puls    d,x,pc
 
                              ;------------------------------------------------------------------------------
                              ; Calculate screen memory location from CursorRow,CursorCol.
                              ; Also refreshes the cursor location.
                              ;
                              ; Modifies:
                              ;               d
                              ; Returns:
                              ;       d = screen location
                              ;------------------------------------------------------------------------------
                              ;
                              CalcScreenLoc:
 FFFFE300 034010                          pshs    x
 FFFFE302 096110                          lda             CursorRow
 FFFFE304 0C6040                          ldb             #COLS
 FFFFE306 03D                             mul
 FFFFE307 01F001                          tfr             d,x
 FFFFE309 0D6111                          ldb             CursorCol
 FFFFE30B 03A                             abx
 FFFFE30C 0150F6FFFFFFF14                 ldb             COREID                          ; update cursor position in text controller
 FFFFE311 0F1FFC010                       cmpb    IOFocusID                       ; only for the task with the output focus
 FFFFE314 026009                          bne             csl1                                    
 FFFFE316 0C1020                          cmpb    #$20
 FFFFE318 027005                          beq             csl1
 FFFFE31A 0150BFFFFE07F22                 stx             TEXTREG+TEXT_CURPOS
                              csl1:
 FFFFE31F 08DF87                          bsr             GetScreenLocation
 FFFFE321 130010                          addr    x,d
 FFFFE323 035090                          puls    x,pc
 
                              ;------------------------------------------------------------------------------
                              ; Display a character on the screen.
                              ; If the task doesn't have the I/O focus then the character is written to
                              ; the virtual screen.
                              ;
                              ; Modifies:
                              ;               none
                              ; Parameters:
                              ;       accb = char to display
                              ;------------------------------------------------------------------------------
                              ;
                              DisplayChar:
 FFFFE325 0170009A8                       lbsr    SerialPutChar
                              ScreenDisplayChar:
 FFFFE328 034016                          pshs    d,x
 FFFFE32A 0C100D                          cmpb    #CR                                     ; carriage return ?
 FFFFE32C 026007                          bne             dccr
 FFFFE32E 00F111                          clr             CursorCol               ; just set cursor column to zero on a CR
 FFFFE330 08DFA8                          bsr             UpdateCursorPos
                              dcx14:
 FFFFE332 01600008C                       lbra            dcx4
                              dccr:
 FFFFE335 0C1091                          cmpb    #$91                            ; cursor right ?
 FFFFE337 02600D                          bne             dcx6
 FFFFE339 096111                          lda             CursorCol
 FFFFE33B 081040                          cmpa    #COLS
 FFFFE33D 024003                          bhs             dcx7
 FFFFE33F 04C                             inca
 FFFFE340 097111                          sta             CursorCol
                              dcx7:
 FFFFE342 08DF96                          bsr             UpdateCursorPos
 FFFFE344 035096                          puls    d,x,pc
                              dcx6:
 FFFFE346 0C1090                          cmpb    #$90                            ; cursor up ?
 FFFFE348 026009                          bne             dcx8            
 FFFFE34A 096110                          lda             CursorRow
 FFFFE34C 027FF4                          beq             dcx7
 FFFFE34E 04A                             deca
 FFFFE34F 097110                          sta             CursorRow
 FFFFE351 020FEF                          bra             dcx7
                              dcx8:
 FFFFE353 0C1093                          cmpb    #$93                            ; cursor left ?
 FFFFE355 026009                          bne             dcx9
 FFFFE357 096111                          lda             CursorCol
 FFFFE359 027FE7                          beq             dcx7
 FFFFE35B 04A                             deca
 FFFFE35C 097111                          sta             CursorCol
 FFFFE35E 020FE2                          bra             dcx7
                              dcx9:
 FFFFE360 0C1092                          cmpb    #$92                            ; cursor down ?
 FFFFE362 02600B                          bne             dcx10
 FFFFE364 096110                          lda             CursorRow
 FFFFE366 081020                          cmpa    #ROWS
 FFFFE368 027FD8                          beq             dcx7
 FFFFE36A 04C                             inca
 FFFFE36B 097110                          sta             CursorRow
 FFFFE36D 020FD3                          bra             dcx7
                              dcx10:
 FFFFE36F 0C1094                          cmpb    #$94                            ; cursor home ?
 FFFFE371 02600C                          bne             dcx11
 FFFFE373 096111                          lda             CursorCol
 FFFFE375 027004                          beq             dcx12
 FFFFE377 00F111                          clr             CursorCol
 FFFFE379 020FC7                          bra             dcx7
                              dcx12:
 FFFFE37B 00F110                          clr             CursorRow
 FFFFE37D 020FC3                          bra             dcx7
                              dcx11:
 FFFFE37F 0C1099                          cmpb    #$99                            ; delete ?
 FFFFE381 026008                          bne             dcx13
 FFFFE383 08DF7B                          bsr             CalcScreenLoc
 FFFFE385 01F001                          tfr             d,x
 FFFFE387 096111                          lda             CursorCol               ; acc = cursor column
 FFFFE389 020011                          bra             dcx5
                              dcx13
 FFFFE38B 0C1008                          cmpb    #CTRLH                  ; backspace ?
 FFFFE38D 02601E                          bne             dcx3
 FFFFE38F 096111                          lda             CursorCol
 FFFFE391 02702E                          beq             dcx4
 FFFFE393 04A                             deca
 FFFFE394 097111                          sta             CursorCol
 FFFFE396 08DF68                          bsr             CalcScreenLoc
 FFFFE398 01F001                          tfr             d,x
 FFFFE39A 096111                          lda             CursorCol
                              dcx5:
 FFFFE39C 0E6001                          ldb             1,x
 FFFFE39E 0E7801                          stb             ,x++
 FFFFE3A0 04C                             inca
 FFFFE3A1 081040                          cmpa    #COLS
 FFFFE3A3 025FF7                          blo             dcx5
 FFFFE3A5 0C6020                          ldb             #' '
 FFFFE3A7 0301FF                          dex
 FFFFE3A9 0E7804                          stb             ,x
 FFFFE3AB 020014                          bra             dcx4
                              dcx3:
 FFFFE3AD 0C100A                          cmpb    #LF                             ; linefeed ?
 FFFFE3AF 02700E                          beq             dclf
 FFFFE3B1 034004                          pshs    b
 FFFFE3B3 08DF4B                          bsr     CalcScreenLoc
 FFFFE3B5 01F001                          tfr             d,x
 FFFFE3B7 035004                          puls    b
 FFFFE3B9 0E7804                          stb             ,x
                                      ; ToDo character color
                              ;       lda             CharColor
                              ;       sta             $2000,x
 FFFFE3BB 08D006                          bsr             IncCursorPos
 FFFFE3BD 020002                          bra             dcx4
                              dclf:
 FFFFE3BF 08D011                          bsr             IncCursorRow
                              dcx4:
 FFFFE3C1 035096                          puls    d,x,pc
 
                              ;------------------------------------------------------------------------------
                              ; Increment the cursor position, scroll the screen if needed.
                              ;
                              ; Modifies:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              IncCursorPos:
 FFFFE3C3 034016                          pshs    d,x
 FFFFE3C5 096111                          lda             CursorCol
 FFFFE3C7 04C                             inca
 FFFFE3C8 097111                          sta             CursorCol
 FFFFE3CA 081040                          cmpa    #COLS
 FFFFE3CC 025014                          blo             icc1
 FFFFE3CE 00F111                          clr             CursorCol               ; column = 0
 FFFFE3D0 020002                          bra             icr1
                              IncCursorRow:
 FFFFE3D2 034016                          pshs    d,x
                              icr1:
 FFFFE3D4 096110                          lda             CursorRow
 FFFFE3D6 04C                             inca
 FFFFE3D7 097110                          sta             CursorRow
 FFFFE3D9 081020                          cmpa    #ROWS
 FFFFE3DB 025005                          blo             icc1
 FFFFE3DD 04A                             deca                                                    ; backup the cursor row, we are scrolling up
 FFFFE3DE 097110                          sta             CursorRow
 FFFFE3E0 08DE91                          bsr             ScrollUp
                              icc1:
 FFFFE3E2 08DEF6                          bsr             UpdateCursorPos
                              icc2:
 FFFFE3E4 035096                          puls    d,x,pc  
 
                              ;------------------------------------------------------------------------------
                              ; Display a string on the screen.
                              ;
                              ; Modifies:
                              ;               none
                              ; Parameters:
                              ;               d = pointer to string
                              ;------------------------------------------------------------------------------
                              ;
                              DisplayString:
 FFFFE3E6 034016                          pshs    d,x
 FFFFE3E8 01F001                          tfr             d,x
 FFFFE3EA 0150B6FFFFFFF14                 lda             COREID
 FFFFE3EF 081020                          cmpa    #$20
 FFFFE3F1 027007                          beq             dspj1B
                              dspj2:                                          ; lock semaphore for access
 FFFFE3F3 0150B6FFFEF0001                 lda             OUTSEMA+1
 FFFFE3F8 027FF9                          beq             dspj2
                              dspj1B:
 FFFFE3FA 0E6800                          ldb             ,x+                             ; move string char into acc
 FFFFE3FC 027005                          beq             dsretB          ; is it end of string ?
 FFFFE3FE 017000E0C                       lbsr    OUTCH                   ; display character
 FFFFE401 020FF7                          bra             dspj1B
                              dsretB:
 FFFFE403 01507FFFFEF0001                 clr             OUTSEMA+1       ; unlock semaphore
 FFFFE408 035096                          puls    d,x,pc
 
                              DisplayStringCRLF:
 FFFFE40A 034006                          pshs    d
 FFFFE40C 08DFD8                          bsr             DisplayString
 FFFFE40E 0C600D                          ldb             #CR
 FFFFE410 017000DFA                       lbsr    OUTCH
 FFFFE413 0C600A                          ldb             #LF
 FFFFE415 017000DF5                       lbsr    OUTCH
 FFFFE418 035086                          puls    d,pc
                                      
                              ;
                              ; PRINT CR, LF, STRING
                              ;
                              PSTRNG
 FFFFE41A 08D002                          BSR             PCRLF
 FFFFE41C 02000D                          BRA             PDATA
                              PCRLF
 FFFFE41E 034010                          PSHS    X
 FFFFE420 08EFFE432                       LDX             #CRLFST
 FFFFE423 08D006                          BSR             PDATA
 FFFFE425 035010                          PULS    X
 FFFFE427 039                             RTS
 
                              PRINT
 FFFFE428 0BDFFF20D                       JSR             OUTCH
                              PDATA
 FFFFE42B 0E6800                          LDB             ,X+
 FFFFE42D 0C1004                          CMPB    #$04
 FFFFE42F 026FF7                          BNE             PRINT
 FFFFE431 039                             RTS
 
                              CRLFST
 FFFFE432 00D00A004                       fcb     CR,LF,4
 
                              DispDWordAsHex:
 FFFFE435 08D007                          bsr             DispWordAsHex
 FFFFE437 01E001                          exg             d,x
 FFFFE439 08D003                          bsr             DispWordAsHex
 FFFFE43B 01E001                          exg             d,x
 FFFFE43D 039                             rts
 
                              DispWordAsHex:
 FFFFE43E 01E089                          exg             a,b
 FFFFE440 08D005                          bsr             DispByteAsHex
 FFFFE442 01E089                          exg             a,b
 FFFFE444 08D001                          bsr             DispByteAsHex
 FFFFE446 039                             rts
 
                              DispByteAsHex:
 FFFFE447 034004                    pshs  b
 FFFFE449 054                             lsrb
 FFFFE44A 054                             lsrb
 FFFFE44B 054                             lsrb
 FFFFE44C 054                             lsrb
 FFFFE44D 054                             lsrb
 FFFFE44E 054                             lsrb
 FFFFE44F 054                             lsrb
 FFFFE450 054                             lsrb
 FFFFE451 08D00C                          bsr             DispNyb
 FFFFE453 035004                          puls    b
 FFFFE455 034004                          pshs    b
 FFFFE457 054                             lsrb
 FFFFE458 054                             lsrb
 FFFFE459 054                             lsrb
 FFFFE45A 054                             lsrb
 FFFFE45B 08D002                          bsr             DispNyb
 FFFFE45D 035004                          puls    b
 
                              DispNyb
 FFFFE45F 034004                          pshs    b
 FFFFE461 0C400F                          andb    #$0F
 FFFFE463 0C100A                          cmpb    #10
 FFFFE465 025007                          blo             DispNyb1
 FFFFE467 0CB037                          addb    #'A'-10
 FFFFE469 017000DA1                       lbsr    OUTCH
 FFFFE46C 035084                          puls    b,pc
                              DispNyb1
 FFFFE46E 0CB030                          addb    #'0'
 FFFFE470 017000D9A                       lbsr    OUTCH
 FFFFE473 035084                          puls    b,pc
 
                              ;==============================================================================
                              ; Timer
                              ;==============================================================================
 
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; Timer routines for a WDC6522 compatible circuit.
                              ;
                              ; This source file is free software: you can redistribute it and/or modify 
                              ; it under the terms of the GNU Lesser General Public License as published 
                              ; by the Free Software Foundation, either version 3 of the License, or     
                              ; (at your option) any later version.                                      
                              ;                                                                          
                              ; This source file is distributed in the hope that it will be useful,      
                              ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                              ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                              ; GNU General Public License for more details.                             
                              ;                                                                          
                              ; You should have received a copy of the GNU General Public License        
                              ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                              ;                                                                          
                              ; ============================================================================
                              ;
                              TimerInit:
 FFFFE475 034001                          pshs    ccr
 FFFFE477 01A010                          sei                                                                             ; turn off interrupts while using mapped I/O
 FFFFE479 0CCF306FF                       ldd             #VIA_MMU                                ; VIA MMU setting; map VIA into page $000
 FFFFE47C 0150FDFFFE38000                 std             MMU
 FFFFE481 0CC061A80                       ldd             #$61A80                                 ; compare to 400000 (100 Hz assuming 40MHz clock)
 FFFFE484 0D7014                          stb             VIA_T3CMPL
 FFFFE486 097015                          sta             VIA_T3CMPH
 FFFFE488 00F012                          clr             VIA_T3LL
 FFFFE48A 00F013                          clr             VIA_T3LH
 FFFFE48C 09600B                          lda             VIA_ACR                 ; set continuous mode for timer
 FFFFE48E 08A100                          ora             #$100
 FFFFE490 09700B                          sta             VIA_ACR                 
 FFFFE492 086880                          lda             #$880                                           ; enable timer #3 interrupts
 FFFFE494 09700E                          sta             VIA_IER
 FFFFE496 0CC000F00                       ldd             #$000F00                                ; reset page zero
 FFFFE499 0150FDFFFE38000                 std             MMU
 FFFFE49E 035081                          puls    ccr,pc
 
                              TimerIRQ:
 FFFFE4A0 0CCF306FF                       ldd             #VIA_MMU                        ; map VIA to page 0
 FFFFE4A3 0150FDFFFE38000                 std             MMU
 FFFFE4A8 0CCF1F6FF                       ldd             #PIC_MMU                        ; map PIC to page 1
 FFFFE4AB 0150FDFFFE38002                 std             MMU+2
                                      ; Reset the edge sense circuit in the PIC
 FFFFE4B0 08601F                          lda             #31                                                     ; Timer is IRQ #31
 FFFFE4B2 0B7002010                       sta             $2000+16                                        ; register 16 is edge sense reset reg   
 FFFFE4B5 0B60020FF                       lda             $2000+$FF                                       ; Timer active interrupt flag
 FFFFE4B8 027035                          beq             notTimerIRQ
 FFFFE4BA 07F0020FF                       clr             $2000+$FF                                       ; clear the flag
 FFFFE4BD 08601F                          lda             #31                                                     ; Timer is IRQ #31
 FFFFE4BF 0B7FFC011                       sta             IrqSource               ; stuff a byte indicating the IRQ source for PEEK()
 FFFFE4C2 00F012                          clr             VIA_T3LL                ; should clear the interrupt
 FFFFE4C4 00F013                          clr             VIA_T3LH
 FFFFE4C6 08601F                          lda             #31                                                     ; Timer is IRQ #31
 FFFFE4C8 0B7002010                       sta             $2000+16                                        ; register 16 is edge sense reset reg   
 FFFFE4CB 07F0020FF                       clr             $2000+$FF                                       ; clear the flag
 FFFFE4CE 07CE0003F                       inc             $E0003F         ; update timer IRQ screen flag
 FFFFE4D1 0FCFFC016                       ldd             milliseconds+2
 FFFFE4D4 0C300000A                       addd    #10
 FFFFE4D7 0FDFFC016                       std             milliseconds+2
 FFFFE4DA 0FCFFC014                       ldd             milliseconds
 FFFFE4DD 189000000                       adcd    #0
 FFFFE4E0 0FDFFC014                       std             milliseconds
 
                                      ; Update XModem timer, we just always do it rather than testing if XModem
                                      ; is active. The increment is set to give approximately 3s before the MSB
                                      ; gets set.
 FFFFE4E3 0150F6FFFFFC020                 ldb             xm_timer
 FFFFE4E8 0CB004                          addb    #4
 FFFFE4EA 0150F7FFFFFC020                 stb             xm_timer
                              notTimerIRQ:
 FFFFE4EF 0CC000F00                       ldd             #$000F00                        ; done with VIA, map it out
 FFFFE4F2 0150FDFFFE38000                 std             MMU
 FFFFE4F7 0CC001F00                       ldd             #$001F00                        ; done with PIC, map it out
 FFFFE4FA 0150FDFFFE38002                 std             MMU+2
 FFFFE4FF 039                             rts
                                      
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2013-2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; BSD 3-Clause License
                              ; Redistribution and use in source and binary forms, with or without
                              ; modification, are permitted provided that the following conditions are met:
                              ;
                              ; 1. Redistributions of source code must retain the above copyright notice, this
                              ;    list of conditions and the following disclaimer.
                              ;
                              ; 2. Redistributions in binary form must reproduce the above copyright notice,
                              ;    this list of conditions and the following disclaimer in the documentation
                              ;    and/or other materials provided with the distribution.
                              ;
                              ; 3. Neither the name of the copyright holder nor the names of its
                              ;    contributors may be used to endorse or promote products derived from
                              ;    this software without specific prior written permission.
                              ;
                              ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                              ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                              ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                              ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                              ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                              ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                              ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                              ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                              ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                              ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                              ;                                                                          
                              ; ============================================================================
                              ;
                              ;===============================================================================
                              ; Generic I2C routines
                              ;
                              ; It is assumed there may be more than one I2C controller in the system, so
                              ; the address of the controller is passed in the X register.
                              ;===============================================================================
 
                              I2C_PREL        EQU             $0
                              I2C_PREH        EQU             $1
                              I2C_CTRL        EQU             $2
                              I2C_RXR         EQU             $3
                              I2C_TXR         EQU             $3
                              I2C_CMD         EQU             $4
                              I2C_STAT        EQU             $4
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; i2c initialization, sets the clock prescaler
                              ;
                              ; Parameters:
                              ;               x = I2C controller address
                              ; Returns: none
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              i2c_init:
 FFFFE500 034004                          pshs    b
 FFFFE502 0C6004                          ldb             #4                                                                      ; setup prescale for 400kHz clock
 FFFFE504 0E7804                          stb             I2C_PREL,x
 FFFFE506 06F001                          clr             I2C_PREH,x
 FFFFE508 035084                          puls    b,pc
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Wait for I2C transfer to complete
                              ;
                              ; Parameters
                              ;       x - I2C controller base address
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              i2c_wait_tip:
 FFFFE50A 034004                          pshs            b
                              i2cw1:
 FFFFE50C 0E6004                          ldb                     I2C_STAT,x              ; would use lvb, but lb is okay since its the I/O area
 FFFFE50E 0C5001                          bitb            #1                                              ; wait for tip to clear
 FFFFE510 026FFA                          bne                     i2cw1
 FFFFE512 035084                          puls            b,pc
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Write command to i2c
                              ;
                              ; Parameters
                              ;               accb - data to transmit
                              ;               acca - command value
                              ;               x       - I2C controller base address
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              i2c_wr_cmd:
 FFFFE514 0E7003                          stb             I2C_TXR,x
 FFFFE516 0A7004                          sta             I2C_CMD,x
 FFFFE518 08DFF0                          bsr             i2c_wait_tip
 FFFFE51A 0E6004                          ldb             I2C_STAT,x
 FFFFE51C 039                             rts
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Parameters
                              ;               x - I2C controller base address
                              ;               accb - data to send
                              ; Returns: none
                              ; Stack space: 2 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              i2c_xmit1:
 FFFFE51D 034006                          pshs    d                                                               ; save data value
 FFFFE51F 034006                          pshs    d                                                               ; and save it again
 FFFFE521 0C6001                          ldb             #1
 FFFFE523 0E7002                          stb             I2C_CTRL,x                      ; enable the core
 FFFFE525 0C6076                          ldb             #$76                                            ; set slave address = %0111011
 FFFFE527 086090                          lda             #$90                                            ; set STA, WR
 FFFFE529 08DFE9                          bsr             i2c_wr_cmd
 FFFFE52B 08D00A                          bsr             i2c_wait_rx_nack
 FFFFE52D 035006                          puls    d                                                               ; get back data value
 FFFFE52F 086050                          lda             #$50                                            ; set STO, WR
 FFFFE531 08DFE1                          bsr             i2c_wr_cmd
 FFFFE533 08D002                          bsr             i2c_wait_rx_nack
 FFFFE535 035086                          puls    d,pc
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              i2c_wait_rx_nack:
 FFFFE537 034004                          pshs    b                                                               ; save off accb
                              i2cwr1:
 FFFFE539 0E6004                          ldb             I2C_STAT,x                      ; wait for RXack = 0
 FFFFE53B 0C5080                          bitb    #$80                                            ; test for nack
 FFFFE53D 026FFA                          bne             i2cwr1
 FFFFE53F 035084                          puls    b,pc
 
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; BSD 3-Clause License
                              ; Redistribution and use in source and binary forms, with or without
                              ; modification, are permitted provided that the following conditions are met:
                              ;
                              ; 1. Redistributions of source code must retain the above copyright notice, this
                              ;    list of conditions and the following disclaimer.
                              ;
                              ; 2. Redistributions in binary form must reproduce the above copyright notice,
                              ;    this list of conditions and the following disclaimer in the documentation
                              ;    and/or other materials provided with the distribution.
                              ;
                              ; 3. Neither the name of the copyright holder nor the names of its
                              ;    contributors may be used to endorse or promote products derived from
                              ;    this software without specific prior written permission.
                              ;
                              ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                              ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                              ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                              ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                              ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                              ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                              ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                              ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                              ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                              ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                              ;
                              ; ============================================================================
 
                              ;===============================================================================
                              ; Realtime clock routines
                              ;===============================================================================
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Read the real-time-clock chip.
                              ;
                              ; The entire contents of the clock registers and sram are read into a buffer
                              ; in one-shot rather than reading the registers individually.
                              ;
                              ; Parameters: none
                              ; Returns: d = 0 on success, otherwise non-zero
                              ; Modifies: d and RTCBuf
                              ; Stack space: 6 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              rtc_read:
 FFFFE541 08EE34000                       ldx                     #RTC
 FFFFE544 18E007FC0                       ldy                     #RTCBuf
 FFFFE547 0C6080                          ldb                     #$80
 FFFFE549 0E7002                          stb                     I2C_CTRL,x              ; enable I2C
 FFFFE54B 0CC0900DE                       ldd                     #$900DE                         ; read address, write op, STA + wr bit
 FFFFE54E 08DFC4                          bsr                     i2c_wr_cmd
 FFFFE550 0C5080                          bitb            #$80
 FFFFE552 02603B                          bne                     rtc_rxerr
 FFFFE554 0CC010000                       ldd                     #$10000                         ; address zero, wr bit
 FFFFE557 08DFBB                          bsr                     i2c_wr_cmd
 FFFFE559 0C5080                          bitb            #$80
 FFFFE55B 026032                          bne                     rtc_rxerr
 FFFFE55D 0CC0900DF                       ldd                     #$900DF                         ; read address, read op, STA + wr bit
 FFFFE560 08DFB2                          bsr                     i2c_wr_cmd
 FFFFE562 0C5080                          bitb            #$80
 FFFFE564 026029                          bne                     rtc_rxerr
                                      
 FFFFE566 05F                             clrb
                              rtcr0001:
 FFFFE567 086020                          lda                     #$20
 FFFFE569 0A7004                          sta                     I2C_CMD,x                       ; rd bit
 FFFFE56B 08DF9D                          bsr                     i2c_wait_tip
 FFFFE56D 08DFC8                          bsr                     i2c_wait_rx_nack
 FFFFE56F 0A6004                          lda                     I2C_STAT,x
 FFFFE571 085080                          bita            #$80
 FFFFE573 02601A                          bne                     rtc_rxerr
 FFFFE575 0A6003                          lda                     I2C_RXR,x
 FFFFE577 0A7A07                          sta                     b,y
 FFFFE579 05C                             incb
 FFFFE57A 0C105F                          cmpb            #$5F
 FFFFE57C 025FE9                          blo                     rtcr0001
 FFFFE57E 086068                          lda                     #$68
 FFFFE580 0A7004                          sta                     I2C_CMD,x                       ; STO, rd bit + nack
 FFFFE582 08DF86                          bsr                     i2c_wait_tip
 FFFFE584 0A6004                          lda                     I2C_STAT,x
 FFFFE586 085080                          bita            #$80
 FFFFE588 026005                          bne                     rtc_rxerr
 FFFFE58A 0A6003                          lda                     I2C_RXR,x
 FFFFE58C 0A7A07                          sta                     b,y
 FFFFE58E 14F                             clrd                                                                    ; return 0
                              rtc_rxerr:
 FFFFE58F 06F002                          clr                     I2C_CTRL,x      ; disable I2C and return status
 FFFFE591 04F                             clra
 FFFFE592 039                             rts
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Write the real-time-clock chip.
                              ;
                              ; The entire contents of the clock registers and sram are written from a 
                              ; buffer (RTCBuf) in one-shot rather than writing the registers individually.
                              ;
                              ; Parameters: none
                              ; Returns: r1 = 0 on success, otherwise non-zero
                              ; Modifies: r1 and RTCBuf
                              ; Stack space: 6 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              rtc_write:
 FFFFE593 08EE34000                       ldx             #RTC
 FFFFE596 18E007FC0                       ldy             #RTCBuf
                                      
 FFFFE599 0C6080                          ldb             #$80
 FFFFE59B 0E7002                          stb             I2C_CTRL,x              ; enable I2C
 FFFFE59D 0CC0900DE                       ldd             #$900DE                         ; read address, write op, STA + wr bit
 FFFFE5A0 08DF72                          bsr             i2c_wr_cmd
 FFFFE5A2 0C5080                          bitb    #$80
 FFFFE5A4 026FE9                          bne             rtc_rxerr
 FFFFE5A6 0CC010000                       ldd             #$10000                         ; address zero, wr bit
 FFFFE5A9 08DF69                          bsr             i2c_wr_cmd
 FFFFE5AB 0C5080                          bitb    #$80
 FFFFE5AD 026FE0                          bne             rtc_rxerr
 
 FFFFE5AF 0C6000                          ldb             #0
                              rtcw0001:
 FFFFE5B1 034004                          pshs    b
 FFFFE5B3 0E6A05                          ldb             b,y
 FFFFE5B5 086010                          lda             #$10
 FFFFE5B7 08DF5B                          bsr             i2c_wr_cmd
 FFFFE5B9 0C5080                          bitb    #$80
 FFFFE5BB 035004                          puls    b
 FFFFE5BD 026FD0                          bne             rtc_rxerr
 FFFFE5BF 05C                             incb
 FFFFE5C0 0C105F                          cmpb    #$5F
 FFFFE5C2 025FED                          blo             rtcw0001
 FFFFE5C4 0E6A05                          ldb             b,y
 FFFFE5C6 086050                          lda             #$50                                    ; STO, wr bit
 FFFFE5C8 08DF4A                          bsr             i2c_wr_cmd
 FFFFE5CA 0C5080                          bitb    #$80
 FFFFE5CC 026FC1                          bne             rtc_rxerr
 FFFFE5CE 14F                             clrd                                                            ; return 0
 FFFFE5CF 06F002                          clr             I2C_CTRL,x              ; disable I2C and return status
 FFFFE5D1 039                             rts
 
                              ;==============================================================================
                              ; Keyboard I/O
                              ;==============================================================================
 
                                      ;--------------------------------------------------------------------------
                                      ; PS2 scan codes to ascii conversion tables.
                                      ;--------------------------------------------------------------------------
                                      ;
                                      org     (* + 127) & $FFFFFF80
 
                              unshiftedScanCodes:
 FFFFE600 02E0A902E0A50A30A10A2           fcb     $2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
 FFFFE607 0AC
 FFFFE608 02E0AA0A80A60A4009060           fcb     $2e,$aa,$a8,$a6,$a4,$09,$60,$2e
 FFFFE60F 02E
 FFFFE610 02E02E02E02E02E071031           fcb     $2e,$2e,$2e,$2e,$2e,$71,$31,$2e
 FFFFE617 02E
 FFFFE618 02E02E07A073061077032           fcb     $2e,$2e,$7a,$73,$61,$77,$32,$2e
 FFFFE61F 02E
 FFFFE620 02E063078064065034033           fcb     $2e,$63,$78,$64,$65,$34,$33,$2e
 FFFFE627 02E
 FFFFE628 02E020076066074072035           fcb     $2e,$20,$76,$66,$74,$72,$35,$2e
 FFFFE62F 02E
 FFFFE630 02E06E062068067079036           fcb     $2e,$6e,$62,$68,$67,$79,$36,$2e
 FFFFE637 02E
 FFFFE638 02E02E06D06A075037038           fcb     $2e,$2e,$6d,$6a,$75,$37,$38,$2e
 FFFFE63F 02E
 FFFFE640 02E02C06B06906F030039           fcb     $2e,$2c,$6b,$69,$6f,$30,$39,$2e
 FFFFE647 02E
 FFFFE648 02E02E02F06C03B07002D           fcb     $2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
 FFFFE64F 02E
 FFFFE650 02E02E02702E05B03D02E           fcb     $2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
 FFFFE657 02E
 FFFFE658 0AD02E00D05D02E05C02E           fcb     $ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
 FFFFE65F 02E
 FFFFE660 02E02E02E02E02E02E008           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
 FFFFE667 02E
 FFFFE668 02E09502E09309402E02E           fcb     $2e,$95,$2e,$93,$94,$2e,$2e,$2e
 FFFFE66F 02E
 FFFFE670 09807F09202E09109001B           fcb     $98,$7f,$92,$2e,$91,$90,$1b,$af
 FFFFE677 0AF
 FFFFE678 0AB02E09702E02E0960AE           fcb     $ab,$2e,$97,$2e,$2e,$96,$ae,$2e
 FFFFE67F 02E
 
 FFFFE680 02E02E02E0A702E02E02E           fcb     $2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
 FFFFE687 02E
 FFFFE688 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE68F 02E
 FFFFE690 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE697 02E
 FFFFE698 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE69F 02E
 FFFFE6A0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE6A7 02E
 FFFFE6A8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE6AF 02E
 FFFFE6B0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE6B7 02E
 FFFFE6B8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE6BF 02E
 FFFFE6C0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE6C7 02E
 FFFFE6C8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE6CF 02E
 FFFFE6D0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE6D7 02E
 FFFFE6D8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE6DF 02E
 FFFFE6E0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE6E7 02E
 FFFFE6E8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE6EF 02E
 FFFFE6F0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE6F7 02E
 FFFFE6F8 02E02E0FA02E02E02E02E           fcb     $2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
 FFFFE6FF 02E
 
                              shiftedScanCodes:
 FFFFE700 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE707 02E
 FFFFE708 02E02E02E02E02E00907E           fcb     $2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
 FFFFE70F 02E
 FFFFE710 02E02E02E02E02E051021           fcb     $2e,$2e,$2e,$2e,$2e,$51,$21,$2e
 FFFFE717 02E
 FFFFE718 02E02E05A053041057040           fcb     $2e,$2e,$5a,$53,$41,$57,$40,$2e
 FFFFE71F 02E
 FFFFE720 02E043058044045024023           fcb     $2e,$43,$58,$44,$45,$24,$23,$2e
 FFFFE727 02E
 FFFFE728 02E020056046054052025           fcb     $2e,$20,$56,$46,$54,$52,$25,$2e
 FFFFE72F 02E
 FFFFE730 02E04E04204804705905E           fcb     $2e,$4e,$42,$48,$47,$59,$5e,$2e
 FFFFE737 02E
 FFFFE738 02E02E04D04A05502602A           fcb     $2e,$2e,$4d,$4a,$55,$26,$2a,$2e
 FFFFE73F 02E
 FFFFE740 02E03C04B04904F029028           fcb     $2e,$3c,$4b,$49,$4f,$29,$28,$2e
 FFFFE747 02E
 FFFFE748 02E03E03F04C03A05005F           fcb     $2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
 FFFFE74F 02E
 FFFFE750 02E02E02202E07B02B02E           fcb     $2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
 FFFFE757 02E
 FFFFE758 02E02E00D07D02E07C02E           fcb     $2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
 FFFFE75F 02E
 FFFFE760 02E02E02E02E02E02E008           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
 FFFFE767 02E
 FFFFE768 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE76F 02E
 FFFFE770 02E07F02E02E02E02E01B           fcb     $2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
 FFFFE777 02E
 FFFFE778 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE77F 02E
 
 FFFFE780 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE787 02E
 FFFFE788 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE78F 02E
 FFFFE790 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE797 02E
 FFFFE798 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE79F 02E
 FFFFE7A0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE7A7 02E
 FFFFE7A8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE7AF 02E
 FFFFE7B0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE7B7 02E
 FFFFE7B8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE7BF 02E
 FFFFE7C0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE7C7 02E
 FFFFE7C8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE7CF 02E
 FFFFE7D0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE7D7 02E
 FFFFE7D8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE7DF 02E
 FFFFE7E0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE7E7 02E
 FFFFE7E8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE7EF 02E
 FFFFE7F0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE7F7 02E
 FFFFE7F8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE7FF 02E
 
                              ; control
                              keybdControlCodes:
 FFFFE800 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE807 02E
 FFFFE808 02E02E02E02E02E00907E           fcb     $2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
 FFFFE80F 02E
 FFFFE810 02E02E02E02E02E011021           fcb     $2e,$2e,$2e,$2e,$2e,$11,$21,$2e
 FFFFE817 02E
 FFFFE818 02E02E01A013001017040           fcb     $2e,$2e,$1a,$13,$01,$17,$40,$2e
 FFFFE81F 02E
 FFFFE820 02E003018004005024023           fcb     $2e,$03,$18,$04,$05,$24,$23,$2e
 FFFFE827 02E
 FFFFE828 02E020016006014012025           fcb     $2e,$20,$16,$06,$14,$12,$25,$2e
 FFFFE82F 02E
 FFFFE830 02E00E00200800701905E           fcb     $2e,$0e,$02,$08,$07,$19,$5e,$2e
 FFFFE837 02E
 FFFFE838 02E02E00D00A01502602A           fcb     $2e,$2e,$0d,$0a,$15,$26,$2a,$2e
 FFFFE83F 02E
 FFFFE840 02E03C00B00900F029028           fcb     $2e,$3c,$0b,$09,$0f,$29,$28,$2e
 FFFFE847 02E
 FFFFE848 02E03E03F00C03A01005F           fcb     $2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
 FFFFE84F 02E
 FFFFE850 02E02E02202E07B02B02E           fcb     $2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
 FFFFE857 02E
 FFFFE858 02E02E00D07D02E07C02E           fcb     $2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
 FFFFE85F 02E
 FFFFE860 02E02E02E02E02E02E008           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
 FFFFE867 02E
 FFFFE868 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE86F 02E
 FFFFE870 02E07F02E02E02E02E01B           fcb     $2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
 FFFFE877 02E
 FFFFE878 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE87F 02E
 
                              keybdExtendedCodes:
 FFFFE880 02E02E02E02E0A30A10A2           fcb     $2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
 FFFFE887 02E
 FFFFE888 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE88F 02E
 FFFFE890 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE897 02E
 FFFFE898 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE89F 02E
 FFFFE8A0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE8A7 02E
 FFFFE8A8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE8AF 02E
 FFFFE8B0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE8B7 02E
 FFFFE8B8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE8BF 02E
 FFFFE8C0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE8C7 02E
 FFFFE8C8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE8CF 02E
 FFFFE8D0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE8D7 02E
 FFFFE8D8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE8DF 02E
 FFFFE8E0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 FFFFE8E7 02E
 FFFFE8E8 02E09502E09309402E02E           fcb     $2e,$95,$2e,$93,$94,$2e,$2e,$2e
 FFFFE8EF 02E
 FFFFE8F0 09809909202E09109002E           fcb     $98,$99,$92,$2e,$91,$90,$2e,$2e
 FFFFE8F7 02E
 FFFFE8F8 02E02E09702E02E09602E           fcb     $2e,$2e,$97,$2e,$2e,$96,$2e,$2e
 FFFFE8FF 02E
 
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2013-2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ;       Keyboard driver routines to interface to a PS2 style keyboard
                              ; Converts the scancode to ascii
                              ;
                              ; This source file is free software: you can redistribute it and/or modify 
                              ; it under the terms of the GNU Lesser General Public License as published 
                              ; by the Free Software Foundation, either version 3 of the License, or     
                              ; (at your option) any later version.                                      
                              ;                                                                          
                              ; This source file is distributed in the hope that it will be useful,      
                              ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                              ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                              ; GNU General Public License for more details.                             
                              ;                                                                          
                              ; You should have received a copy of the GNU General Public License        
                              ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                              ;                                                                          
                              ; ============================================================================
                              ;
                              SC_F12  EQU     $07
                              SC_C    EQU             $21
                              SC_T    EQU         $2C
                              SC_Z            EQU     $1A
                              SC_DEL  EQU                     $71     ; extend
                              SC_KEYUP        EQU             $F0     ; should be $f0
                              SC_EXTEND EQU     $E0
                              SC_CTRL EQU                     $14
                              SC_RSHIFT               EQU     $59
                              SC_NUMLOCK      EQU     $77
                              SC_SCROLLLOCK           EQU     $7E
                              SC_CAPSLOCK             EQU             $58
                              SC_ALT  EQU                     $11
 
                              ;#define SC_LSHIFT      EQU             $12
                              ;SC_DEL         EQU             $71             ; extend
                              ;SC_LCTRL       EQU             $58
 
                              SC_TAB  EQU     $0D
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Recieve a byte from the keyboard, used after a command is sent to the
                              ; keyboard in order to wait for a response.
                              ;
                              ; Parameters: none
                              ; Returns: accd = recieved byte ($00 to $FF), -1 on timeout
                              ; Modifies: acc
                              ; Stack Space: 2 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdRecvByte:
 FFFFE900 034010                          pshs    x
 FFFFE902 08E000064                       ldx             #100                                            ; wait up to 1s
                              krb3:
 FFFFE905 08D05A                          bsr             KeybdGetStatus  ; wait for response from keyboard
 FFFFE907 05D                             tstb
 FFFFE908 02B00B                          bmi             krb4                                            ; is input buffer full ? yes, branch
 FFFFE90A 08D02D                          bsr             Wait10ms                                ; wait a bit
 FFFFE90C 0301FF                          dex
 FFFFE90E 026FF5                          bne             krb3                                            ; go back and try again
 FFFFE910 0CCFFFFFF                       ldd             #-1                                                     ; return -1
 FFFFE913 035090                          puls    x,pc
                              krb4:
 FFFFE915 08D066                          bsr             KeybdGetScancode
 FFFFE917 035090                          puls    x,pc
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Send a byte to the keyboard.
                              ;
                              ; Parameters: accb byte to send
                              ; Returns: none
                              ; Modifies: none
                              ; Stack Space: 0 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdSendByte:
 FFFFE919 0150F7FFFE30000                 stb             KEYBD
 FFFFE91E 039                             rts
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Wait until the keyboard transmit is complete
                              ;
                              ; Parameters: none
                              ; Returns: r1 = 0 if successful, r1 = -1 timeout
                              ; Modifies: r1
                              ; Stack Space: 3 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdWaitTx:
 FFFFE91F 034010                          pshs    x
 FFFFE921 08E000064                       ldx             #100                            ; wait a max of 1s
                              kwt1:
 FFFFE924 08D03B                          bsr             KeybdGetStatus
 FFFFE926 0C4040                          andb    #$40                            ; check for transmit complete bit; branch if bit set
 FFFFE928 02600B                          bne             kwt2
 FFFFE92A 08D00D                          bsr             Wait10ms                ; delay a little bit
 FFFFE92C 0301FF                          dex
 FFFFE92E 026FF4                          bne             kwt1                            ; go back and try again
 FFFFE930 0CCFFFFFF                       ldd             #-1                                     ; timed out, return -1
 FFFFE933 035090                          puls    x,pc
                              kwt2:
 FFFFE935 04F                             clra                                                    ; wait complete, return 0
 FFFFE936 05F                             clrb                                                    
 FFFFE937 035090                          puls    x,pc                            
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Wait for 10 ms
                              ;
                              ; Parameters: none
                              ; Returns: none
                              ; Modifies: none
                              ; Stack Space: 2 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              Wait10ms:
 FFFFE939 034006                          pshs    d
 FFFFE93B 0150B6FFFFFFF1B                 lda             MSCOUNT+3
                              W10_0001:
 FFFFE940 01F089                          tfr             a,b
 FFFFE942 0150F0FFFFFFF1B                 subb    MSCOUNT+3
 FFFFE947 0C1FFA                          cmpb    #$FFA
 FFFFE949 022FF5                          bhi             W10_0001
 FFFFE94B 035086                          puls    d,pc
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Wait for 300 ms (256 ms)
                              ;
                              ; Parameters: none
                              ; Returns: none
                              ; Modifies: none
                              ; Stack Space: 2 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              Wait300ms:
 FFFFE94D 034006                          pshs    d
 FFFFE94F 0150B6FFFFFFF1B                 lda             MSCOUNT+3
                              W300_0001:
 FFFFE954 01F089                          tfr             a,b
 FFFFE956 0150F0FFFFFFF1B                 subb    MSCOUNT+3
 FFFFE95B 0C1F00                          cmpb    #$F00
 FFFFE95D 022FF5                          bhi     W300_0001
 FFFFE95F 035086                          puls    d,pc
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Get the keyboard status
                              ;
                              ; Parameters: none
                              ; Returns: d = status
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdGetStatus:
                              kbgs3:
 FFFFE961 0150F6FFFE30001                 ldb             KEYBD+1
 FFFFE966 0C5080                          bitb    #$80
 FFFFE968 02600E                          bne             kbgs1
 FFFFE96A 0C5001                          bitb    #$01            ; check parity error flag
 FFFFE96C 026002                          bne             kbgs2
 FFFFE96E 04F                             clra
 FFFFE96F 039                             rts
                              kbgs2:
 FFFFE970 0C60FE                          ldb             #$FE            ; request resend
 FFFFE972 08DFA5                          bsr             KeybdSendByte
 FFFFE974 08DFA9                          bsr             KeybdWaitTx
 FFFFE976 020FE9                          bra             kbgs3
                              kbgs1:                                  ; return negative status
 FFFFE978 0CAF00                          orb             #$F00
 FFFFE97A 086FFF                          lda             #-1
 FFFFE97C 039                             rts
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Get the scancode from the keyboard port
                              ;
                              ; Parameters: none
                              ; Returns: acca = scancode
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdGetScancode:
 FFFFE97D 04F                             clra
 FFFFE97E 0150F6FFFE30000                 ldb             KEYBD                           ; get the scan code
 FFFFE983 01507FFFFE30001                 clr             KEYBD+1                 ; clear receive register (write $00 to status reg)
 FFFFE988 039                             rts
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Set the LEDs on the keyboard.
                              ;
                              ; Parameters: d LED status to set
                              ; Returns: none
                              ; Modifies: none
                              ; Stack Space: 2 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdSetLED:
 FFFFE989 034004                          pshs    b
 FFFFE98B 0C60ED                          ldb             #$ED                                            ; set LEDs command
 FFFFE98D 08DF8A                          bsr             KeybdSendByte
 FFFFE98F 08DF8E                          bsr             KeybdWaitTx
 FFFFE991 08DF6D                          bsr             KeybdRecvByte   ; should be an ack
 FFFFE993 035004                          puls    b
 FFFFE995 08DF82                          bsr             KeybdSendByte
 FFFFE997 08DF86                          bsr             KeybdWaitTx
 FFFFE999 08DF65                          bsr             KeybdRecvByte   ; should be an ack
 FFFFE99B 039                             rts
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Get ID - get the keyboards identifier code.
                              ;
                              ; Parameters: none
                              ; Returns: d = $AB83, $00 on fail
                              ; Modifies: d, KeybdID updated
                              ; Stack Space: 2 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdGetID:
 FFFFE99C 0C60F2                          ldb             #$F2
 FFFFE99E 08DF79                          bsr             KeybdSendByte
 FFFFE9A0 08DF7D                          bsr             KeybdWaitTx
 FFFFE9A2 08DF5C                          bsr             KeybdRecvByte
 FFFFE9A4 0C5080                          bitb    #$80
 FFFFE9A6 026014                          bne             kgnotKbd
 FFFFE9A8 0C10AB                          cmpb    #$AB
 FFFFE9AA 026010                          bne             kgnotKbd
 FFFFE9AC 08DF52                          bsr             KeybdRecvByte
 FFFFE9AE 0C5080                          bitb    #$80
 FFFFE9B0 02600A                          bne             kgnotKbd
 FFFFE9B2 0C1083                          cmpb    #$83
 FFFFE9B4 026006                          bne             kgnotKbd
 FFFFE9B6 0CC00AB83                       ldd             #$AB83
                              kgid1:
 FFFFE9B9 0DD124                          std             KeybdID
 FFFFE9BB 039                             rts
                              kgnotKbd:
 FFFFE9BC 04F                             clra
 FFFFE9BD 05F                             clrb
 FFFFE9BE 020FF9                          bra             kgid1
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Initialize the keyboard.
                              ;
                              ; Parameters:
                              ;               none
                              ;       Modifies:
                              ;               none
                              ; Returns:
                              ;               none
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdInit:
 FFFFE9C0 034026                          pshs    d,y
 FFFFE9C2 18E000005                       ldy             #5
 FFFFE9C5 00F120                          clr             KeyState1               ; records key up/down state
 FFFFE9C7 00F121                          clr             KeyState2               ; records shift,ctrl,alt state
                              kbdi0002:
 FFFFE9C9 08DF6E                          bsr             Wait10ms
 FFFFE9CB 01507FFFFE30001                 clr             KEYBD+1                 ; clear receive register (write $00 to status reg)
 FFFFE9D0 0C6FFF                          ldb             #-1                                     ; send reset code to keyboard
 FFFFE9D2 0150F7FFFE30001                 stb             KEYBD+1                 ; write $FF to status reg to clear TX state
 FFFFE9D7 08DF40                          bsr             KeybdSendByte   ; now write to transmit register
 FFFFE9D9 08DF44                          bsr             KeybdWaitTx             ; wait until no longer busy
 FFFFE9DB 08DF23                          bsr             KeybdRecvByte   ; look for an ACK ($FA)
 FFFFE9DD 0C10FA                          cmpb    #$FA
 FFFFE9DF 026021                          bne             kbdiTryAgain
 FFFFE9E1 08DF1D                          bsr             KeybdRecvByte   ; look for BAT completion code ($AA)
 FFFFE9E3 0C10FC                          cmpb    #$FC                            ; reset error ?
 FFFFE9E5 02701B                          beq             kbdiTryAgain
 FFFFE9E7 0C10AA                          cmpb    #$AA                            ; reset complete okay ?
 FFFFE9E9 026017                          bne             kbdiTryAgain
 
                                      ; After a reset, scan code set #2 should be active
                              .config:
 FFFFE9EB 0C60F0                          ldb             #$F0                    ; send scan code select
 FFFFE9ED 0150F7FFFE60001                 stb             LEDS
 FFFFE9F2 08DF25                          bsr             KeybdSendByte
 FFFFE9F4 08DF29                          bsr             KeybdWaitTx
 FFFFE9F6 05D                             tstb
 FFFFE9F7 02B009                          bmi             kbdiTryAgain
 FFFFE9F9 08DF05                          bsr             KeybdRecvByte   ; wait for response from keyboard
 FFFFE9FB 04D                             tsta
 FFFFE9FC 02B004                          bmi             kbdiTryAgain
 FFFFE9FE 0C10FA                          cmpb    #$FA                                    ; ACK
 FFFFEA00 02700C                          beq             kbdi0004
                              kbdiTryAgain:
 FFFFEA02 0313FF                          dey
 FFFFEA04 026FC3                          bne       kbdi0002
                              .keybdErr:
 FFFFEA06 0CCFFEA2E                       ldd             #msgBadKeybd
 FFFFEA09 017FFF9FE                       lbsr    DisplayStringCRLF
*** warning 1: Long branch within short branch range could be optimized
 FFFFEA0C 020014                          bra             ledxit
                              kbdi0004:
 FFFFEA0E 0C6002                          ldb             #2                      ; select scan code set #2
 FFFFEA10 08DF07                          bsr             KeybdSendByte
 FFFFEA12 08DF0B                          bsr             KeybdWaitTx
 FFFFEA14 05D                             tstb
 FFFFEA15 02BFEB                          bmi             kbdiTryAgain
 FFFFEA17 08DEE7                          bsr             KeybdRecvByte   ; wait for response from keyboard
 FFFFEA19 04D                             tsta
 FFFFEA1A 02BFE6                          bmi             kbdiTryAgain
 FFFFEA1C 0C10FA                          cmpb    #$FA
 FFFFEA1E 026FE2                          bne             kbdiTryAgain
 FFFFEA20 08DF7A                          bsr             KeybdGetID
                              ledxit:
 FFFFEA22 0C6007                          ldb             #$07
 FFFFEA24 08DF63                          bsr             KeybdSetLED
 FFFFEA26 08DF25                          bsr             Wait300ms
 FFFFEA28 0C6000                          ldb             #$00
 FFFFEA2A 08DF5D                          bsr             KeybdSetLED
 FFFFEA2C 0350A6                          puls    d,y,pc
 
                              msgBadKeybd:
 FFFFEA2E 04B06507906206F061072           fcb             "Keyboard error",0
 FFFFEA35 06402006507207206F072
 FFFFEA3C 000
 
                              ;------------------------------------------------------------------------------
                              ; Calculate number of character in input buffer
                              ;
                              ; Parameters:
                              ;               y = $Cn00000 where n is core id
                              ; Returns:
                              ;               d = number of bytes in buffer.
                              ;------------------------------------------------------------------------------
 
                              kbdRcvCount:
 FFFFEA3D 04F                             clra
 FFFFEA3E 0E6A08128                       ldb             kbdTailRcv,y
 FFFFEA41 0E0A08127                       subb    kbdHeadRcv,y
 FFFFEA44 02C008                          bge             krcXit
 FFFFEA46 0C6040                          ldb             #$40
 FFFFEA48 0E0A08127                       subb    kbdHeadRcv,y
 FFFFEA4B 0EBA08128                       addb    kbdTailRcv,y
                              krcXit:
 FFFFEA4E 039                             rts
 
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdIRQ:
 FFFFEA4F 0150B6FFFE30001                 lda             KEYBD+1                                         ; check status
 FFFFEA54 085080                          bita    #$80                                                    ; was key pressed?
 FFFFEA56 027034                          beq             notKbdIRQ                                       ; if not, exit
 FFFFEA58 0150F6FFFE30000                 ldb             KEYBD                                                   ; get the scan code
 FFFFEA5D 01507FFFFE30001                 clr             KEYBD+1                                         ; clear receive register (write $00 to status reg)
 FFFFEA62 034004                          pshs    b                                                                       ; save it off
 FFFFEA64 0B6FFC010                       lda             IOFocusID                                       ; compute core memory address $Cn0000
 FFFFEA67 05F                             clrb
 FFFFEA68 048                             asla
 FFFFEA69 048                             asla
 FFFFEA6A 048                             asla
 FFFFEA6B 048                             asla
 FFFFEA6C 08AC00                          ora             #$C00                                                   ; address $Cn0000       
 FFFFEA6E 01F002                          tfr             d,y                                                             ; y =
 FFFFEA70 08DFCB                          bsr             kbdRcvCount                             ; get count of scan codes in buffer
 FFFFEA72 0C1040                          cmpb    #64                                                             ; check if buffer full?
 FFFFEA74 024017                          bhs             kbdBufFull                              ; if buffer full, ignore new keystroke
 FFFFEA76 01F021                          tfr             y,x                                                             ; compute fifo address
 FFFFEA78 0E6A08128                       ldb             kbdTailRcv,y                    ; b = buffer index
 FFFFEA7B 035002                          puls    a                                                                       ; get back scancode
 FFFFEA7D 030040                          leax    kbdFifo,x                                       ; x = base address for fifo
 FFFFEA7F 0A7845                          sta             b,x                                                             ; store in buffer
 FFFFEA81 05C                             incb                                                                            ; increment buffer index
 FFFFEA82 0C403F                          andb    #$3f                                                    ; wrap around at 64 chars
 FFFFEA84 0E7A08128                       stb             kbdTailRcv,y                    ; update it
 FFFFEA87 08601C                          lda             #28                                                             ; Keyboard is IRQ #28
 FFFFEA89 0B7FFC011                       sta             IrqSource                                       ; stuff a byte indicating the IRQ source for PEEK()
                              notKbdIRQ:
 FFFFEA8C 039                             rts     
                              kbdBufFull:
 FFFFEA8D 032601                          leas    1,s                                                             ; get rid of saved scancode
 FFFFEA8F 039                             rts
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              DBGCheckForKey:
 FFFFEA90 020ECF                          bra             KeybdGetStatus
 
 
                              ; KeyState2 variable bit meanings
                              ;1176543210
                              ; ||||||||+ = shift
                              ; |||||||+- = alt
                              ; ||||||+-- = control
                              ; |||||+--- = numlock
                              ; ||||+---- = capslock
                              ; |||+----- = scrolllock
                              ; ||+------ = <empty>
                              ; |+------- =    "
                              ; |         =    "
                              ; |         =    "
                              ; |         =    "
                              ; +-------- = extended
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Keyboard get routine.
                              ;
                              ; The routine may get characters directly from the scancode input or less
                              ; directly from the scancode buffer, if things are interrupt driven.
                              ;
                              ; Parameters:
                              ;               b:  bit 11 = blocking status 1=blocking, 0=non blocking
                              ;               b:      bit 1  = scancode source 1=scancode buffer, 0=direct
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              GetKey:
 FFFFEA92 034030                          pshs    x,y
 FFFFEA94 0D7126                          stb             KeybdBlock                              ; save off blocking status
                              dbgk2:
 FFFFEA96 0D6126                          ldb             KeybdBlock
 FFFFEA98 034004                          pshs    b
 FFFFEA9A 0C5001                          bitb    #1                                                              ; what is the scancode source
 FFFFEA9C 02701A                          beq             dbgk20                                          ; branch if direct read
 FFFFEA9E 0150B6FFFFFFF14                 lda             COREID                                          ; compute core memory address
 FFFFEAA3 05F                             clrb
 FFFFEAA4 048                             asla
 FFFFEAA5 048                             asla
 FFFFEAA6 048                             asla
 FFFFEAA7 048                             asla
 FFFFEAA8 08AC00                          ora             #$C00
 FFFFEAAA 01F002                          tfr             d,y                                                             ; y = $Cn0000
 FFFFEAAC 08DF8F                          bsr             kbdRcvCount
 FFFFEAAE 05D                             tstb                                                                            ; anything in buffer?
 FFFFEAAF 035004                          puls    b
 FFFFEAB1 026018                          bne             dbgk1                                                   ; branch if something in buffer
 FFFFEAB3 05D                             tstb
 FFFFEAB4 02BFE0                          bmi             dbgk2                                                   ; if no key and blocking - loop
 FFFFEAB6 02000E                          bra             dbgk24
                              dbgk20:
 FFFFEAB8 18E000000                       ldy             #0
 FFFFEABB 08DEA4                          bsr             KeybdGetStatus
 FFFFEABD 0C4080                          andb    #$80                                                    ; is key available?
 FFFFEABF 035004                          puls    b
 FFFFEAC1 026008                          bne             dbgk1                                                   ; branch if key
 FFFFEAC3 05D                             tstb                                                                            ; block?
 FFFFEAC4 02BFD0                          bmi             dbgk2                                                   ; If no key and blocking - loop
                              dbgk24:
 FFFFEAC6 0CCFFFFFF                       ldd             #-1                                                             ; return -1 if no block and no key
 FFFFEAC9 0350B0                          puls    x,y,pc
                              dbgk1:
 FFFFEACB 18C000000                       cmpy    #0
 FFFFEACE 026004                          bne             dbgk22
 FFFFEAD0 08DEAB                          bsr             KeybdGetScancode        ; get scancode directly
 FFFFEAD2 020011                          bra             dbgk23
                              dbgk22:
                                      ; Retrieve value from scancode buffer
 FFFFEAD4 01F021                          tfr             y,x
 FFFFEAD6 030040                          leax    kbdFifo,x                                       ; x = fifo address
 FFFFEAD8 0E6A08127                       ldb             kbdHeadRcv,y                    ; b = buffer index
 FFFFEADB 0A6A0D                          lda             b,x                                                             ; get the scancode
 FFFFEADD 05C                             incb                                                                            ; increment fifo index
 FFFFEADE 0C403F                          andb    #$3f                                                    ; and wrap around
 FFFFEAE0 0E7A08127                       stb             kbdHeadRcv,y                    ; save it back
 FFFFEAE3 01F089                          tfr             a,b                                                             ; the scancode is needed in accb
                              dbgk23:
                              ;       lbsr    DispByteAsHex
                                      ; Make sure there is a small delay between scancode reads
 FFFFEAE5 08E000014                       ldx             #20
                              dbgk3:
 FFFFEAE8 0301FF                          dex
 FFFFEAEA 026FFC                          bne             dbgk3
                                      ; switch on scan code
 FFFFEAEC 0C10F0                          cmpb    #SC_KEYUP
 FFFFEAEE 026004                          bne             dbgk4
 FFFFEAF0 0D7120                          stb             KeyState1                                       ; make KeyState1 <> 0
 FFFFEAF2 020FA2                          bra             dbgk2                                                   ; loop back
                              dbgk4:
 FFFFEAF4 0C10E0                          cmpb    #SC_EXTEND
 FFFFEAF6 026008                          bne             dbgk5
 FFFFEAF8 096121                          lda             KeyState2
 FFFFEAFA 08A800                          ora             #$800
 FFFFEAFC 097121                          sta             KeyState2
 FFFFEAFE 020F96                          bra             dbgk2
                              dbgk5:
 FFFFEB00 0C1014                          cmpb    #SC_CTRL
 FFFFEB02 026016                          bne             dbgkNotCtrl
 FFFFEB04 00D120                          tst             KeyState1
 FFFFEB06 026008                          bne             dbgk7
 FFFFEB08 096121                          lda             KeyState2
 FFFFEB0A 08A004                          ora             #4
 FFFFEB0C 097121                          sta             KeyState2
 FFFFEB0E 020006                          bra             dbgk8
                              dbgk7:
 FFFFEB10 096121                          lda             KeyState2
 FFFFEB12 084FFB                          anda    #~4
 FFFFEB14 097121                          sta             KeyState2
                              dbgk8:
 FFFFEB16 00F120                          clr             KeyState1
 FFFFEB18 020F7C                          bra             dbgk2
                              dbgkNotCtrl:
 FFFFEB1A 0C1059                          cmpb    #SC_RSHIFT
 FFFFEB1C 026016                          bne             dbgkNotRshift
 FFFFEB1E 00D120                          tst             KeyState1
 FFFFEB20 026008                          bne             dbgk9
 FFFFEB22 096121                          lda             KeyState2
 FFFFEB24 08A001                          ora             #1
 FFFFEB26 097121                          sta             KeyState2
 FFFFEB28 020006                          bra             dbgk10
                              dbgk9:
 FFFFEB2A 096121                          lda             KeyState2
 FFFFEB2C 084FFE                          anda    #~1
 FFFFEB2E 097121                          sta             KeyState2
                              dbgk10:
 FFFFEB30 00F120                          clr             KeyState1
 FFFFEB32 020F62                          bra             dbgk2
                              dbgkNotRshift:
 FFFFEB34 0C1077                          cmpb    #SC_NUMLOCK
 FFFFEB36 026013                          bne             dbgkNotNumlock
 FFFFEB38 096121                          lda             KeyState2
 FFFFEB3A 088010                          eora    #16
 FFFFEB3C 097121                          sta             KeyState2
 FFFFEB3E 096122                          lda             KeyLED
 FFFFEB40 088002                          eora    #2
 FFFFEB42 097122                          sta             KeyLED
 FFFFEB44 01F089                          tfr             a,b
 FFFFEB46 04F                             clra
 FFFFEB47 08DE40                          bsr             KeybdSetLED
 FFFFEB49 020F4B                          bra             dbgk2
                              dbgkNotNumlock:
 FFFFEB4B 0C1058                          cmpb    #SC_CAPSLOCK
 FFFFEB4D 026013                          bne             dbgkNotCapslock
 FFFFEB4F 096121                          lda             KeyState2
 FFFFEB51 088020                          eora    #32
 FFFFEB53 097121                          sta             KeyState2
 FFFFEB55 096122                          lda             KeyLED
 FFFFEB57 088004                          eora    #4
 FFFFEB59 097122                          sta             KeyLED
 FFFFEB5B 01F089                          tfr             a,b
 FFFFEB5D 04F                             clra
 FFFFEB5E 08DE29                          bsr             KeybdSetLED
 FFFFEB60 020F34                          bra             dbgk2
                              dbgkNotCapslock:
 FFFFEB62 0C107E                          cmpb    #SC_SCROLLLOCK
 FFFFEB64 026013                          bne             dbgkNotScrolllock
 FFFFEB66 096121                          lda             KeyState2
 FFFFEB68 088040                          eora    #64
 FFFFEB6A 097121                          sta             KeyState2
 FFFFEB6C 096122                          lda             KeyLED
 FFFFEB6E 088001                          eora    #1
 FFFFEB70 097122                          sta             KeyLED
 FFFFEB72 01F089                          tfr             a,b
 FFFFEB74 04F                             clra
 FFFFEB75 08DE12                          bsr             KeybdSetLED
 FFFFEB77 020F1D                          bra             dbgk2
                              dbgkNotScrolllock:
 FFFFEB79 0C1011                          cmpb    #SC_ALT
 FFFFEB7B 026016                          bne             dbgkNotAlt
 FFFFEB7D 00D120                          tst             KeyState1
 FFFFEB7F 026008                          bne             dbgk11
 FFFFEB81 096121                          lda             KeyState2
 FFFFEB83 08A002                          ora             #2
 FFFFEB85 097121                          sta             KeyState2
 FFFFEB87 020006                          bra             dbgk12
                              dbgk11:
 FFFFEB89 096121                          lda             KeyState2
 FFFFEB8B 084FFD                          anda    #~2
 FFFFEB8D 097121                          sta             KeyState2
                              dbgk12:
 FFFFEB8F 00F120                          clr             KeyState1
 FFFFEB91 020F03                          bra             dbgk2
                              dbgkNotAlt:
 FFFFEB93 00D120                          tst             KeyState1
 FFFFEB95 027004                          beq             dbgk13
 FFFFEB97 00F120                          clr             KeyState1
 FFFFEB99 020EFB                          bra             dbgk2
                              dbgk13:
 FFFFEB9B 096121                          lda             KeyState2               ; Check for CTRL-ALT-DEL
 FFFFEB9D 084006                          anda    #6
 FFFFEB9F 081006                          cmpa    #6
 FFFFEBA1 026008                          bne             dbgk14
 FFFFEBA3 0C1071                          cmpb    #SC_DEL 
 FFFFEBA5 026004                          bne             dbgk14
 FFFFEBA7 06E90FFFFFFC                    jmp             [$FFFFFC]               ; jump to NMI vector
                              dbgk14:
 FFFFEBAB 00D121                          tst             KeyState2               ; extended code?
 FFFFEBAD 02A00B                          bpl             dbgk15
 FFFFEBAF 096121                          lda             KeyState2
 FFFFEBB1 0847FF                          anda    #$7FF
 FFFFEBB3 097121                          sta             KeyState2
 FFFFEBB5 08EFFE880                       ldx             #keybdExtendedCodes
 FFFFEBB8 020017                          bra             dbgk18
                              dbgk15:
 FFFFEBBA 096121                          lda             KeyState2               ; Is CTRL down?
 FFFFEBBC 085004                          bita    #4
 FFFFEBBE 027005                          beq             dbgk16
 FFFFEBC0 08EFFE800                       ldx             #keybdControlCodes
 FFFFEBC3 02000C                          bra             dbgk18
                              dbgk16:
 FFFFEBC5 085001                          bita    #1                                      ; Is shift down?
 FFFFEBC7 027005                          beq             dbgk17
 FFFFEBC9 08EFFE700                       ldx             #shiftedScanCodes
 FFFFEBCC 020003                          bra             dbgk18
                              dbgk17:
 FFFFEBCE 08EFFE600                       ldx             #unshiftedScanCodes
                              dbgk18:
 FFFFEBD1 0E690FFFE600                    ldb             b,x                                     ; load accb with ascii from table
 FFFFEBD5 04F                             clra
 FFFFEBD6 0350B0                          puls    x,y,pc                  ; and return
                                      
 
 FFFFEBD8 04B04505904204F041052           fcb             "KEYBOARD"
 FFFFEBDF 044
 FFFFEBE0 FFEBEA                          fcw             KeybdOpen
 FFFFEBE2 FFEBEB                          fcw             KeybdClose
 FFFFEBE4 FFEBEC                          fcw             KeybdRead
 FFFFEBE6 FFEBED                          fcw             KeybdWrite
 FFFFEBE8 FFEBEE                          fcw             KeybdSeek
 
                              ; Keyboard Open:
                              ; Initialize the keyboard buffer head and tail indexes
                              ;
                              KeybdOpen:
 FFFFEBEA 039                             rts
 
                              ; Keyboard Close:
                              ; Nothing to do except maybe clear the keyboard buffer
                              ;
                              KeybdClose:
 FFFFEBEB 039                             rts
                              ;
                              KeybdRead:
 FFFFEBEC 039                             rts
                              ;
                              KeybdWrite:
 FFFFEBED 039                             rts
 
                              KeybdSeek:
 FFFFEBEE 039                             rts
 
                              ;==============================================================================
                              ; Serial I/O
                              ;==============================================================================
 
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; Serial port routines for a WDC6551 compatible circuit.
                              ;
                              ; This source file is free software: you can redistribute it and/or modify 
                              ; it under the terms of the GNU Lesser General Public License as published 
                              ; by the Free Software Foundation, either version 3 of the License, or     
                              ; (at your option) any later version.                                      
                              ;                                                                          
                              ; This source file is distributed in the hope that it will be useful,      
                              ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                              ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                              ; GNU General Public License for more details.                             
                              ;                                                                          
                              ; You should have received a copy of the GNU General Public License        
                              ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                              ;                                                                          
                              ; ============================================================================
                              ;
                              ;------------------------------------------------------------------------------
                              ; Initialize serial port.
                              ;
                              ; Clear buffer indexes. Two bytes are used for the buffer index even though
                              ; only a single byte is needed. This is for convenience in calculating the
                              ; number of characters in the buffer, done later. The upper byte remains at
                              ; zero.
                              ; The port is initialized for 9600 baud, 1 stop bit and 8 bits data sent.
                              ; The internal baud rate generator is used.
                              ;
                              ; Stack Space:
                              ;               2 words
                              ; Parameters:
                              ;               none
                              ; Modifies:
                              ;               d
                              ; Returns:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                                      setdp   $FFFFFC
 
                              InitSerial:
                              SerialInit:
 FFFFEBEF 034009                          pshs    dpr,ccr
 FFFFEBF1 0CC000FFC                       ldd             #$FFC
 FFFFEBF4 01F00B                          tfr             d,dpr
 FFFFEBF6 04F                             clra
 FFFFEBF7 05F                             clrb
 FFFFEBF8 07FFFC018                       clr             SerHeadRcv
 FFFFEBFB 07FFFC019                       clr             SerTailRcv
 FFFFEBFE 07FFFC01A                       clr             SerHeadXmit
 FFFFEC01 07FFFC01B                       clr             SerTailXmit
 FFFFEC04 07FFFC01C                       clr             SerRcvXon
 FFFFEC07 07FFFC01D                       clr             SerRcvXoff
 FFFFEC0A 0150B6FFFFFFF14                 lda             COREID
                              sini1:
 FFFFEC0F 0B1FFC010                       cmpa    IOFocusID
 FFFFEC12 026FFB                          bne             sini1
 FFFFEC14 01A290                          orcc    #$290                                           ; mask off interrupts
 FFFFEC16 0CCF196FF                       ldd             #ACIA_MMU                               ; map ACIA into address space
 FFFFEC19 0150FDFFFE38000                 std             MMU
 FFFFEC1E 0C6009                          ldb             #$09                                            ; dtr,rts active, rxint enabled (bit 1=0), no parity
 FFFFEC20 0F7000002                       stb             ACIA_CMD
 FFFFEC23 0C601E                          ldb             #$1E                                            ; baud 9600, 1 stop bit, 8 bit, internal baud gen
 FFFFEC25 0F7000003                       stb             ACIA_CTRL
 FFFFEC28 0C60AC                          ldb             #$0AC                                           ; disable fifos (bit zero, one), reset fifos
 FFFFEC2A 0F700000B                       stb             ACIA_CTRL2      
 FFFFEC2D 0CC000F00                       ldd             #$000F00                                ; map out ACIA
 FFFFEC30 0150FDFFFE38000                 std             MMU
 FFFFEC35 035089                          puls    dpr,ccr,pc
 
                              ;------------------------------------------------------------------------------
                              ; SerialGetChar
                              ;
                              ; Check the serial port buffer to see if there's a char available. If there's
                              ; a char available then return it. If the buffer is almost empty then send an
                              ; XON.
                              ;
                              ; Stack Space:
                              ;               4 words
                              ; Parameters:
                              ;               none
                              ; Modifies:
                              ;               none
                              ; Returns:
                              ;               d = character or -1
                              ;------------------------------------------------------------------------------
 
                              SerialGetChar:
 FFFFEC37 034039                          pshs    ccr,x,y,dpr
 FFFFEC39 0CC000FFC                       ldd             #$FFC
 FFFFEC3C 01F00B                          tfr             d,dpr
 FFFFEC3E 01A290                          orcc    #$290                                           ; mask off interrupts
 FFFFEC40 08D0C7                          bsr             SerialRcvCount                  ; check number of chars in receive buffer
 FFFFEC42 0C1008                          cmpb    #8                                                      ; less than 8?
 FFFFEC44 02200F                          bhi             sgc2
 FFFFEC46 0F6FFC01C                       ldb             SerRcvXon                               ; skip sending XON if already sent
 FFFFEC49 02600A                          bne       sgc2            ; XON already sent?
 FFFFEC4B 0C6011                          ldb             #XON                                            ; if <8 send an XON
 FFFFEC4D 07FFFC01D                       clr             SerRcvXoff                      ; clear XOFF status
 FFFFEC50 0F7FFC01C                       stb             SerRcvXon                               ; flag so we don't send it multiple times
 FFFFEC53 08D07B                          bsr             SerialPutChar
                              sgc2:
 FFFFEC55 0F6FFC018                       ldb             SerHeadRcv                      ; check if anything is in buffer
 FFFFEC58 0F1FFC019                       cmpb    SerTailRcv
 FFFFEC5B 02700D                          beq             sgcNoChars                      ; no?
 FFFFEC5D 04F                             clra
 FFFFEC5E 01F001                          tfr             d,x     
 FFFFEC60 0E680A000FFB000                 ldb             SerRcvBuf,x                     ; get byte from buffer
 FFFFEC65 07CFFC018                       inc             SerHeadRcv                      ; 4k wrap around
 FFFFEC68 020003                          bra             sgcXit
                              sgcNoChars:
 FFFFEC6A 0CCFFFFFF                       ldd             #-1
                              sgcXit:
 FFFFEC6D 0350B9                          puls    ccr,x,y,dpr,pc
 
                              ;------------------------------------------------------------------------------
                              ; SerialPeekChar
                              ;
                              ; Check the serial port buffer to see if there's a char available. If there's
                              ; a char available then return it. But don't update the buffer indexes. No need
                              ; to send an XON here.
                              ;
                              ; Stack Space:
                              ;               3 words
                              ; Parameters:
                              ;               none
                              ; Modifies:
                              ;               none
                              ; Returns:
                              ;               d = character or -1
                              ;------------------------------------------------------------------------------
 
                              SerialPeekChar:
 FFFFEC6F 034019                          pshs    x,ccr,dpr
 FFFFEC71 0CC000FFC                       ldd             #$FFC
 FFFFEC74 01F00B                          tfr             d,dpr
 FFFFEC76 01A290                          orcc    #$290                                                   ; mask off interrupts
 FFFFEC78 0F6FFC018                       ldb             SerHeadRcv                              ; check if anything is in buffer
 FFFFEC7B 0F1FFC019                       cmpb    SerTailRcv
 FFFFEC7E 02700A                          beq             spcNoChars                              ; no?
 FFFFEC80 04F                             clra
 FFFFEC81 01F001                          tfr             d,x
 FFFFEC83 0E680A000FFB000                 ldb             SerRcvBuf,x                             ; get byte from buffer
 FFFFEC88 020003                          bra             spcXit
                              spcNoChars:
 FFFFEC8A 0CCFFFFFF                       ldd             #-1
                              spcXit:
 FFFFEC8D 035099                          puls    x,ccr,dpr,pc
 
                              ;------------------------------------------------------------------------------
                              ; SerialPeekChar
                              ;               Get a character directly from the I/O port. This bypasses the input
                              ; buffer.
                              ;
                              ; Stack Space:
                              ;               3 words
                              ; Parameters:
                              ;               none
                              ; Modifies:
                              ;               d
                              ; Returns:
                              ;               d = character or -1
                              ;------------------------------------------------------------------------------
 
                              SerialPeekCharDirect:
 FFFFEC8F 034009                          pshs    ccr,dpr
 FFFFEC91 0CC000FFC                       ldd             #$FFC
 FFFFEC94 01F00B                          tfr             d,dpr
 FFFFEC96 0150B6FFFFFFF14                 lda             COREID                                  ; Ensure we have the IO Focus
 FFFFEC9B 0B1FFC010                       cmpa    IOFocusID
 FFFFEC9E 026023                          bne             spcd0001
                                      ; Disallow interrupts between status read and rx read.
 FFFFECA0 0CCF196FF                       ldd             #ACIA_MMU
 FFFFECA3 01A290                          orcc    #$290                                           ; mask off interrupts
 FFFFECA5 0150FDFFFE38000                 std             MMU
 FFFFECAA 0F6000001                       ldb             ACIA_STAT
 FFFFECAD 0C5008                          bitb    #8                                                      ; look for Rx not empty
 FFFFECAF 027012                          beq             spcd0001
 FFFFECB1 0F6000000                       ldb             ACIA_RX
 FFFFECB4 034004                          pshs    b
 FFFFECB6 0CC000F00                       ldd             #$000F00
 FFFFECB9 0150FDFFFE38000                 std             MMU
 FFFFECBE 035004                          puls    b
 FFFFECC0 04F                             clra
 FFFFECC1 035089                          puls    ccr,dpr,pc
                              spcd0001:
 FFFFECC3 0CC000F00                       ldd             #$000F00
 FFFFECC6 0150FDFFFE38000                 std             MMU
 FFFFECCB 0CCFFFFFF                       ldd             #-1
 FFFFECCE 035089                          puls    ccr,dpr,pc
 
                              ;------------------------------------------------------------------------------
                              ; SerialPutChar
                              ;    Put a character to the serial transmitter. This routine blocks until the
                              ; transmitter is empty. 
                              ;
                              ; Stack Space
                              ;               4 words
                              ; Parameters:
                              ;               b = character to put
                              ; Modifies:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              SerialPutChar:
 FFFFECD0 03404F                          pshs    d,ccr,u,dpr
 FFFFECD2 0CE000FFC                       ldu             #$FFC
 FFFFECD5 01F03B                          tfr             u,dpr
                              spc0001:
 FFFFECD7 0CE000F00                       ldu             #$000F00
 FFFFECDA 0150FFFFFE38000                 stu             MMU
 FFFFECDF 0150B6FFFFFFF14                 lda             COREID                                  ; Ensure we have the IO Focus
 FFFFECE4 0B1FFC010                       cmpa    IOFocusID
 FFFFECE7 026FEE                          bne             spc0001
 FFFFECE9 01CD6F                          andcc   #$D6F                                           ; provide a window for an interrupt to occur
 FFFFECEB 0CEF196FF                       ldu             #ACIA_MMU
 FFFFECEE 01A290                          orcc    #$290                                           ; mask off interrupts
 FFFFECF0 0150FFFFFE38000                 stu             MMU
                                      ; Between the status read and the transmit do not allow an
                                      ; intervening interrupt.
 FFFFECF5 0B6000001                       lda             ACIA_STAT                               ; wait until the uart indicates tx empty
 FFFFECF8 085010                          bita    #16                                                     ; bit #4 of the status reg
 FFFFECFA 027FDB                          beq             spc0001                     ; branch if transmitter is not empty
 FFFFECFC 0F7000000                       stb             ACIA_TX                                 ; send the byte
 FFFFECFF 0CE000F00                       ldu             #$000F00
 FFFFED02 0150FFFFFE38000                 stu             MMU
 FFFFED07 0350CF                          puls    d,ccr,u,dpr,pc
 
                              ;------------------------------------------------------------------------------
                              ; Calculate number of character in input buffer. Direct page must be set
                              ; already.
                              ;
                              ; Parameters:
                              ;               none
                              ; Returns:
                              ;               d = number of bytes in buffer.
                              ;------------------------------------------------------------------------------
 
                              SerialRcvCount:
 FFFFED09 04F                             clra
 FFFFED0A 0F6FFC019                       ldb             SerTailRcv
 FFFFED0D 0F0FFC018                       subb    SerHeadRcv
 FFFFED10 02C009                          bge             srcXit
 FFFFED12 0CC001000                       ldd             #$1000
 FFFFED15 0B3FFC018                       subd    SerHeadRcv
 FFFFED18 0F3FFC019                       addd    SerTailRcv
                              srcXit:
 FFFFED1B 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Serial IRQ routine
                              ;
                              ; Keeps looping as long as it finds characters in the ACIA recieve buffer/fifo.
                              ; Received characters are buffered. If the buffer becomes full, new characters
                              ; will be lost.
                              ;
                              ; Stack Space:
                              ;               1 word
                              ; Parameters:
                              ;               none
                              ; Modifies:
                              ;               d,x
                              ; Returns:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              SerialIRQ:
 FFFFED1C 034008                          pshs    dpr                                                     ; set direct page register to boot variables
 FFFFED1E 0CC000FFC                       ldd             #$FFC
 FFFFED21 01F00B                          tfr             d,dpr
 FFFFED23 0CCF196FF                       ldd             #ACIA_MMU                               ; map ACIA to page #0
 FFFFED26 0150FDFFFE38000                 std             MMU
 FFFFED2B 0CCF1F6FF                       ldd             #PIC_MMU                                ; map PIC to page #1
 FFFFED2E 0150FDFFFE38002                 std             MMU+2
 FFFFED33 0B60020D3                       lda             $2000+$D3                               ; Serial active interrupt flag
 FFFFED36 027052                          beq             notSerInt
                              sirqNxtByte:
 FFFFED38 0F6000004                       ldb             ACIA_IRQS                               ; look for IRQs
 FFFFED3B 02A04D                          bpl             notSerInt                               ; quick test for any irqs
 FFFFED3D 0F6000001                       ldb             ACIA_STAT                               ; check the status
 FFFFED40 0C5008                          bitb    #$08                                            ; bit 3 = rx full (not empty)
 FFFFED42 027034                          beq             notRxInt1
 FFFFED44 0F6000000                       ldb             ACIA_RX                                 ; get data from Rx buffer to clear interrupt
 FFFFED47 0B6FFC019                       lda             SerTailRcv                      ; check if recieve buffer full
 FFFFED4A 04C                             inca
 FFFFED4B 0B1FFC018                       cmpa    SerHeadRcv
 FFFFED4E 02703A                          beq             sirqRxFull
 FFFFED50 0B7FFC019                       sta             SerTailRcv                      ; update tail pointer
 FFFFED53 04A                             deca                                                                    ; backup
 FFFFED54 01F09E                          tfr             b,e                                                     ; acce = char from port
 FFFFED56 01F089                          tfr             a,b                                                     ; b = buffer index
 FFFFED58 04F                             clra                                                                    ; a = 0
 FFFFED59 01F001                          tfr             d,x                                                     ; x = buffer index
 FFFFED5B 2A780A000FFB000                 ste             SerRcvBuf,x                     ; store recieved byte in buffer
 FFFFED60 07DFFC01D                       tst             SerRcvXoff                      ; check if xoff already sent
 FFFFED63 026FD3                          bne             sirqNxtByte
 FFFFED65 08DFA2                          bsr             SerialRcvCount  ; if more than 4070 chars in buffer
 FFFFED67 0C1FE6                          cmpb    #4070
 FFFFED69 025FCD                          blo             sirqNxtByte
 FFFFED6B 0C6013                          ldb             #XOFF                                           ; send an XOFF
 FFFFED6D 07FFFC01C                       clr             SerRcvXon                               ; clear XON status
 FFFFED70 0F7FFC01D                       stb             SerRcvXoff                      ; set XOFF status
 FFFFED73 0F7000000                       stb             ACIA_TX
 FFFFED76 020FC0                          bra             sirqNxtByte     ; check the status for another byte
                                      ; Process other serial IRQs
                              notRxInt1:
 FFFFED78 0CC000F00                       ldd             #$000F00
 FFFFED7B 0150FDFFFE38000                 std             MMU
 FFFFED80 0CC001F00                       ldd             #$001F00
 FFFFED83 0150FDFFFE38002                 std             MMU+2
 FFFFED88 035088                          puls    dpr,pc
                              sirqRxFull:
                              notRxInt:
                              notSerInt:
 FFFFED8A 0CC000F00                       ldd             #$000F00
 FFFFED8D 0150FDFFFE38000                 std             MMU
 FFFFED92 0CC001F00                       ldd             #$001F00
 FFFFED95 0150FDFFFE38002                 std             MMU+2
 FFFFED9A 035088                          puls    dpr,pc
 
                              nmeSerial:
 FFFFED9C 05306507206906106C000           fcb             "Serial",0
 
                              ;------------------------------------------------------------------------------
                              ; Put a string to the serial port.
                              ;
                              ; Parameters:
                              ;               d = pointer to string
                              ; Modifies:
                              ;               none
                              ; Returns:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              SerialPutString:
 FFFFEDA3 034016                          pshs    d,x
 FFFFEDA5 01F001                          tfr             d,x
                              sps2:
 FFFFEDA7 0E6804                          ldb             ,x
 FFFFEDA9 027006                          beq             spsXit
 FFFFEDAB 030001                          inx
 FFFFEDAD 08DF21                          bsr             SerialPutChar
 FFFFEDAF 020FF6                          bra             sps2
                              spsXit:
 FFFFEDB1 035096                          puls    d,x,pc
 
                              ;------------------------------------------------------------------------------
                              ; A little routine to test serial output.
                              ;
                              ; Parameters:
                              ;               none
                              ; Modifies:
                              ;               none
                              ; Returns:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              SerialOutputTest:
 FFFFEDB3 034006                          pshs    d
 FFFFEDB5 0CCFFEDD3                       ldd             #msgSerialTest
 FFFFEDB8 017FFF62B                       lbsr    DisplayString
*** warning 1: Long branch within short branch range could be optimized
 FFFFEDBB 08DE32                          bsr             SerialInit
                              sotst1:
 FFFFEDBD 0C6011                          ldb             #XON
 FFFFEDBF 08DF0F                          bsr             SerialPutChar
 FFFFEDC1 08DF0D                          bsr             SerialPutChar
 FFFFEDC3 08DF0B                          bsr             SerialPutChar
 FFFFEDC5 0CCFFEDD3                       ldd             #msgSerialTest
 FFFFEDC8 08DFD9                          bsr             SerialPutString
 FFFFEDCA 01700040A                       lbsr    INCH
 FFFFEDCD 0C1003                          cmpb    #CTRLC
 FFFFEDCF 026FEC                          bne             sotst1
 FFFFEDD1 035086                          puls    d,pc
 
                              msgSerialTest:
 FFFFEDD3 05306507206906106C020           fcb     "Serial port test",CR,LF,0
 FFFFEDDA 07006F072074020074065
 FFFFEDE1 07307400D00A000
 
                                      setdp   $000
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; BSD 3-Clause License
                              ; Redistribution and use in source and binary forms, with or without
                              ; modification, are permitted provided that the following conditions are met:
                              ;
                              ; 1. Redistributions of source code must retain the above copyright notice, this
                              ;    list of conditions and the following disclaimer.
                              ;
                              ; 2. Redistributions in binary form must reproduce the above copyright notice,
                              ;    this list of conditions and the following disclaimer in the documentation
                              ;    and/or other materials provided with the distribution.
                              ;
                              ; 3. Neither the name of the copyright holder nor the names of its
                              ;    contributors may be used to endorse or promote products derived from
                              ;    this software without specific prior written permission.
                              ;
                              ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                              ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                              ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                              ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                              ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                              ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                              ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                              ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                              ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                              ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                              ;                                                                          
                              ; ============================================================================
                              ;
                              ; C19 variables
                              ;
                              c19Address                      EQU             $940    ; to $943
                              c19StartAddress EQU             $944    ; to $947
                              c19Rectype                      EQU             $948
                              c19Reclen                               EQU             $949
                              c19Abort                                EQU             $94A
                              c19Checksum                     EQU             $94B
                              c19SummaryChecksum      EQU             $94C
                              c19Source                               EQU             $94E
                              c19XferAddress  EQU     $950    ; to $951
                              c19crc24                                EQU     $954
                              c19crcAddress           EQU     $956    ; to $959
                              c19Buf                                  EQU     $980    ; to $9FF
 
                              ; ------------------------------------------------------------------------------
                              ; Input a character either from a file in memory or from the serial port.
                              ;
                              ; Parameters:
                              ;               none
                              ;       Returns:
                              ;               accb = character input
                              ; ------------------------------------------------------------------------------
 
                              c19InputChar:
 FFFFEDE6 07D00094E                       tst             c19Source
 FFFFEDE9 02700D                          beq             c19ic1
 FFFFEDEB 0E690F000950                    ldb             [c19XferAddress]
 FFFFEDEF 07C000951                       inc             c19XferAddress+1        ; increment low byte of address pointer
 FFFFEDF2 026003                          bne             c19ic2
 FFFFEDF4 07C000950                       inc             c19XferAddress          ; increment high byte of address pointer
                              c19ic2:
 FFFFEDF7 039                             rts
                              c19ic1:
 FFFFEDF8 0CCFFFFFF                       ldd             #-1                                                     ; block until input is available
 FFFFEDFB 03F                             swi
 FFFFEDFC 001                             fcb             MF_INCH                                 ; monitor input rout
 FFFFEDFD 039                             rts     
 
                              ; ------------------------------------------------------------------------------
                              ; Skip over input to the next record.
                              ; ------------------------------------------------------------------------------
 
                              c19NextRecord:
 FFFFEDFE 08DFE6                          bsr             c19InputChar
 FFFFEE00 0C100A                          cmpb    #LF                                                     ; line feed marks end of record
 FFFFEE02 027013                          beq             c19nr1
 FFFFEE04 0C1003                          cmpb    #CTRLC                                  ; should not get this in a file transfer
 FFFFEE06 026003                          bne             c19nr2
 FFFFEE08 0F700094A                       stb             c19Abort
                              c19nr2:
 FFFFEE0B 0C101A                          cmpb    #CTRLZ                                  ; end of file marker?
 FFFFEE0D 026003                          bne             c19nr3
 FFFFEE0F 0F700094A                       stb             c19Abort
                              c19nr3:
 FFFFEE12 07D00094A                       tst             c19Abort
 FFFFEE15 027FE7                          beq             c19NextRecord
                              c19nr1:
 FFFFEE17 039                             rts
 
                              ; ------------------------------------------------------------------------------
                              ; Input a byte. There are three characters per byte since things are 12-bit.
                              ;
                              ;       Parameters:
                              ;               none
                              ; Returns:
                              ;               accb = byte value converted from text
                              ; ------------------------------------------------------------------------------
 
                              c19GetByte:
 FFFFEE18 08DFCC                          bsr             c19InputChar                    ; get the first character
 FFFFEE1A 0170007F2                       lbsr    AsciiToHexNybble        ; convert to nybble
 FFFFEE1D 07D00094A                       tst             c19Abort                                        ; check for abort
 FFFFEE20 027002                          beq             c19gb1
 FFFFEE22 04F                             clra
 FFFFEE23 039                             rts
                              c19gb1:                                                                         ; shift the value four bits
 FFFFEE24 058                             aslb
 FFFFEE25 058                             aslb
 FFFFEE26 058                             aslb
 FFFFEE27 058                             aslb
 FFFFEE28 034004                          pshs    b                                                                       ; save off value
 FFFFEE2A 08DFBA                          bsr             c19InputChar                    ; get the second character
 FFFFEE2C 0170007E0                       lbsr    AsciiToHexNybble        ; convert to nybble
 FFFFEE2F 07D00094A                       tst             c19Abort                                        ; check for abort
 FFFFEE32 026011                          bne             c19gb2
 FFFFEE34 0EAE00                          orb             ,s+                                                             ; merge new nybble into value
 FFFFEE36 058                             aslb                                                                            ; shift the value four more bits
 FFFFEE37 058                             aslb
 FFFFEE38 058                             aslb
 FFFFEE39 058                             aslb
 FFFFEE3A 034004                          pshs    b                                                                       ; save off value
 FFFFEE3C 08DFA8                          bsr             c19InputChar                    ; get the third character
 FFFFEE3E 0170007CE                       lbsr    AsciiToHexNybble        ; convert to nybble
 FFFFEE41 0EAE00                          orb             ,s+                                                             ; merge in value
 FFFFEE43 04F                             clra                                                                            ; make byte 000 to FFF in D
 FFFFEE44 039                             rts
                              c19gb2:
 FFFFEE45 032601                          leas    1,s                                                             ; discard saved byte
 FFFFEE47 04F                             clra
 FFFFEE48 039                             rts
 
                              ; ------------------------------------------------------------------------------
                              ; Get an address composed of two bytes (24 bit)
                              ;
                              ; Side Effects:
                              ;               updates c19Address variable
                              ; Returns:
                              ;       none
                              ; ------------------------------------------------------------------------------
 
                              c19GetAddress2:
 FFFFEE49 08E000000                       ldx             #0
 FFFFEE4C 08DFCA                          bsr             c19GetByte
 FFFFEE4E 0E7809000980                    stb             c19Buf,x
 FFFFEE52 030001                          inx
 FFFFEE54 07D00094A                       tst             c19Abort
 FFFFEE57 026008                          bne             c19ga1
 FFFFEE59 08DFBD                          bsr             c19GetByte
 FFFFEE5B 0E7809000980                    stb             c19Buf,x
 FFFFEE5F 030001                          inx
                              c19ga1:
 FFFFEE61 039                             rts
                                      
                              ; ------------------------------------------------------------------------------
                              ; Get an address composed of three bytes (36 bit)
                              ;
                              ; Side Effects:
                              ;               updates c19Address variable
                              ; Returns:
                              ;       none
                              ; ------------------------------------------------------------------------------
 
                              ;c19GetAddress3:
                              ;       bsr             c19ClearAddress
                              ;       bsr             c19GetByte
                              ;       stb             c19Address+1
                              ;       stb             c19Buf,x
                              ;       inx
                              ;       tst             c19Abort
                              ;       bne             c19ga2
                              ;       bsr             c19GetByte
                              ;       stb             c19Address+2
                              ;       stb             c19Buf,x
                              ;       inx
                              ;       tst             c19Abort
                              ;       bne             c19ga2
                              ;       bsr             c19GetByte
                              ;       stb             c19Address+3
                              ;       stb             c19Buf,x
                              ;       inx
                              ;c19ga2:
                              ;       rts
 
                              ; ------------------------------------------------------------------------------
                              ; Put a record to memory.
                              ; ------------------------------------------------------------------------------
 
                              c19PutMem:
 FFFFEE62 05F                             clrb                                                            ; accb = current byte count
 FFFFEE63 08E000002                       ldx             #2
                              c19pm3:
 FFFFEE66 034004                          pshs    b                                                       ; save byte count
 FFFFEE68 08DFAE                          bsr             c19GetByte              ; get a byte
 FFFFEE6A 0E7809000980                    stb             c19Buf,x                        ; stuff in a temp buffer somewhere
 FFFFEE6E 030001                          inx                                                                     ; index to next byte
 FFFFEE70 07D00094A                       tst             c19Abort                        ; check for abort
 FFFFEE73 02603E                          bne             c19pm1
 FFFFEE75 035004                          puls    b                                                       ; get back byte count
 FFFFEE77 05C                             incb                                                            ; increment byte count
 FFFFEE78 0F1000949                       cmpb    c19Reclen                       ; test if reached end of record
 FFFFEE7B 025FE9                          blo             c19pm3                          ; no, go back
 FFFFEE7D 08DF99                          bsr             c19GetByte              ; get CRC high byte
 FFFFEE7F 0F7000954                       stb             c19crc24
 FFFFEE82 08DF94                          bsr             c19GetByte              ; get CRC low byte
 FFFFEE84 0F7000955                       stb             c19crc24+1
 FFFFEE87 04F                             clra                                                            ; set y = reclen
 FFFFEE88 0F6000949                       ldb             c19Reclen
 FFFFEE8B 01F002                          tfr             d,y
 FFFFEE8D 03380F000980                    leau    c19Buf                          ; set u = pointer to buffer
 FFFFEE91 08D0BA                          bsr             calc_crc24              ; calc CRC for buffer
 FFFFEE93 1B3000954                       cmpd    c19crc24                        ; compared to received CRC
 FFFFEE96 027006                          beq             c19pm4                          ; if equal go to update memory
 FFFFEE98 0CCFFEF3B                       ldd             #msgCrcErr              ; otherwise display error
 FFFFEE9B 03F                             swi
 FFFFEE9C 004                             fcb             MF_DisplayString
 FFFFEE9D 039                             rts
                                      ; Now that it is verified the record is correct, update memory with the record.
                              c19pm4:
 FFFFEE9E 08E000000                       ldx             #0
                              c19pm5:
 FFFFEEA1 0E6809000982                    ldb             c19Buf+2,x                                      ; ignore the address bytes
 FFFFEEA5 0E7989000980                    stb             [c19Buf],x
 FFFFEEA9 030001                          inx
 FFFFEEAB 01F010                          tfr             x,d
 FFFFEEAD 0F1000949                       cmpb    c19Reclen
 FFFFEEB0 025FEF                          blo             c19pm5
 FFFFEEB2 039                             rts
                              c19pm1:
 FFFFEEB3 032601                          leas    1,s                                             ; get rid of byte count
 FFFFEEB5 039                             rts
 
                              ; ------------------------------------------------------------------------------
                              ; Processing for S1 record type.
                              ; ------------------------------------------------------------------------------
 
                              c19ProcessS1:
 FFFFEEB6 08DF91                          bsr             c19GetAddress2
 FFFFEEB8 08DFA8                          bsr             c19PutMem
                              c19p11:
 FFFFEEBA 02005A                          bra             c19lnr
 
                              ; ------------------------------------------------------------------------------
                              ; Processing for S2 record type.
                              ; ------------------------------------------------------------------------------
 
                              ;c19ProcessS2:
                              ;       bsr             c19GetAddress3
                              ;       bsr             c19PutMem
                              ;       tst             c19Checksum
                              ;       beq             c19p21
                              ;       inc             c19SummaryChecksum
                              ;       ldd             #msgChecksumErr
                              ;       swi
                              ;       fcb             MF_DisplayString
                              ;c19p21:
                              ;       bra             c19lnr
 
                              ; S3,4,5,6 not processed
 
                              ; ------------------------------------------------------------------------------
                              ; Processing for S7 record type. Gets a two byte (24 bit) start address.
                              ; ------------------------------------------------------------------------------
 
                              c19ProcessS9:
 FFFFEEBC 08DF8B                          bsr             c19GetAddress2
 FFFFEEBE 020064                          bra             c19l2
                                      
                              ; ------------------------------------------------------------------------------
                              ; Processing for S8 record type. Gets a three byte (36 bit) start address.
                              ; ------------------------------------------------------------------------------
 
                              ;c19ProcessS8:
                              ;       bsr             c19GetAddress3
                              ;       ldd             c19Address+2
                              ;       std             c19StartAddress+2
                              ;       ldd             c19Address+0
                              ;       std             c19StartAddress+0
                              ;       bra             c19l2
 
                              ; ------------------------------------------------------------------------------
                              ; S19 Loader
                              ;
                              ; Not all record types are processed. Some are skipped over.
                              ; ------------------------------------------------------------------------------
 
                              C19Loader:
 FFFFEEC0 07F00094E                       clr             c19Source
 FFFFEEC3 01700073B                       lbsr    GetNumber                               ; check for a file storage address
 FFFFEEC6 05D                             tstb
 FFFFEEC7 027009                          beq             c19l4                                           ; if not a memory file
 FFFFEEC9 07C00094E                       inc             c19Source                               ; set flag indicating a memory file
 FFFFEECC 0FC000912                       ldd             mon_numwka+2            ; set transfer address variable
 FFFFEECF 0FD000950                       std             c19XferAddress
                              c19l4:
 FFFFEED2 07F00094A                       clr             c19Abort                                ; clear the abort flag
 FFFFEED5 0CCFFEF27                       ldd             #msgC19Loader           ; signon banner
 FFFFEED8 03F                             swi
 FFFFEED9 004                             fcb             MF_DisplayString
                              c19l3:
 FFFFEEDA 08DF0A                          bsr             c19InputChar            ; get a character from input
 FFFFEEDC 0C101A                          cmpb    #CTRLZ                                  ; is it CTRL-Z?
 FFFFEEDE 027044                          beq             c19l2
 FFFFEEE0 0C1043                          cmpb    #'C'                                            ; records must start with the letter C
 FFFFEEE2 026032                          bne             c19lnr
 FFFFEEE4 08DF00                          bsr             c19InputChar            ; get the next character
 FFFFEEE6 0C1030                          cmpb    #'0'                                            ; must be a numeric digit
 FFFFEEE8 02502C                          blo             c19lnr
 FFFFEEEA 0C1039                          cmpb    #'9'
 FFFFEEEC 022028                          bhi             c19lnr
 FFFFEEEE 0F7000948                       stb             c19Rectype                      ; save off in record type
 FFFFEEF1 08DF25                          bsr             c19GetByte                      ; get a byte indicating record length
 FFFFEEF3 0F7000949                       stb             c19Reclen
 FFFFEEF6 07D00094A                       tst             c19Abort                                ; check for abort
 FFFFEEF9 026029                          bne             c19l2
 FFFFEEFB 0F6000948                       ldb             c19Rectype                      ; process according to record type
 FFFFEEFE 0C1030                          cmpb    #'0'
 FFFFEF00 027014                          beq             c19lnr
 FFFFEF02 0C1031                          cmpb    #'1'
 FFFFEF04 027FB0                          beq             c19ProcessS1            ; data record with a two byte address
                              ;       cmpb    #'2'
                              ;       beq             c19ProcessS2            ; data record with a three byte address
 FFFFEF06 0C1033                          cmpb    #'3'
 FFFFEF08 02700C                          beq             c19lnr
 FFFFEF0A 0C1035                          cmpb    #'5'                                            ; record count? ignore
 FFFFEF0C 027008                          beq             c19lnr
 FFFFEF0E 0C1037                          cmpb    #'7'                                            ; ignore record with 48 bit address
 FFFFEF10 027012                          beq             c19l2
                              ;       cmpb    #'8'
                              ;       beq             c19ProcessS8            ; three byte start address
 FFFFEF12 0C1039                          cmpb    #'9'
 FFFFEF14 027FA6                          beq             c19ProcessS9            ; two byte start address
                              c19lnr:
 FFFFEF16 0C602E                          ldb             #'.'                                            ; output a progress indicator
 FFFFEF18 03F                             swi
 FFFFEF19 002                             fcb             MF_OUTCH
 FFFFEF1A 08DEE2                          bsr             c19NextRecord           ; skip to the next record
 FFFFEF1C 07D00094A                       tst             c19Abort                                ; check for abort
 FFFFEF1F 1260004A0                       lbne    Monitor
 FFFFEF22 020FB6                          bra             c19l3                                           ; loop back to process more records
                              c19l2:
 FFFFEF24 01600049B                       lbra    Monitor
 
                              msgC19Loader:
 FFFFEF27 04303103902004C06F061           fcb     "C19 Loader Active",CR,LF,0
 FFFFEF2E 064065072020041063074
 FFFFEF35 06907606500D00A000
                              msgCrcErr:
 FFFFEF3B 043031039020043052043           fcb     "C19 CRC Err",CR,LF,0
 FFFFEF42 02004507207200D00A000
 
                              ; ------------------------------------------------------------------------------
                              ; Compute CRC-24 of buffer.
                              ;
                              ;int calcrc24(char *ptr, int count)
                              ;{
                              ;    int  crc;
                              ;    char i;
                              ;    crc = CRC24INIT;
                              ;    while (--count >= 0)
                              ;    {
                              ;        crc = crc ^ (int) (*ptr++ << 12);
                              ;        i = 12;
                              ;        do
                              ;        {
                              ;            if (crc & 0x800000)
                              ;                crc = crc << 1 ^ CRC24POLY;
                              ;            else
                              ;                crc = crc << 1;
                              ;        } while(--i);
                              ;    }
                              ;    return (crc);
                              ;}
                              ;
                              ; Parameters:
                              ;               y = number of bytes in buffer
                              ;               u = pointer to buffer
                              ; Returns:
                              ;               d = crc24 value
                              ;
                              ; ------------------------------------------------------------------------------
 
                              crc24_init:
 FFFFEF49 B704CE                          fcw             $B704CE
                              crc24_poly:
 FFFFEF4B CFB864                          fcw             $CFB864
 
                              calc_crc24:
 FFFFEF4D 0150FCFFFFFEF49                 ldd             crc24_init
                              calc_crc24c:
 FFFFEF52 0A8C00                          eora    ,u+
 FFFFEF54 08E00000C                       ldx             #12
                              calc_crc24b:
 FFFFEF57 058                             aslb
 FFFFEF58 049                             rola
 FFFFEF59 02400A                          bcc             calc_crc24a
 FFFFEF5B 0150F8FFFFFEF4C                 eorb    crc24_poly+1
 FFFFEF60 0150B8FFFFFEF4B                 eora    crc24_poly
                              calc_crc24a:
 FFFFEF65 0301FF                          dex
 FFFFEF67 026FEE                          bne             calc_crc24b
 FFFFEF69 0313FF                          dey
 FFFFEF6B 026FE5                          bne             calc_crc24c
 FFFFEF6D 039                             rts
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; BSD 3-Clause License
                              ; Redistribution and use in source and binary forms, with or without
                              ; modification, are permitted provided that the following conditions are met:
                              ;
                              ; 1. Redistributions of source code must retain the above copyright notice, this
                              ;    list of conditions and the following disclaimer.
                              ;
                              ; 2. Redistributions in binary form must reproduce the above copyright notice,
                              ;    this list of conditions and the following disclaimer in the documentation
                              ;    and/or other materials provided with the distribution.
                              ;
                              ; 3. Neither the name of the copyright holder nor the names of its
                              ;    contributors may be used to endorse or promote products derived from
                              ;    this software without specific prior written permission.
                              ;
                              ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                              ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                              ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                              ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                              ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                              ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                              ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                              ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                              ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                              ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                              ;                                                                          
                              ; ============================================================================
                              ;
                              ; Xmodem variables
                              ;
                              xm_timer                                EQU             $FFFFFC020
                              xm_protocol                     EQU             $9F5
                              xm_flag                                 EQU             $9F6
                              xm_checksum                     EQU             $9F7
                              xm_tmp2                                 EQU             $9F8
                              xm_packetnum            EQU             $9FA
                              xm_tmp                                  EQU             $9FC
                              xm_crc                                  EQU             $9FE
                              xm_ibuf                                 EQU             $A00    ; to $A7F
                              xm_obuf                                 EQU             $A80    ; to $AFF
 
                              ; ------------------------------------------------------------------------------
                              ; Send data using XModem.
                              ; ------------------------------------------------------------------------------
 
                              xm_SendStart:
 FFFFEF6E 0170005D4                       lbsr    GetRange
 FFFFEF71 0BE000922                       ldx             mon_r1+2                                ; x = buffer address
 FFFFEF74 01F013                          tfr             x,u
 FFFFEF76 0C6001                          ldb             #1                                                      ; packet numbers start at one
 FFFFEF78 0F70009FB                       stb             xm_packetnum+1
                                      ; Wait for receiver to send a NAK
                              xm_send:                                                        
 FFFFEF7B 0CCFFFFFF                       ldd             #-1                                                     ; select blocking input
 FFFFEF7E 03F                             swi
 FFFFEF7F 001                             fcb             MF_INCH
 FFFFEF80 0C1015                          cmpb    #NAK                                            ; should have got a NAK
 FFFFEF82 027004                          beq             xm_send5
 FFFFEF84 0C1043                          cmpb    #'C'                                            ; or a 'C'
 FFFFEF86 026FF3                          bne             xm_send
                              xm_send5:
 FFFFEF88 0F70009F5                       stb             xm_protocol
                              xm_send4:
 FFFFEF8B 0C6001                          ldb             #SOH                                            ; send start
 FFFFEF8D 03F                             swi
 FFFFEF8E 20D                             fcb             OUTCH                   
 FFFFEF8F 0F60009FB                       ldb             xm_packetnum+1  ; send packet number
 FFFFEF92 03F                             swi
 FFFFEF93 002                             fcb             MF_OUTCH
 FFFFEF94 053                             comb                                                                    ; one's complement
 FFFFEF95 03F                             swi
 FFFFEF96 002                             fcb             MF_OUTCH                                ; send packet number complement
 FFFFEF97 04F                             clra                                                                    ; acca = byte count
 FFFFEF98 01F013                          tfr             x,u                                                     ; u = buffer address
                              xm_send1:
 FFFFEF9A 0E6C00                          ldb             ,u+                                                     ; grab a byte from the buffer
 FFFFEF9C 03F                             swi
 FFFFEF9D 002                             fcb             MF_OUTCH                                ; send it out
 FFFFEF9E 04C                             inca
 FFFFEF9F 081080                          cmpa    #128                                            ; number of bytes in payload
 FFFFEFA1 025FF7                          blo             xm_send1
 FFFFEFA3 0F60009F5                       ldb             xm_protocol
 FFFFEFA6 0C1043                          cmpb    #'C'                                            ; CRC protocol?
 FFFFEFA8 02601E                          bne             xm_send2
 FFFFEFAA 08D183                          bsr             xm_calc_crc                     ; compute CRC
 FFFFEFAC 0FC0009FE                       ldd             xm_crc                                  ; get crc
 FFFFEFAF 044                             lsra                                                                    ; transfer high eight bits first, so
 FFFFEFB0 056                             rorb                                                                    ; right shift D by eight
 FFFFEFB1 044                             lsra
 FFFFEFB2 056                             rorb
 FFFFEFB3 044                             lsra
 FFFFEFB4 056                             rorb
 FFFFEFB5 044                             lsra
 FFFFEFB6 056                             rorb
 FFFFEFB7 044                             lsra
 FFFFEFB8 056                             rorb
 FFFFEFB9 044                             lsra
 FFFFEFBA 056                             rorb
 FFFFEFBB 044                             lsra
 FFFFEFBC 056                             rorb
 FFFFEFBD 044                             lsra
 FFFFEFBE 056                             rorb
 FFFFEFBF 03F                             swi
 FFFFEFC0 002                             fcb             MF_OUTCH                                ; send out the byte
 FFFFEFC1 0FC0009FE                       ldd             xm_crc                                  ; get back CRC
 FFFFEFC4 03F                             swi                                                                     
 FFFFEFC5 002                             fcb             MF_OUTCH                                ; and send out low byte
 FFFFEFC6 020007                          bra             xm_send3
                              xm_send2:
 FFFFEFC8 08D153                          bsr             xm_calc_checksum
 FFFFEFCA 0F60009F7                       ldb             xm_checksum
 FFFFEFCD 03F                             swi
 FFFFEFCE 002                             fcb             MF_OUTCH
                              xm_send3:
 FFFFEFCF 03F                             swi
 FFFFEFD0 0CCFFFFFF                       ldd             #-1                                                     ; block until input is present
 FFFFEFD3 001                             fcb             MF_INCH
 FFFFEFD4 0C1006                          cmpb    #ACK
 FFFFEFD6 026FB3                          bne             xm_send4                                ; not an ACK then resend the record
 FFFFEFD8 07C0009FA                       inc             xm_packetnum            ; increment packet number
 FFFFEFDB 030080                          leax    128,x                                           ; advance buffer pointer
 FFFFEFDD 0BC000926                       cmpx    mon_r2+2
 FFFFEFE0 025FA9                          blo             xm_send4                                ; go send next record
 FFFFEFE2 0C6004                          ldb             #EOT                                            ; send end of transmission
 FFFFEFE4 03F                             swi
 FFFFEFE5 002                             fcb             MF_OUTCH
 FFFFEFE6 03F                             swi
 FFFFEFE7 002                             fcb             MF_OUTCH
 FFFFEFE8 03F                             swi
 FFFFEFE9 002                             fcb             MF_OUTCH
 FFFFEFEA 039                             rts
 
                              ; ------------------------------------------------------------------------------
                              ; Get a byte, checking for a receive timeout.
                              ;
                              ; Returns:
                              ;               accb = byte (0 to 255) or -1 if timed out
                              ; ------------------------------------------------------------------------------
 
                              xm_getbyte:
                              xm_gb1:
 FFFFEFEB 01507DFFFFFC020                 tst             xm_timer                ; check the timeout - 2048 ticks (3 seconds approx.)
 FFFFEFF0 02B009                          bmi             xm_gb2
 FFFFEFF2 04F                             clra                                                    ; non-blocking
 FFFFEFF3 05F                             clrb
 FFFFEFF4 03F                             swi     
 FFFFEFF5 001                             fcb             MF_INCH                 ; try and get a character
 FFFFEFF6 02BFF3                          bmi             xm_gb1                  ; if no character, try again
 FFFFEFF8 08D1BC                          bsr             xm_outbyteAsHex
 FFFFEFFA 039                             rts
                              xm_gb2:
 FFFFEFFB 0C6FFF                          ldb             #-1
 FFFFEFFD 039                             rts
 
                              ; ------------------------------------------------------------------------------
                              ; XModem Receive
                              ;
                              ; Parameters:
                              ;               none
                              ; Modifies:
                              ;               All
                              ;       Returns:
                              ;               none
                              ; ------------------------------------------------------------------------------
 
                              xm_ReceiveStart:
 FFFFEFFE 017FFF1C2                       lbsr    Delay3s                         ; give a little bit of time for sender
*** warning 1: Long branch within short branch range could be optimized
 FFFFF001 017FFF1BF                       lbsr    Delay3s
*** warning 1: Long branch within short branch range could be optimized
 FFFFF004 017FFF1BC                       lbsr    Delay3s
*** warning 1: Long branch within short branch range could be optimized
 FFFFF007 0170005F7                       lbsr    GetNumber                       ; Get the transfer address
 FFFFF00A 05D                             tstb                                                            ; Make sure we got a value
 FFFFF00B 1270003B4                       lbeq    Monitor
 FFFFF00E 0BE000912                       ldx             mon_numwka+2    ; X = transfer address
 FFFFF011 07F0009FA                       clr             xm_packetnum    ; initialize
 FFFFF014 086043                          lda             #'C'                                    ; try for CRC first
 FFFFF016 0B70009F5                       sta             xm_protocol
                              xm_receive:
 FFFFF019 086002                          lda             #2                                              ; number of times to retry -1
                              xm_rcv5:
 FFFFF01B 0F60009F5                       ldb             xm_protocol             ; indicate we want a transfer (send protocol byte)
 FFFFF01E 03F                             swi
 FFFFF01F 00D                             fcb             MF_SerialPutchar
                              xm_rcv4:
 FFFFF020 01507FFFFFFC020                 clr             xm_timer                ; clear the timeout
                              xm_rcv1:
 FFFFF025 08DFC4                          bsr             xm_getbyte
 FFFFF027 05D                             tstb
 FFFFF028 02B0A1                          bmi             xm_retry1               ; timeout on protocol id?
 FFFFF02A 0C1001                          cmpb    #SOH                            ; it should be start of a transfer
 FFFFF02C 027012                          beq             xm_SOH
 FFFFF02E 0C1004                          cmpb    #EOT
 FFFFF030 027092                          beq             xm_EOT                  ; or end of transfer (EOT)
 FFFFF032 0C1018                          cmpb    #CAN
 FFFFF034 027FE3                          beq             xm_receive      ; might be a cancel
 FFFFF036 0C1017                          cmpb    #ETB
 FFFFF038 02708A                          beq             xm_EOT
                              xm_rcv_nak:                                     ; wasn't a valid start so
 FFFFF03A 0C6015                          ldb             #NAK                            ; send a NAK
 FFFFF03C 03F                             swi
 FFFFF03D 00D                             fcb             MF_SerialPutchar        ; and try again
 FFFFF03E 020FE0                          bra             xm_rcv4
                              xm_SOH:
 FFFFF040 08DFA9                          bsr             xm_getbyte      ; get packet number
 FFFFF042 02B078                          bmi             xm_rcv_to1
 FFFFF044 0F70009FB                       stb             xm_packetnum+1
 FFFFF047 034004                          pshs    b                                               ; save it
 FFFFF049 08DFA0                          bsr             xm_getbyte      ; get complement of packet number
 FFFFF04B 02B06D                          bmi             xm_rcv_to2
 FFFFF04D 0EBE04                          addb    ,s                                      ; add the two values
 FFFFF04F 0C40FF                          andb    #$FF                            ; the sum should be $FF
 FFFFF051 0C00FF                          subb    #$FF
 FFFFF053 0F70009F6                       stb             xm_flag                 ; should be storing a zero if there is no error
 FFFFF056 18E000000                       ldy             #0                                      ; y = payload byte counter
 FFFFF059 01F013                          tfr             x,u
                              xm_rcv2:
 FFFFF05B 08DF8E                          bsr             xm_getbyte
 FFFFF05D 02B05D                          bmi             xm_rcv_to1
 FFFFF05F 0E7C00                          stb             ,u+                                     ; store the byte to memory
 FFFFF061 031201                          iny
 FFFFF063 18C000080                       cmpy    #128                            ; 128 bytes per payload
 FFFFF066 025FF3                          blo             xm_rcv2
 FFFFF068 08DF81                          bsr             xm_getbyte      ; get checksum or CRC byte
 FFFFF06A 02B050                          bmi             xm_rcv_to1
 FFFFF06C 0F70009FC                       stb             xm_tmp                  ; stuff checksum/CRC byte
 FFFFF06F 0F60009F5                       ldb             xm_protocol
 FFFFF072 0C1043                          cmpb    #'C'
 FFFFF074 026022                          bne             xm_rcv_chksum
 FFFFF076 08DF73                          bsr             xm_getbyte      ; get low order CRC byte
 FFFFF078 02B042                          bmi             xm_rcv_to1
 FFFFF07A 0B60009FC                       lda             xm_tmp                  ; get the high byte
 FFFFF07D 058                             aslb                                                    ; prepare to combine high and low order
 FFFFF07E 058                             aslb
 FFFFF07F 058                             aslb
 FFFFF080 058                             aslb
 FFFFF081 044                             lsra                                                    ; shift low nybble of acca into accb
 FFFFF082 056                             rorb
 FFFFF083 044                             lsra
 FFFFF084 056                             rorb
 FFFFF085 044                             lsra
 FFFFF086 056                             rorb
 FFFFF087 044                             lsra
 FFFFF088 056                             rorb
 FFFFF089 08400F                          anda    #$00F                                   ; mask off any extra bits
 FFFFF08B 0FD0009F8                       std     xm_tmp2
 FFFFF08E 08D09F                          bsr             xm_calc_crc             ; compute the CRC-16 for the received data
 FFFFF090 0FC0009FE                       ldd             xm_crc                          ; and compare to received value
 FFFFF093 1B30009F8                       cmpd    xm_tmp2
 FFFFF096 020008                          bra             xm_rcv3
                              xm_rcv_chksum:
 FFFFF098 08D083                          bsr             xm_calc_checksum
 FFFFF09A 0F60009F7                       ldb             xm_checksum
 FFFFF09D 0F10009FC                       cmpb    xm_tmp                          ; where we stuffed the byte
                              xm_rcv3:
 FFFFF0A0 026F98                          bne             xm_rcv_nak              ; if not the same, NAK
 FFFFF0A2 07D0009F6                       tst             xm_flag
 FFFFF0A5 026F93                          bne             xm_rcv_nak              ; bad packet number?
 FFFFF0A7 0C6006                          ldb             #ACK                                    ; packet recieved okay, send back an ACK
 FFFFF0A9 03F                             swi
 FFFFF0AA 00D                             fcb             MF_SerialPutchar
 FFFFF0AB 0F60009FB                       ldb             xm_packetnum+1  ; did we receive the same packet
 FFFFF0AE 0F10009FA                       cmpb    xm_packetnum
 FFFFF0B1 027F6D                          beq             xm_rcv4                         ; same packet received, dont update buffer pointer
 FFFFF0B3 0F70009FA                       stb             xm_packetnum    ; update last seen packet number
 FFFFF0B6 030080                          leax    128,x                                   ; increment buffer pointer
 FFFFF0B8 020F66                          bra             xm_rcv4                         ; and go back for next packet
                              xm_rcv_to2:
 FFFFF0BA 032601                          leas    1,s                                             ; get rid of stacked byte
                              xm_rcv_to1:
 FFFFF0BC 0CCFFF0E4                       ldd             #msgXmTimeout
 FFFFF0BF 03F                             swi
 FFFFF0C0 004                             fcb             MF_DisplayString
 FFFFF0C1 0160002FE                       lbra    Monitor
                              xm_EOT:                                                         ; end of transmission received, return
 FFFFF0C4 0C6006                          ldb             #ACK                                    ; ACK the EOT
 FFFFF0C6 03F                             swi
 FFFFF0C7 00D                             fcb             MF_SerialPutchar
 FFFFF0C8 0160002F7                       lbra    Monitor
                              xm_retry1:
 FFFFF0CB 04A                             deca
 FFFFF0CC 02AF4D                          bpl             xm_rcv5
 FFFFF0CE 0B60009F5                       lda             xm_protocol
 FFFFF0D1 081015                          cmpa    #NAK                                    ; are we already lowered down to checksum protocol?
 FFFFF0D3 027007                          beq             xm_noTransmitter        ; did we try both checksum and CRC?
 FFFFF0D5 086015                          lda             #NAK
 FFFFF0D7 0B70009F5                       sta             xm_protocol
 FFFFF0DA 020F3D                          bra             xm_receive
                              xm_noTransmitter:
 FFFFF0DC 0CCFFF0F8                       ldd             #msgXmNoTransmitter
 FFFFF0DF 03F                             swi
 FFFFF0E0 004                             fcb             MF_DisplayString
 FFFFF0E1 0160002DE                       lbra    Monitor 
 
                              msgXmTimeout:
 FFFFF0E4 05806D06F06406506D03A           fcb             "Xmodem: timed out",CR,LF,0
 FFFFF0EB 02007406906D065064020
 FFFFF0F2 06F07507400D00A000
                              msgXmNoTransmitter:
 FFFFF0F8 05804D06F06406506D03A           fcb             "XModem: transmitter not responding",CR,LF,0
 FFFFF0FF 02007407206106E07306D
 FFFFF106 06907407406507202006E
 FFFFF10D 06F074020072065073070
 FFFFF114 06F06E06406906E06700D
 FFFFF11B 00A000
 
                              ; ------------------------------------------------------------------------------
                              ; Calculate checksum value. The checksum is simply the low order eight bits of
                              ; the sum of all the bytes in the payload area.
                              ;
                              ; Stack space:
                              ;               two words
                              ;       Modifies:
                              ;               xm_checksum             contains the checksum value for the record
                              ; Parameters:
                              ;               X = buffer address
                              ;       Returns:
                              ;               none
                              ; ------------------------------------------------------------------------------
 
                              xm_calc_checksum:
 FFFFF11D 034016                          pshs    d,x
 FFFFF11F 04F                             clra
 FFFFF120 05F                             clrb
                              xm_cs1:
 FFFFF121 0EB800                          addb    ,x+
 FFFFF123 04C                             inca
 FFFFF124 081080                          cmpa    #128
 FFFFF126 025FF9                          blo             xm_cs1
 FFFFF128 0C40FF                          andb    #$FF
 FFFFF12A 0F70009F7                       stb             xm_checksum
 FFFFF12D 035096                          puls    d,x,pc
 
                              ; ------------------------------------------------------------------------------
                              ; Compute CRC-16 of buffer.
                              ;
                              ;int calcrc(char *ptr, int count)
                              ;{
                              ;    int  crc;
                              ;    char i;
                              ;    crc = 0;
                              ;    while (--count >= 0)
                              ;    {
                              ;        crc = crc ^ (int) (*ptr++ << 8);
                              ;        i = 8;
                              ;        do
                              ;        {
                              ;            if (crc & 0x8000)
                              ;                crc = crc << 1 ^ 0x1021;
                              ;            else
                              ;                crc = crc << 1;
                              ;        } while(--i);
                              ;    }
                              ;    return (crc);
                              ;}
                              ;
                              ; Modifies:
                              ;               xm_crc variable
                              ; Parameters:
                              ;               u = buffer address
                              ; Returns:
                              ;               none
                              ; ------------------------------------------------------------------------------
 
                              xm_calc_crc:
 FFFFF12F 034076                          pshs    d,x,y,u
 FFFFF131 07F0009FE                       clr             xm_crc
 FFFFF134 07F0009FF                       clr             xm_crc+1        
 FFFFF137 0CE000000                       ldu             #0                                      ; u = byte count
                              xm_crc1:
 FFFFF13A 0E6800                          ldb             ,x+                                     ; get byte
 FFFFF13C 07F0009FC                       clr             xm_tmp                  ; save in temp
 FFFFF13F 0F70009FD                       stb             xm_tmp+1
 FFFFF142 0780009FD                       asl             xm_tmp+1                ; shift temp eight bits to left         
 FFFFF145 0790009FC                       rol             xm_tmp
 FFFFF148 0780009FD                       asl             xm_tmp+1
 FFFFF14B 0790009FC                       rol             xm_tmp
 FFFFF14E 0780009FD                       asl             xm_tmp+1
 FFFFF151 0790009FC                       rol             xm_tmp
 FFFFF154 0780009FD                       asl             xm_tmp+1
 FFFFF157 0790009FC                       rol             xm_tmp
 FFFFF15A 0780009FD                       asl             xm_tmp+1
 FFFFF15D 0790009FC                       rol             xm_tmp
 FFFFF160 0780009FD                       asl             xm_tmp+1
 FFFFF163 0790009FC                       rol             xm_tmp
 FFFFF166 0780009FD                       asl             xm_tmp+1
 FFFFF169 0790009FC                       rol             xm_tmp
 FFFFF16C 0780009FD                       asl             xm_tmp+1
 FFFFF16F 0790009FC                       rol             xm_tmp
 FFFFF172 0FC0009FE                       ldd             xm_crc          ; crc = crc ^ tmp
 FFFFF175 0B80009FC                       eora    xm_tmp
 FFFFF178 0F80009FD                       eorb    xm_tmp+1
 FFFFF17B 0FD0009FE                       std             xm_crc
 FFFFF17E 18E000000                       ldy             #0
                              xm_crc4:
 FFFFF181 0F60009FE                       ldb             xm_crc          ; get high byte
 FFFFF184 0C5008                          bitb    #$8                             ; check for $8000
 FFFFF186 02700E                          beq             xm_crc2         ; no? then just go shift
 FFFFF188 0FC0009FE                       ldd             xm_crc          ; load
 FFFFF18B 058                             aslb                                            ; shift
 FFFFF18C 049                             rola
 FFFFF18D 0C8021                          eorb    #$021                   ; and xor
 FFFFF18F 088001                          eora    #$001
 FFFFF191 0FD0009FE                       std             xm_crc          ; store it back
 FFFFF194 020008                          bra             xm_crc3
                              xm_crc2:
 FFFFF196 0FC0009FE                       ldd             xm_crc          ; load
 FFFFF199 058                             aslb                                            ; shift
 FFFFF19A 049                             rola
 FFFFF19B 0FD0009FE                       std             xm_crc          ; and store
                              xm_crc3:
 FFFFF19E 031201                          iny
 FFFFF1A0 18C000008                       cmpy    #8                              ; repeat eight times
 FFFFF1A3 025FDC                          blo             xm_crc4
 FFFFF1A5 033401                          leau    1,u                             ; increment byte count
 FFFFF1A7 283000080                       cmpu    #128
 FFFFF1AA 0FC0009FE                       ldd             xm_crc          ; we want only a 16-bit CRC
 FFFFF1AD 08400F                          anda    #$0F
 FFFFF1AF 0FD0009FE                       std             xm_crc
 FFFFF1B2 025F86                          blo             xm_crc1
 FFFFF1B4 0350F6                          puls    d,x,y,u,pc
 
                              xm_outbyteAsHex:
 FFFFF1B6 034006                          pshs    d
 FFFFF1B8 0FC000800                       ldd             CharOutVec                                              ; get current char out vector
 FFFFF1BB 034006                          pshs    d                                                                                       ; save it
 FFFFF1BD 0CCFFE328                       ldd             #ScreenDisplayChar              ; set output vector to screen display
 FFFFF1C0 0FD000800                       std             CharOUtVec
 FFFFF1C3 0EC602                          ldd             2,s                                                                             ; get passed data
 FFFFF1C5 017FFF27F                       lbsr    DispByteAsHex                                   ; and display on-screen
*** warning 1: Long branch within short branch range could be optimized
 FFFFF1C8 0C6020                          ldb             #' '
 FFFFF1CA 017FFF15B                       lbsr    ScreenDisplayChar
*** warning 1: Long branch within short branch range could be optimized
 FFFFF1CD 035006                          puls    d                                                                                       ; get back old char out vector
 FFFFF1CF 0FD000800                       std             CharOutVec                                              ; and restore it
 FFFFF1D2 035006                          puls    d                                                                                       ; restore input arguments
 FFFFF1D4 039                             rts
 
                                      
 
                              ;------------------------------------------------------------------------------
                              ; Check if there is a keyboard character available. If so return true (<0)
                              ; otherwise return false (0) in accb.
                              ;------------------------------------------------------------------------------
                              ;
                              KeybdCheckForKeyDirect:
 FFFFF1D5 0208B9                          bra             DBGCheckForKey
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              INCH:
 FFFFF1D7 034004                          pshs    b
                              INCH2:
 FFFFF1D9 0150F6FFFFFFF14                 ldb             COREID
 FFFFF1DE 0F1FFC010                       cmpb    IOFocusID       ; if we do not have focus, block
 FFFFF1E1 026FF6                          bne             INCH2                   
                              ;       ldb             #$800                   ; block if no key available, get scancode directly
                              ;       bra             GetKey
                              ;       jsr             [CharInVec]     ; vector is being overwritten somehow
                              ;       lbsr    SerialPeekCharDirect
 FFFFF1E3 017FFFA51                       lbsr    SerialGetChar
*** warning 1: Long branch within short branch range could be optimized
 FFFFF1E6 04D                             tsta
 FFFFF1E7 02B003                          bmi             INCH1                   ; block if no key available
 FFFFF1E9 032601                          leas    1,s                             ; get rid of blocking status
 FFFFF1EB 039                             rts                                                     ; return character
                              INCH1:
 FFFFF1EC 035004                          puls    b                                       ; check blocking status
 FFFFF1EE 05D                             tstb
 FFFFF1EF 02BFE6                          bmi     INCH                    ; if blocking, loop
 FFFFF1F1 0CCFFFFFF                       ldd             #-1                             ; return -1 if no char available
 FFFFF1F4 039                             rts
 
                              INCHE:
 FFFFF1F5 08DFE0                          bsr             INCH
 FFFFF1F7 020007                          bra             INCHEK3
 
                              INCHEK:
 FFFFF1F9 08DFDC                          bsr             INCH
 FFFFF1FB 07DFFCA00                       tst             KeybdEcho
 FFFFF1FE 02700C                          beq             INCHEK1
                              INCHEK3:
 FFFFF200 08100D                          cmpa    #CR
 FFFFF202 026005                          bne             INCHEK2
 FFFFF204 017FFDECB                       lbsr            CRLF
*** warning 1: Long branch within short branch range could be optimized
 FFFFF207 020003                          bra             INCHEK1
                              INCHEK2:
 FFFFF209 017FFF119                       lbsr    DisplayChar
*** warning 1: Long branch within short branch range could be optimized
                              INCHEK1:
 FFFFF20C 039                             rts
 
                              OUTCH:
 FFFFF20D 06E90F000800                    jmp             [CharOutVec]
 
                              ;------------------------------------------------------------------------------
                              ; r1 0=echo off, non-zero = echo on
                              ;------------------------------------------------------------------------------
                              ;
                              SetKeyboardEcho:
 FFFFF211 0F7FFCA00                       stb             KeybdEcho
 FFFFF214 039                             rts
 
 
                              ;------------------------------------------------------------------------------
                              ; Stack Space:
                              ;               2 words
                              ; Parameters:
                              ;               x,d     bitmap of sprites to enable
                              ;------------------------------------------------------------------------------
 
                              ShowSprites:
 FFFFF215 034041                          pshs    ccr,u
 FFFFF217 0CEF086FF                       ldu             #SPRITE_MMU
 FFFFF21A 01A010                          sei
 FFFFF21C 0150FFFFFE38000                 stu             MMU
 FFFFF221 09F3C0                          stx             SPRITE_EN
 FFFFF223 0DD3C2                          std             SPRITE_EN+2
 FFFFF225 0CE000F00                       ldu             #$000F00
 FFFFF228 0150FFFFFE38000                 stu             MMU
 FFFFF22D 0350C1                          puls    ccr,u,pc
 
                              ;==============================================================================
                              ; Femtiki Operating System.
                              ;==============================================================================
 
                              OSCallTbl:
 FFFFF22F 000000                          fcw             0
 FFFFF231 000000                          fcw             0
 FFFFF233 000000                          fcw             0
 FFFFF235 000000                          fcw             0
 FFFFF237 000000                          fcw             0
 FFFFF239 000000                          fcw             0
 FFFFF23B 000000                          fcw             0
 FFFFF23D 000000                          fcw             0
 FFFFF23F 000000                          fcw             0
 FFFFF241 000000                          fcw             0
 FFFFF243 000000                          fcw             0
 FFFFF245 000000                          fcw             0
 FFFFF247 000000                          fcw             0
 FFFFF249 000000                          fcw             0
 FFFFF24B 000000                          fcw             0
 FFFFF24D 000000                          fcw             0
 FFFFF24F 000000                          fcw             0
 FFFFF251 000000                          fcw             0
 FFFFF253 000000                          fcw             0
 FFFFF255 000000                          fcw             0
 FFFFF257 000000                          fcw             0
 FFFFF259 000000                          fcw             0
 FFFFF25B FFF278                          fcw             ReleaseIOFocus
 FFFFF25D 000000                          fcw             0
 FFFFF25F FFF261                          fcw             RequestIOFocus
 
                              NumOSFuncs      EQU     (*-OSCallTbl)/2
 
                              RequestIOFocus:
 FFFFF261 0150F6FFFFFFF14                 ldb             COREID
 FFFFF266 08EFFC000                       ldx             #IOFocusList
 FFFFF269 03A                             abx
 FFFFF26A 0A7804                          sta             ,x
 FFFFF26C 07DFFC010                       tst             IOFocusID
 FFFFF26F 12600099F                       lbne    oscx
 FFFFF272 0F7FFC010                       stb             IOFocusID
 FFFFF275 016000999                       lbra    oscx
 
                              ReleaseIOFocus:
 FFFFF278 0150F6FFFFFFF14                 ldb             COREID
 FFFFF27D 08EFFC000                       ldx             #IOFocusList
 FFFFF280 03A                             abx
 FFFFF281 06F804                          clr             ,x                                              ; clear the request indicator
 FFFFF283 017FFEF91                       lbsr    CopyScreenToVirtualScreen
*** warning 1: Long branch within short branch range could be optimized
 FFFFF286 0F1FFC010                       cmpb    IOFocusID                       ; are we the one with the focus?
 FFFFF289 126000985                       lbne    oscx
                                      ; We had the focus, so now a new core needs the focus.
                                      ; Search the focus list for a requestor. If no requester
                                      ; is found, give focus to core #1.
 FFFFF28C 08600F                          lda             #15
                              riof2:
 FFFFF28E 05C                             incb
 FFFFF28F 0C400F                          andb    #15
 FFFFF291 03A                             abx
 FFFFF292 06D804                          tst             ,x
 FFFFF294 026009                          bne             riof1
 FFFFF296 04A                             deca
 FFFFF297 026FF5                          bne             riof2
                                      ; If no focus is requested by anyone, give to core #1
 FFFFF299 0C6001                          ldb             #1
 FFFFF29B 086018                          lda             #24
 FFFFF29D 0A7804                          sta             ,x
                              riof1:
 FFFFF29F 0F7FFC010                       stb             IOFocusID
 FFFFF2A2 017FFEF3B                       lbsr    CopyVirtualScreenToScreen
*** warning 1: Long branch within short branch range could be optimized
 FFFFF2A5 016000969                       lbra    oscx
                                              
                                      
                              ;==============================================================================
                              ;==============================================================================
 
                              ;------------------------------------------------------------------------------
                              ; Seed the random number generator. All channels are seeded with the same
                              ; value.
                              ;
                              ; Parameters:
                              ;               d = 'z' part of seed
                              ;               x = 'w' part of seed
                              ; Returns:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              mon_srand:
 FFFFF2A8 18E000000                       ldy     #0
 FFFFF2AB 034001                          pshs    ccr
 FFFFF2AD 01F003                          tfr             d,u
 FFFFF2AF 01A010                          sei
 FFFFF2B1 0CC71B6FF                       ldd             #PRNG_MMU
 FFFFF2B4 0150FDFFFE38000                 std             MMU
                              mon_srand1:
 FFFFF2B9 19F004                          sty             4                               ; select channel
 FFFFF2BB 00F008                          clr             8
 FFFFF2BD 00F009                          clr     9
 FFFFF2BF 0DF00A                          stu             10                              ; update low half of value
 FFFFF2C1 00F00C                          clr     12
 FFFFF2C3 00F00D                          clr     13
 FFFFF2C5 09F00E                          stx             14                              ; update low half of value
 FFFFF2C7 031201                          iny
 FFFFF2C9 18C000400                       cmpy    #$400                           ; 1k channels
 FFFFF2CC 025FEB                          blo             mon_srand1
 FFFFF2CE 0CC000F00                       ldd             #$000F00
 FFFFF2D1 0150FDFFFE38000                 std             MMU
 FFFFF2D6 035081                          puls    ccr,pc
 
                              ;------------------------------------------------------------------------------
                              ; Get a random number and generate the next one.
                              ;
                              ; Parameters:
                              ;               d = channel to use
                              ; Returns:
                              ;               x,d = 36 bit random value
                              ;------------------------------------------------------------------------------
 
                              mon_rand:
 FFFFF2D8 034041                          pshs    u,ccr
 FFFFF2DA 0CE71B6FF                       ldu             #PRNG_MMU
 FFFFF2DD 01A010                          sei
 FFFFF2DF 0150FFFFFE38000                 stu             MMU
 FFFFF2E4 0DD004                          std             4                               ; select channel
 FFFFF2E6 09E000                          ldx             0
 FFFFF2E8 0DC002                          ldd             2
 FFFFF2EA 0D7003                          stb             3                               ; trigger calc of next number
 FFFFF2EC 0CE000F00                       ldu             #$000F00
 FFFFF2EF 0150FFFFFE38000                 stu             MMU
 FFFFF2F4 0350C1                          puls    u,ccr,pc
 
                              ;==============================================================================
                              ; System Monitor
                              ;==============================================================================
 
                              ; Command Tables
 
                              cmdTable1:
 FFFFF2F6 03C83E                          fcb             '<','>'+$800
 FFFFF2F8 04282B                          fcb             'B','+'+$800
 FFFFF2FA 04282D                          fcb             'B','-'+$800
 FFFFF2FC 042043844                       fcb             "BC",'D'+$800
 FFFFF2FF 044049856                       fcb             "DI",'V'+$800
 FFFFF302 044852                          fcb             'D','R'+$800
 FFFFF304 844                             fcb             'D'+$800
 FFFFF305 83A                             fcb             ':'+$800
 FFFFF306 046049847                       fcb             "FI",'G'+$800
 FFFFF309 04604984C                       fcb             "FI",'L'+$800
 FFFFF30C 04684C                          fcb             'F','L'+$800
 FFFFF30E 84A                             fcb             'J'+$800
 FFFFF30F 05204104D054045053854           fcb             "RAMTES",'T'+$800
 FFFFF316 053050844                       fcb             "SP",'D'+$800
 FFFFF319 054049852                       fcb             "TI",'R'+$800
 FFFFF31C 855                             fcb             'U'+$800
 FFFFF31D 065078069874                    fcb             "exi",'t'+$800
 FFFFF321 83F                             fcb             '?'+$800
 FFFFF322 04304C853                       fcb             "CL",'S'+$800
 FFFFF325 043031839                       fcb             "C1",'9'+$800
 FFFFF328 04A044834                       fcb             "JD",'4'+$800
 FFFFF32B 05804D852                       fcb             "XM",'R'+$800
 FFFFF32E 05804D853                       fcb             "XM",'S'+$800
 FFFFF331 052841                          fcb             'R','A'+$800
 FFFFF333 052842                          fcb             'R','B'+$800
 FFFFF335 052044050852                    fcb             "RDP",'R'+$800
 FFFFF339 052844                          fcb             'R','D'+$800
 FFFFF33B 052858                          fcb             'R','X'+$800
 FFFFF33D 052859                          fcb             'R','Y'+$800
 FFFFF33F 052855                          fcb             'R','U'+$800
 FFFFF341 052853                          fcb             'R','S'+$800
 FFFFF343 052043043852                    fcb             "RCC",'R'+$800
 FFFFF347 052050843                       fcb             "RP",'C'+$800
 FFFFF34A 04C842                          fcb             'L','B'+$800
                              ;       fcb             "MU",'L'+$800
 FFFFF34C 000000                          fcw             0
 
                              cmdTable2:
 FFFFF34E FFF49A                          fcw             Redirect
 FFFFF350 FFF4DC                          fcw             MonArmBreakpoint
 FFFFF352 FFF4E7                          fcw             MonDisarmBreakpoint
 FFFFF354 FFD447                          fcw             BCDArith
 FFFFF356 FFFD65                          fcw             DivTest
 FFFFF358 FFF954                          fcw             DumpRegs
 FFFFF35A FFF88B                          fcw             DumpMemory
 FFFFF35C FFF8E7                          fcw             EditMemory
 FFFFF35E FE0000                          fcw             $FE0000                                 ; FIG forth
 FFFFF360 FFF92A                          fcw             FillMemory
 FFFFF362 FFFB09                          fcw             DumpIOFocusList
 FFFFF364 FFFA92                          fcw             jump_to_code
 FFFFF366 FFD400                          fcw             $FFD400
 FFFFF368 FF8000                          fcw             $FF8000                                 ; sprite demo
 FFFFF36A FFE541                          fcw             rtc_read
 FFFFF36C FF8003                          fcw             $FF8003                                 ; unassembler
 FFFFF36E FFFBFA                          fcw             xitMonitor
 FFFFF370 FFF4C0                          fcw             PromptHelp
 FFFFF372 FFF4C8                          fcw             PromptClearscreen
 FFFFF374 FFEEC0                          fcw             C19Loader
 FFFFF376 FFD400                          fcw             $FFD400
 FFFFF378 FFEFFE                          fcw             xm_ReceiveStart
 FFFFF37A FFEF6E                          fcw             xm_SendStart
 FFFFF37C FFF9F6                          fcw             SetRegA
 FFFFF37E FFFA05                          fcw             SetRegB
 FFFFF380 FFFA5F                          fcw             SetRegDPR
 FFFFF382 FFFA14                          fcw             SetRegD
 FFFFF384 FFFA23                          fcw             SetRegX
 FFFFF386 FFFA32                          fcw             SetRegY
 FFFFF388 FFFA41                          fcw             SetRegU
 FFFFF38A FFFA50                          fcw             SetRegS
 FFFFF38C FFFA6E                          fcw             SetRegCCR
 FFFFF38E FFFA7D                          fcw             SetRegPC
 FFFFF390 FFFD3A                          fcw             ListBreakpoints
                              ;       fcw             MulTest
 
                              CmdPrompt:
 FFFFF392 017FFDD3D                       lbsr    CRLF
*** warning 1: Long branch within short branch range could be optimized
 FFFFF395 0C6024                          ldb             #'$'
 FFFFF397 017FFFE73                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 FFFFF39A 016FFFE70                       lbra    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 
                              msgF09Starting:
 FFFFF39D 04606506D07406906B069           fcb             "Femtiki F09 Multi-core OS Starting",CR,LF,0
 FFFFF3A4 02004603003902004D075
 FFFFF3AB 06C07406902D06306F072
 FFFFF3B2 06502004F053020053074
 FFFFF3B9 06107207406906E06700D
 FFFFF3C0 00A000
 
                              Monitor:
 FFFFF3C2 0CCF1F6FF                       ldd             #PIC_MMU
 FFFFF3C5 0150FDFFFE38000                 std             MMU
 FFFFF3CA 08601F                          lda             #31                                             ; Timer is IRQ #31
 FFFFF3CC 097010                          sta             16                                              ; register 16 is edge sense reset reg   
 FFFFF3CE 0CC000F00                       ldd             #$000F00
 FFFFF3D1 0150FDFFFE38000                 std             MMU
 FFFFF3D6 01C0EF                          andcc   #$EF                                    ; SWI disables interrupts, re-enable them
 FFFFF3D8 0FC00092C                       ldd             mon_init                        ; check special code to see if monitor has been initialized
 FFFFF3DB 18312D687                       cmpd    #1234567
 FFFFF3DE 02704D                          beq             mon1
 FFFFF3E0 07F000810                       clr             BreakpointFlag
 FFFFF3E3 07F000811                       clr             NumSetBreakpoints
 FFFFF3E6 0CC00007B                       ldd             #123
 FFFFF3E9 08E00028E                       ldx             #654
 FFFFF3EC 017FFFEB9                       lbsr    mon_srand
*** warning 1: Long branch within short branch range could be optimized
 FFFFF3EF 0CCFFF39D                       ldd             #msgF09Starting
 FFFFF3F2 017FFEFF1                       lbsr    DisplayString
*** warning 1: Long branch within short branch range could be optimized
 FFFFF3F5 0CCFFF66E                       ldd             #HelpMsg
 FFFFF3F8 017FFEFEB                       lbsr    DisplayString
*** warning 1: Long branch within short branch range could be optimized
 FFFFF3FB 0CCFFF392                       ldd             #CmdPrompt
 FFFFF3FE 0FD000808                       std             CmdPromptJI
 FFFFF401 0CCFFF655                       ldd             #DisplayErr
 FFFFF404 0FD00080C                       std             MonErrVec
 FFFFF407 0CC0063FF                       ldd             #$63FF                  ; default app stack
 FFFFF40A 0FD000908                       std             mon_SSAVE
 FFFFF40D 07F00090E                       clr             mon_DPRSAVE     ;
 FFFFF410 01F0A8                          tfr             ccr,a
 FFFFF412 0B700090F                       sta             mon_CCRSAVE
 FFFFF415 07F00090A                       clr             mon_PCSAVE
 FFFFF418 0CCFFF3C2                       ldd             #Monitor
 FFFFF41B 0FD00090B                       std             mon_PCSAVE+1
 FFFFF41E 07F000902                       clr             mon_XSAVE
 FFFFF421 07F000904                       clr             mon_YSAVE
 FFFFF424 07F000906                       clr             mon_USAVE
 FFFFF427 0CC12D687                       ldd             #1234567
 FFFFF42A 0FD00092C                       std             mon_init
                              mon1:
 FFFFF42D 03280F006FFF                    leas    $6FFF                           ; reset stack pointer
 FFFFF431 05F                             clrb                                                    ; turn off keyboard echo
 FFFFF432 017FFFDDC                       lbsr    SetKeyboardEcho
*** warning 1: Long branch within short branch range could be optimized
                                      ; Reset IO vectors
 FFFFF435 0CCFFEC8F                       ldd             #SerialPeekCharDirect
 FFFFF438 0FD000804                       std             CharInVec
 FFFFF43B 0CCFFE325                       ldd             #DisplayChar
 FFFFF43E 0FD000800                       std             CharOutVec
 FFFFF441 0CCFFF392                       ldd             #CmdPrompt
 FFFFF444 0FD000808                       std             CmdPromptJI
                              ;       jsr             RequestIOFocus
                              PromptLn:
 FFFFF447 0AD90F000808                    jsr             [CmdPromptJI]
 
                              ; Get characters until a CR is keyed
                                      
                              Prompt3:
 FFFFF44B 0CCFFFFFF                       ldd             #-1                                     ; block until key present
 FFFFF44E 017FFFD86                       lbsr    INCH
*** warning 1: Long branch within short branch range could be optimized
 FFFFF451 04D                             tsta                                                    ; should not get this with blocking
 FFFFF452 02BFF7                          bmi             Prompt3
 FFFFF454 0C100D                          cmpb    #CR                                     ; carriage return?
 FFFFF456 027005                          beq             Prompt1 
 FFFFF458 017FFFDB2                       lbsr    OUTCH                           ; spit out the character
*** warning 1: Long branch within short branch range could be optimized
 FFFFF45B 020FEE                          bra             Prompt3                 ; and keep going
 
                              ; Process the screen line that the CR was keyed on
                              ;
                              Prompt1:
 FFFFF45D 0CC005050                       ldd             #$5050
 FFFFF460 0150FDFFFE60001                 std             LEDS
                              ;       ldb             RunningID
                              ;       cmpb    #61
                              ;       bhi             Prompt3
 FFFFF465 00F111                          clr             CursorCol                       ; go back to the start of the line
 FFFFF467 017FFEE96                       lbsr    CalcScreenLoc   ; calc screen memory location
*** warning 1: Long branch within short branch range could be optimized
 FFFFF46A 01F002                          tfr             d,y
                              skipDollar:
 FFFFF46C 08D067                          bsr             MonGetNonSpace
 FFFFF46E 0C1024                          cmpb    #'$'
 FFFFF470 027FFA                          beq             skipDollar              ; skip over '$' prompt character
 
                              ; Dispatch based on command
                              ;
 FFFFF472 0313FF                          dey
 FFFFF474 01F023                          tfr             y,u                                                     ; save off input position
 FFFFF476 05F                             clrb
 FFFFF477 08EFFF2F6                       ldx             #cmdTable1
                              parseCmd1:
 FFFFF47A 0A6A00                          lda             ,y+                                                     ; get input character
 FFFFF47C 06D804                          tst             ,x                                                      ; test for end of command
 FFFFF47E 02B00F                          bmi             endOfWord                               ;
 FFFFF480 0A1800                          cmpa    ,x+                                                     ; does input match command?
 FFFFF482 027FF6                          beq             parseCmd1
                              scanNextWord:
 FFFFF484 06D800                          tst             ,x+
 FFFFF486 027F3A                          beq             Monitor                                 ; if end of table reached, not a command
 FFFFF488 02AFFA                          bpl             scanNextWord
 FFFFF48A 05C                             incb
 FFFFF48B 01F032                          tfr             u,y                                                     ; reset input pointer
 FFFFF48D 020FEB                          bra             parseCmd1                               ; try again
                              endOfWord:
 FFFFF48F 0A8804                          eora    ,x
 FFFFF491 048                             asla
 FFFFF492 026FF0                          bne             scanNextWord
                                      ; we found the command in the table
 FFFFF494 058                             aslb                                                                    ; b = word index
 FFFFF495 08EFFF34E                       ldx             #cmdTable2
 FFFFF498 06E905                          jmp             [b,x]                                           ; execute command
 
                              Redirect:
 FFFFF49A 08D034                          bsr             MonGetch
 FFFFF49C 0C1073                          cmpb    #'s'
 FFFFF49E 02600E                          bne             Prompt2a
 FFFFF4A0 0CCFFEC8F                       ldd             #SerialPeekCharDirect
 FFFFF4A3 0FD000804                       std             CharInVec
 FFFFF4A6 0CCFFECD0                       ldd             #SerialPutChar
 FFFFF4A9 0FD000800                       std             CharOutVec
 FFFFF4AC 020F14                          bra             Monitor
                              Prompt2a:
 FFFFF4AE 0C1063                          cmpb    #'c'
 FFFFF4B0 026F10                          bne             Monitor
 FFFFF4B2 0CCFFEA92                       ldd             #GetKey
 FFFFF4B5 0FD000804                       std             CharInVec
 FFFFF4B8 0CCFFE325                       ldd             #DisplayChar
 FFFFF4BB 0FD000800                       std             CharOutVec
 FFFFF4BE 020F02                          bra             Monitor
 
                              PromptHelp:
 FFFFF4C0 0CCFFF66E                       ldd             #HelpMsg
 FFFFF4C3 017FFEF20                       lbsr    DisplayString
*** warning 1: Long branch within short branch range could be optimized
 FFFFF4C6 020EFA                          bra             Monitor
 
                              PromptClearscreen:
 FFFFF4C8 017FFED7C                       lbsr    ClearScreen
*** warning 1: Long branch within short branch range could be optimized
 FFFFF4CB 017FFEDF0                       lbsr    HomeCursor
*** warning 1: Long branch within short branch range could be optimized
 FFFFF4CE 020EF2                          bra             Monitor
 
                              MonGetch:
 FFFFF4D0 0E6A04                          ldb             ,y
 FFFFF4D2 031201                          iny
 FFFFF4D4 039                             rts
 
                              MonGetNonSpace:
 FFFFF4D5 08DFF9                          bsr             MonGetCh
 FFFFF4D7 0C1020                          cmpb    #' '
 FFFFF4D9 027FFA                          beq             MonGetNonSpace
 FFFFF4DB 039                             rts
 
                              MonArmBreakpoint:
 FFFFF4DC 01700077A                       lbsr    ArmBreakpoint
 FFFFF4DF 0C6FFF                          ldb             #$FFF
 FFFFF4E1 0F7000810                       stb             BreakpointFlag
 FFFFF4E4 016FFFEDB                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              MonDisarmBreakpoint:
 FFFFF4E7 0170007EF                       lbsr    DisarmBreakpoint
 FFFFF4EA 016FFFED5                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
 
                              ;------------------------------------------------------------------------------
                              ; Ignore blanks in the input
                              ; Y = text pointer
                              ; D destroyed
                              ;------------------------------------------------------------------------------
                              ;
                              ignBlanks:
                              ignBlanks1:
 FFFFF4ED 08DFE1                          bsr             MonGetch
 FFFFF4EF 0C1020                          cmpb    #' '
 FFFFF4F1 027FFA                          beq             ignBlanks1
 FFFFF4F3 0313FF                          dey
 FFFFF4F5 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Multiply number in work area by 10.
                              ;------------------------------------------------------------------------------
                              Times10:
 FFFFF4F6 034006                          pshs    d
 FFFFF4F8 0FC000910                       ldd             mon_numwka              ; make a copy of the number
 FFFFF4FB 0FD000918                       std             mon_numwka+8
 FFFFF4FE 0FC000912                       ldd             mon_numwka+2
 FFFFF501 0FD00091A                       std             mon_numwka+10
 FFFFF504 08D05B                          bsr             shl_numwka              ; shift left = *2
 FFFFF506 08D059                          bsr             shl_numwka              ; shift left = *4
 FFFFF508 0FC000912                       ldd             mon_numwka+2    ; add in original value
 FFFFF50B 0F300091A                       addd    mon_numwka+10   ; = *5
 FFFFF50E 0F6000911                       ldb             mon_numwka+1
 FFFFF511 0F9000919                       adcb    mon_numwka+9
 FFFFF514 0F7000911                       stb             mon_numwka+1
 FFFFF517 0B6000910                       lda             mon_numwka+0
 FFFFF51A 0B9000918                       adca    mon_numwka+8
 FFFFF51D 0B7000910                       sta             mon_numwka+0
 FFFFF520 08D03F                          bsr             shl_numwka              ; shift left = * 10
 FFFFF522 035086                          puls    d,pc
                                      
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              GetTwoParams:
 FFFFF524 08DFC7                          bsr             ignBlanks
 FFFFF526 08D0D9                          bsr             GetNumber                       ; get start address of dump
 FFFFF528 0FC000910                       ldd             mon_numwka
 FFFFF52B 0FD000920                       std             mon_r1
 FFFFF52E 0FC000912                       ldd             mon_numwka+2
 FFFFF531 0FD000922                       std             mon_r1+2
 FFFFF534 08DFB7                          bsr             ignBlanks
 FFFFF536 08D0C9                          bsr             GetNumber                       ; get end address of dump
 FFFFF538 0FC000910                       ldd             mon_numwka
 FFFFF53B 0FD000924                       std             mon_r2
 FFFFF53E 0FC000912                       ldd             mon_numwka+2
 FFFFF541 0FD000926                       std             mon_r2+2
 FFFFF544 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Get a range, the end must be greater or equal to the start.
                              ;------------------------------------------------------------------------------
                              GetRange:
 FFFFF545 08DFDD                          bsr             GetTwoParams
 FFFFF547 0FC000926                       ldd             mon_r2+2
 FFFFF54A 0B3000922                       subd    mon_r1+2
 FFFFF54D 0FC000924                       ldd             mon_r2
 FFFFF550 0F2000921                       sbcb    mon_r1+1
 FFFFF553 0B2000920                       sbca    mon_r1
 FFFFF556 124000007                       lbcc    grng1
 FFFFF559 0AD90F00080C                    jsr             [MonErrVec]
 FFFFF55D 016FFFE62                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              grng1:
 FFFFF560 039                             rts
 
                              shl_numwka:
 FFFFF561 078000913                       asl             mon_numwka+3
 FFFFF564 079000912                       rol             mon_numwka+2
 FFFFF567 079000911                       rol             mon_numwka+1
 FFFFF56A 079000910                       rol             mon_numwka
 FFFFF56D 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Get a hexidecimal number. Maximum of twelve digits.
                              ;
                              ; Modifies:
                              ;       Y = text pointer (updated)
                              ;       D = number of digits
                              ;       mon_numwka contains number
                              ;------------------------------------------------------------------------------
                              ;
                              GetHexNumber:
 FFFFF56E 14F                             clrd
 FFFFF56F 0FD000910                       std             mon_numwka      ; zero out work area
 FFFFF572 0FD000912                       std             mon_numwka+2
 FFFFF575 034010                          pshs    x
 FFFFF577 08E000000                       ldx             #0                                      ; max 12 eight digits
                              gthxn2:
 FFFFF57A 08DF54                          bsr             MonGetch
 FFFFF57C 08D091                          bsr             AsciiToHexNybble
 FFFFF57E 0C1FFF                          cmpb    #-1
 FFFFF580 027017                          beq             gthxn1
 FFFFF582 08DFDD                          bsr             shl_numwka
 FFFFF584 08DFDB                          bsr             shl_numwka
 FFFFF586 08DFD9                          bsr             shl_numwka
 FFFFF588 08DFD7                          bsr             shl_numwka
 FFFFF58A 0C400F                          andb    #$0f
 FFFFF58C 0FA000913                       orb             mon_numwka+3
 FFFFF58F 0F7000913                       stb             mon_numwka+3
 FFFFF592 030001                          inx
 FFFFF594 08C00000C                       cmpx    #12
 FFFFF597 025FE1                          blo             gthxn2
                              gthxn1:
 FFFFF599 01F010                          tfr             x,d
 FFFFF59B 035090                          puls    x,pc
 
                              GetBinNumber:
 FFFFF59D 14F                             clrd
 FFFFF59E 0FD000910                       std             mon_numwka
 FFFFF5A1 0FD000912                       std             mon_numwka+2
 FFFFF5A4 034010                          pshs    x
 FFFFF5A6 08E000000                       ldx             #0
                              gtbin2:
 FFFFF5A9 08DF25                          bsr             MonGetch
 FFFFF5AB 08D098                          bsr             AsciiToBinDigit
 FFFFF5AD 05D                             tstb
 FFFFF5AE 02B00F                          bmi             gtbin1
 FFFFF5B0 08DFAF                          bsr             shl_numwka
 FFFFF5B2 0FA000913                       orb             mon_numwka+3
 FFFFF5B5 0F7000913                       stb             mon_numwka+3
 FFFFF5B8 030001                          inx
 FFFFF5BA 08C000030                       cpx             #48
 FFFFF5BD 025FEA                          blo             gtbin2
                              gtbin1:
 FFFFF5BF 01F010                          tfr             x,d
 FFFFF5C1 035090                          puls    x,pc
                                      
                              GetDecNumber:
 FFFFF5C3 14F                             clrd
 FFFFF5C4 0FD000910                       std             mon_numwka
 FFFFF5C7 0FD000912                       std             mon_numwka+2
 FFFFF5CA 034010                          pshs    x
 FFFFF5CC 08E000000                       ldx             #0
                              gtdec2:
 FFFFF5CF 08DEFF                          bsr             MonGetch
 FFFFF5D1 08D064                          bsr             AsciiToDecDigit
 FFFFF5D3 05D                             tstb
 FFFFF5D4 02B027                          bmi             gtdec1
 FFFFF5D6 08DF1E                          bsr             Times10
 FFFFF5D8 0FB000913                       addb    mon_numwka+3
 FFFFF5DB 0F7000913                       stb             mon_numwka+3
 FFFFF5DE 0F6000912                       ldb             mon_numwka+2
 FFFFF5E1 0C9000                          adcb    #0
 FFFFF5E3 0F7000912                       stb             mon_numwka+2
 FFFFF5E6 0F6000911                       ldb             mon_numwka+1
 FFFFF5E9 0C9000                          adcb    #0
 FFFFF5EB 0F7000911                       stb             mon_numwka+1
 FFFFF5EE 0F6000910                       ldb             mon_numwka+0
 FFFFF5F1 0C9000                          adcb    #0
 FFFFF5F3 0F7000910                       stb             mon_numwka+0
 FFFFF5F6 030001                          inx
 FFFFF5F8 08C00000F                       cpx             #15
 FFFFF5FB 025FD2                          blo             gtdec2
                              gtdec1:
 FFFFF5FD 01F010                          tfr             x,d
 FFFFF5FF 035090                          puls    x,pc
 
                              GetNumber:
 FFFFF601 08DECD                          bsr             MonGetch
 FFFFF603 0C102B                          cmpb    #'+'
 FFFFF605 027FBC                          beq             GetDecNumber
 FFFFF607 0C1025                          cmpb    #'%'
 FFFFF609 027F92                          beq             GetBinNumber
 FFFFF60B 0313FF                          dey
 FFFFF60D 020F5F                          bra             GetHexNumber
 
                              ;       phx
                              ;       push    r4
                              ;       push    r5
                              ;       ldx             #0
                              ;       ld              r4,#10
                              ;       ld              r5,#10
                              ;gtdcn2:
                              ;       jsr             MonGetch
                              ;       jsr             AsciiToDecNybble
                              ;       cmp             #-1
                              ;       beq             gtdcn1
                              ;       mul             r2,r2,r5
                              ;       add             r2,r1
                              ;       dec             r4
                              ;       bne             gtdcn2
                              ;gtdcn1:
                              ;       txa
                              ;       pop             r5
                              ;       pop             r4
                              ;       plx
                              ;       rts
 
                              ;------------------------------------------------------------------------------
                              ; Convert ASCII character in the range '0' to '9', 'a' to 'f' or 'A' to 'F'
                              ; to a hex nybble.
                              ;------------------------------------------------------------------------------
                              ;
                              AsciiToHexNybble:
 FFFFF60F 0C1030                          cmpb    #'0'
 FFFFF611 025021                          blo             gthx3
 FFFFF613 0C1039                          cmpb    #'9'
 FFFFF615 022003                          bhi             gthx5
 FFFFF617 0C0030                          subb    #'0'
 FFFFF619 039                             rts
                              gthx5:
 FFFFF61A 0C1041                          cmpb    #'A'
 FFFFF61C 025016                          blo             gthx3
 FFFFF61E 0C1046                          cmpb    #'F'
 FFFFF620 022005                          bhi             gthx6
 FFFFF622 0C0041                          subb    #'A'
 FFFFF624 0CB00A                          addb    #10
 FFFFF626 039                             rts
                              gthx6:
 FFFFF627 0C1061                          cmpb    #'a'
 FFFFF629 025009                          blo             gthx3
 FFFFF62B 0C107A                          cmpb    #'z'
 FFFFF62D 022005                          bhi             gthx3
 FFFFF62F 0C0061                          subb    #'a'
 FFFFF631 0CB00A                          addb    #10
 FFFFF633 039                             rts
                              gthx3:
 FFFFF634 0C6FFF                          ldb             #-1             ; not a hex number
 FFFFF636 039                             rts
 
                              AsciiToDecDigit:
 FFFFF637 0C1030                          cmpb    #'0'
 FFFFF639 025007                          blo             gtdc3
 FFFFF63B 0C1039                          cmpb    #'9'
 FFFFF63D 022003                          bhi             gtdc3
 FFFFF63F 0C0030                          subb    #'0'
 FFFFF641 039                             rts
                              gtdc3:
 FFFFF642 0C6FFF                          ldb             #-1
 FFFFF644 039                             rts
 
                              AsciiToBinDigit:
 FFFFF645 0C1030                          cmpb    #'0'
 FFFFF647 026002                          bne             abd1
 FFFFF649 05F                             clrb
 FFFFF64A 039                             rts
                              abd1:
 FFFFF64B 0C1031                          cmpb    #'1'
 FFFFF64D 026003                          bne             abd2
 FFFFF64F 0C6001                          ldb             #1
 FFFFF651 039                             rts
                              abd2:
 FFFFF652 0C6FFF                          ldb             #-1
 FFFFF654 039                             rts
 
                              DisplayErr:
 FFFFF655 0CCFFF666                       ldd             #msgErr
 FFFFF658 017FFED8B                       lbsr    DisplayString
*** warning 1: Long branch within short branch range could be optimized
 FFFFF65B 07EFFF3C2                       jmp             Monitor
 
                              DisplayStringDX
 FFFFF65E 0DD024                          std             Strptr
 FFFFF660 09F026                          stx             Strptr+2
 FFFFF662 0BDFFE3E6                       jsr             DisplayString
 FFFFF665 039                             rts
 
                              msgErr:
 FFFFF666 02A02A04507207200D00A           fcb     "**Err",CR,LF,0
 FFFFF66D 000
 
                              HelpMsg:
 FFFFF66E 03F02003D020044069073           fcb             "? = Display help",CR,LF
 FFFFF675 07006C061079020068065
 FFFFF67C 06C07000D00A
 FFFFF680 04304C05302003D020063           fcb     "CLS = clear screen",CR,LF
 FFFFF687 06C065061072020073063
 FFFFF68E 07206506506E00D00A
 FFFFF694 06202B02003D020073065           fcb     "b+ = set breakpoint",CR,LF
 FFFFF69B 07402006207206506106B
 FFFFF6A2 07006F06906E07400D00A
 FFFFF6A9 06202D02003D02006306C           fcb     "b- = clear breakpoint",CR,LF
 FFFFF6B0 065061072020062072065
 FFFFF6B7 06106B07006F06906E074
 FFFFF6BE 00D00A
 FFFFF6C0 04303103902003D020072           fcb     "C19 = run C19 loader",CR,LF
 FFFFF6C7 07506E020043031039020
 FFFFF6CE 06C06F06106406507200D
 FFFFF6D5 00A
                              ;       db      "S = Boot from SD Card",CR,LF
 FFFFF6D6 03A02003D020045064069           fcb     ": = Edit memory bytes",CR,LF
 FFFFF6DD 07402006D06506D06F072
 FFFFF6E4 079020062079074065073
 FFFFF6EB 00D00A
                              ;       db      "L = Load sector",CR,LF
                              ;       db      "W = Write sector",CR,LF
 FFFFF6ED 04405202003D020044075           fcb "DR = Dump registers",CR,LF
 FFFFF6F4 06D070020072065067069
 FFFFF6FB 07307406507207300D00A
 FFFFF702 04402003D02004407506D           fcb     "D = Dump memory",CR,LF
 FFFFF709 07002006D06506D06F072
 FFFFF710 07900D00A
 FFFFF713 04404905602003D020044           fcb "DIV = Divider Test", CR, LF
 FFFFF71A 069076069064065072020
 FFFFF721 05406507307400D00A
 FFFFF727 04602003D02004606906C           fcb     "F = Fill memory",CR,LF
 FFFFF72E 06C02006D06506D06F072
 FFFFF735 07900D00A
 FFFFF738 04604C02003D020044075           fcb "FL = Dump I/O Focus List",CR,LF
 FFFFF73F 06D07002004902F04F020
 FFFFF746 04606F06307507302004C
 FFFFF74D 06907307400D00A
                              ;       fcb "FIG = start FIG Forth",CR,LF
                              ;       db      "KILL n = kill task #n",CR,LF
                              ;       db      "B = start tiny basic",CR,LF
                              ;       db      "b = start EhBasic 6502",CR,LF
 FFFFF752 04A02003D02004A07506D           fcb     "J = Jump to code",CR,LF
 FFFFF759 07002007406F02006306F
 FFFFF760 06406500D00A
 FFFFF764 04A04403402003D02004A           fcb     "JD4 = Jump to $FFD400",CR,LF
 FFFFF76B 07506D07002007406F020
 FFFFF772 024046046044034030030
 FFFFF779 00D00A
 FFFFF77B 05205B06E05D02003D020           fcb     "R[n] = Set register value",CR,LF
 FFFFF782 053065074020072065067
 FFFFF789 069073074065072020076
 FFFFF790 06106C07506500D00A
                              ;       db      "r = random lines - test bitmap",CR,LF
                              ;       db      "e = ethernet test",CR,LF
 FFFFF796 07302003D020073065072           fcb     "s = serial output test",CR,LF
 FFFFF79D 06906106C02006F075074
 FFFFF7A4 070075074020074065073
 FFFFF7AB 07400D00A
 FFFFF7AE 05305002003D020073070           fcb     "SP = sprite demo",CR,LF
 FFFFF7B5 072069074065020064065
 FFFFF7BC 06D06F00D00A
                              ;       db      "T = Dump task list",CR,LF
                              ;       db      "TO = Dump timeout list",CR,LF
 FFFFF7C0 05404902003D020064069           fcb     "TI = display date/time",CR,LF
 FFFFF7C7 07307006C061079020064
 FFFFF7CE 06107406502F07406906D
 FFFFF7D5 06500D00A
                              ;       db      "TEMP = display temperature",CR,LF
 FFFFF7D8 05502003D02007506E061           fcb     "U = unassemble",CR,LF
 FFFFF7DF 07307306506D06206C065
 FFFFF7E6 00D00A
                              ;       db      "P = Piano",CR,LF
 FFFFF7E8 05804D02003D02007806D           fcb     "XM = xmodem transfer",CR,LF
 FFFFF7EF 06F06406506D020074072
 FFFFF7F6 06106E07306606507200D
 FFFFF7FD 00A
 FFFFF7FE 07802003D020065078069           fcb     "x = exit monitor",CR,LF
 FFFFF805 07402006D06F06E069074
 FFFFF80C 06F07200D00A
 FFFFF810 000                             fcb             0
 
                              msgRegHeadings
 FFFFF811 00D00A02002004402F041           fcb     CR,LF,"  D/AB     X      Y      U      S       PC    DP  CCR",CR,LF,0
 FFFFF818 042020020020020020058
 FFFFF81F 020020020020020020059
 FFFFF826 020020020020020020055
 FFFFF82D 020020020020020020053
 FFFFF834 020020020020020020020
 FFFFF83B 050043020020020020044
 FFFFF842 05002002004304305200D
 FFFFF849 00A000
                              msgDBRegHeadings:
 FFFFF84B 00D00A020020041044030           fcb     CR,LF,"  AD0     AD1    AD2    AD3    CTL0 CTL1 CTL2 CTL3",CR,LF,0
 FFFFF852 020020020020020041044
 FFFFF859 031020020020020041044
 FFFFF860 032020020020020041044
 FFFFF867 033020020020020043054
 FFFFF86E 04C03002004305404C031
 FFFFF875 02004305404C032020043
 FFFFF87C 05404C03300D00A000
                              nHEX4:
 FFFFF882 0BDFFD2D2                       jsr             HEX4
 FFFFF885 039                             rts
 
                              nXBLANK:
 FFFFF886 0C6020                          ldb             #' '
 FFFFF888 016FFF982                       lbra    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 
                              ;------------------------------------------------------------------------------
                              ; Dump Memory
                              ;
                              ; Usage:
                              ;       $D FFFC12 FFFC20
                              ;
                              ; Dump formatted to look like:
                              ;               :FFFC12 012 012 012 012 555 666 777 888
                              ;
                              ;------------------------------------------------------------------------------
 
                              DumpMemory:
 FFFFF88B 08DCB8                          bsr             GetRange
 FFFFF88D 18E000000                       ldy             #0
 FFFFF890 1BE000922                       ldy             mon_r1+2
                              dmpm2:
 FFFFF893 017FFD83C                       lbsr    CRLF
*** warning 1: Long branch within short branch range could be optimized
 FFFFF896 0C603A                          ldb             #':'
 FFFFF898 017FFF972                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 FFFFF89B 01F020                          tfr             y,d
                                      ;addd   mon_r1+2                                        ; output the address
 FFFFF89D 017FFEB9E                       lbsr    DispWordAsHex
*** warning 1: Long branch within short branch range could be optimized
 FFFFF8A0 0C6020                          ldb             #' '
 FFFFF8A2 017FFF968                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 FFFFF8A5 08E000008                       ldx             #8                                                              ; number of bytes to display
                              dmpm1:
                              ;       ldb             far [mon_r1+1],y
                                      ;ldb            [mon_r1+2],y
 FFFFF8A8 0E6A04                          ldb             ,y
 FFFFF8AA 031201                          iny
 FFFFF8AC 017FFEB98                       lbsr    DispByteAsHex                   ; display byte
*** warning 1: Long branch within short branch range could be optimized
 FFFFF8AF 0C6020                          ldb             #' '                                                    ; followed by a space
 FFFFF8B1 017FFF959                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 FFFFF8B4 05F                             clrb
 FFFFF8B5 04F                             clra
 FFFFF8B6 017FFF91E                       lbsr    INCH
*** warning 1: Long branch within short branch range could be optimized
 FFFFF8B9 0C1003                          cmpb    #CTRLC
 FFFFF8BB 027024                          beq             dmpm3
 FFFFF8BD 0301FF                          dex
 FFFFF8BF 026FE7                          bne             dmpm1
                                      ; Now output ascii
 FFFFF8C1 0C6020                          ldb             #' '
 FFFFF8C3 017FFF947                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 FFFFF8C6 08E000008                       ldx             #8                                                              ; 8 chars to output
 FFFFF8C9 0313F8                          leay    -8,y                                                    ; backup pointer
                              dmpm5:
                              ;       ldb             far [mon_r1+1],y        ; get the char
                              ;       ldb             [mon_r1+2],y                    ; get the char
 FFFFF8CB 0E6A04                          ldb             ,y
 FFFFF8CD 0C1020                          cmpb    #$20                                                    ; is it a control char?
 FFFFF8CF 024002                          bhs             dmpm4
 FFFFF8D1 0C602E                          ldb             #'.'
                              dmpm4:
 FFFFF8D3 017FFF937                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 FFFFF8D6 031201                          iny
 FFFFF8D8 0301FF                          dex
 FFFFF8DA 026FEF                          bne             dmpm5
 FFFFF8DC 1BC000926                       cmpy    mon_r2+2
 FFFFF8DF 025FB2                          blo             dmpm2
                              dmpm3:
 FFFFF8E1 017FFD7EE                       lbsr    CRLF
*** warning 1: Long branch within short branch range could be optimized
 FFFFF8E4 016FFFADB                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
 
                              ;------------------------------------------------------------------------------
                              ; Edit Memory
                              ;
                              ; Usage:
                              ;       $$:FFFC12 8 "Hello World!" 0
                              ;
                              ; Dump formatted to look like:
                              ;               :FFFC12 012 012 012 012 555 666 777 888
                              ;
                              ;------------------------------------------------------------------------------
 
                              EditMemory:
 FFFFF8E7 0CE000008                       ldu             #8                                              ; set max byte count
 FFFFF8EA 017FFFC00                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 FFFFF8ED 017FFFC7E                       lbsr    GetHexNumber    ; get the start address
*** warning 1: Long branch within short branch range could be optimized
 FFFFF8F0 0BE000912                       ldx             mon_numwka+2
                              EditMem2:
 FFFFF8F3 017FFFBF7                       lbsr    ignBlanks                       ; skip over blanks
*** warning 1: Long branch within short branch range could be optimized
 FFFFF8F6 017FFFC75                       lbsr    GetHexNumber    ; get the byte value
*** warning 1: Long branch within short branch range could be optimized
 FFFFF8F9 05D                             tstb                                                            ; check for valid value
 FFFFF8FA 02700C                          beq             EditMem1                        ; if invalid, quit
 FFFFF8FC 0F6000913                       ldb             mon_numwka+3    ; get value
 FFFFF8FF 0E7800                          stb             ,x+                                             ; update memory at address
 FFFFF901 0335FF                          leau    -1,u                                    ; decremeent byte count
 FFFFF903 283000000                       cmpu    #0
 FFFFF906 026FEB                          bne             EditMem2                        ; go back for annother byte
                              EditMem1:
 FFFFF908 017FFFBC5                       lbsr    MonGetch                        ; see if a string is being entered
*** warning 1: Long branch within short branch range could be optimized
 FFFFF90B 0C1022                          cmpb    #'"'
 FFFFF90D 026018                          bne             EditMem3                        ; no string, we're done
 FFFFF90F 0CE000028                       ldu             #40                                             ; string must be less than 40 chars
                              EditMem4:
 FFFFF912 017FFFBBB                       lbsr    MonGetch                        ; look for close quote
*** warning 1: Long branch within short branch range could be optimized
 FFFFF915 0C1022                          cmpb    #'"'
 FFFFF917 026005                          bne             EditMem6                        ; end of string?
 FFFFF919 0CE000008                       ldu             #8                                              ; reset the byte count
 FFFFF91C 020FD5                          bra             EditMem2
                              EditMem6:                       
 FFFFF91E 0E7800                          stb             ,x+                                             ; store the character in memory
 FFFFF920 0335FF                          leau    -1,u                                    ; decrement byte count
 FFFFF922 283000000                       cmpu    #0
 FFFFF925 022FEB                          bhi             EditMem4                        ; max 40 chars
                              EditMem3:
 FFFFF927 016FFFA98                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                                      
 
                              ;------------------------------------------------------------------------------
                              ; Fill Memory
                              ;
                              ; Usage:
                              ;       $$F FFFC12 FFFC30 89F
                              ;
                              ;------------------------------------------------------------------------------
 
                              FillMemory:
 FFFFF92A 017FFFC18                       lbsr    GetRange                        ; get address range to fill
*** warning 1: Long branch within short branch range could be optimized
 FFFFF92D 017FFFBBD                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 FFFFF930 017FFFC3B                       lbsr    GetHexNumber    ; get target byte to write
*** warning 1: Long branch within short branch range could be optimized
 FFFFF933 0F6000913                       ldb             mon_numwka+3
 FFFFF936 0BE000922                       ldx             mon_r1+2
 FFFFF939 04F                             clra
                              fillm1:                                                         ; Check for a CTRL-C every page of memory
 FFFFF93A 04D                             tsta
 FFFFF93B 02600D                          bne             fillm2
 FFFFF93D 05F                             clrb                                                            ; we want a non-blocking check
 FFFFF93E 04F                             clra
 FFFFF93F 017FFF895                       lbsr    INCH
*** warning 1: Long branch within short branch range could be optimized
 FFFFF942 0C1003                          cmpb    #CTRLC
 FFFFF944 127FFFA7B                       lbeq    Monitor
*** warning 1: Long branch within short branch range could be optimized
 FFFFF947 0F6000913                       ldb             mon_numwka+3    ; reset target byte
                              fillm2:
 FFFFF94A 0E7800                          stb             ,x+
 FFFFF94C 0BC000926                       cmpx    mon_r2+2
 FFFFF94F 023FE9                          bls             fillm1
                              fillm3:
 FFFFF951 016FFFA6E                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                                      
                              ;------------------------------------------------------------------------------
                              ; Dump Registers
                              ;
                              ;       Usage:
                              ;               $DR
                              ;------------------------------------------------------------------------------
 
                              DumpRegs:
 FFFFF954 0CCFFF811                       ldd             #msgRegHeadings
 FFFFF957 017FFEA8C                       lbsr    DisplayString
*** warning 1: Long branch within short branch range could be optimized
 FFFFF95A 08DF2A                          bsr             nXBLANK
 FFFFF95C 0FC000900                       ldd             mon_DSAVE
 FFFFF95F 08DF21                          bsr             nHEX4
 FFFFF961 08DF23                          bsr             nXBLANK
 FFFFF963 0FC000902                       ldd             mon_XSAVE
 FFFFF966 08DF1A                          bsr             nHEX4
 FFFFF968 08DF1C                          bsr             nXBLANK
 FFFFF96A 0FC000904                       ldd             mon_YSAVE
 FFFFF96D 08DF13                          bsr             nHEX4
 FFFFF96F 08DF15                          bsr             nXBLANK
 FFFFF971 0FC000906                       ldd             mon_USAVE
 FFFFF974 08DF0C                          bsr             nHEX4
 FFFFF976 08DF0E                          bsr             nXBLANK
 FFFFF978 0FC000908                       ldd             mon_SSAVE
 FFFFF97B 08DF05                          bsr             nHEX4
 FFFFF97D 08DF07                          bsr             nXBLANK
 FFFFF97F 0F600090B                       ldb             mon_PCSAVE+1
 FFFFF982 017FFEAC2                       lbsr    DispByteAsHex   
*** warning 1: Long branch within short branch range could be optimized
 FFFFF985 0FC00090C                       ldd             mon_PCSAVE+2
 FFFFF988 08DEF8                          bsr             nHEX4
 FFFFF98A 08DEFA                          bsr             nXBLANK
 FFFFF98C 0FC00090E                       ldd             mon_DPRSAVE
 FFFFF98F 0BDFFD2CE                       jsr             HEX2
 FFFFF992 08DEF2                          bsr             nXBLANK
 FFFFF994 0B600090F                       lda             mon_CCRSAVE
 FFFFF997 017FFD934                       lbsr    HEX2
*** warning 1: Long branch within short branch range could be optimized
 FFFFF99A 08DEEA                          bsr             nXBLANK
 FFFFF99C 0CCFFF84B                       ldd             #msgDBRegHeadings
 FFFFF99F 017FFEA44                       lbsr    DisplayString
*** warning 1: Long branch within short branch range could be optimized
 FFFFF9A2 0150FCFFFFFFF00                 ldd             BRKAD0
 FFFFF9A7 017FFEA94                       lbsr  DispWordAsHex
*** warning 1: Long branch within short branch range could be optimized
 FFFFF9AA 08DEDA                          bsr             nXBLANK
 FFFFF9AC 0150FCFFFFFFF04                 ldd             BRKAD1
 FFFFF9B1 017FFEA8A                       lbsr  DispWordAsHex
*** warning 1: Long branch within short branch range could be optimized
 FFFFF9B4 08DED0                          bsr             nXBLANK
 FFFFF9B6 0150FCFFFFFFF08                 ldd             BRKAD2
 FFFFF9BB 017FFEA80                       lbsr  DispWordAsHex
*** warning 1: Long branch within short branch range could be optimized
 FFFFF9BE 08DEC6                          bsr             nXBLANK
 FFFFF9C0 0150FCFFFFFFF0C                 ldd             BRKAD3
 FFFFF9C5 017FFEA76                       lbsr  DispWordAsHex
*** warning 1: Long branch within short branch range could be optimized
 FFFFF9C8 08DEBC                          bsr             nXBLANK
 FFFFF9CA 0150F6FFFFFFF10                 ldb             BRKCTRL0
 FFFFF9CF 017FFEA75                       lbsr    DispByteAsHex
*** warning 1: Long branch within short branch range could be optimized
 FFFFF9D2 08DEB2                          bsr             nXBLANK
 FFFFF9D4 0150F6FFFFFFF11                 ldb             BRKCTRL1
 FFFFF9D9 017FFEA6B                       lbsr    DispByteAsHex
*** warning 1: Long branch within short branch range could be optimized
 FFFFF9DC 08DEA8                          bsr             nXBLANK
 FFFFF9DE 0150F6FFFFFFF12                 ldb             BRKCTRL2
 FFFFF9E3 017FFEA61                       lbsr    DispByteAsHex
*** warning 1: Long branch within short branch range could be optimized
 FFFFF9E6 08DE9E                          bsr             nXBLANK
 FFFFF9E8 0150F6FFFFFFF13                 ldb             BRKCTRL3
 FFFFF9ED 017FFEA57                       lbsr    DispByteAsHex
*** warning 1: Long branch within short branch range could be optimized
 FFFFF9F0 017FFD6DF                       lbsr    CRLF
*** warning 1: Long branch within short branch range could be optimized
 FFFFF9F3 016FFF9CC                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
 
                              ;------------------------------------------------------------------------------
                              ; SetRegXXX
                              ;
                              ; Set the value to be loaded into a register.
                              ;------------------------------------------------------------------------------
 
                              SetRegA:
 FFFFF9F6 017FFFAF4                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 FFFFF9F9 017FFFC05                       lbsr    GetNumber
*** warning 1: Long branch within short branch range could be optimized
 FFFFF9FC 0B6000913                       lda             mon_numwka+3
 FFFFF9FF 0B7000900                       sta             mon_DSAVE
 FFFFFA02 016FFF9BD                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              SetRegB:
 FFFFFA05 017FFFAE5                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 FFFFFA08 017FFFBF6                       lbsr    GetNumber
*** warning 1: Long branch within short branch range could be optimized
 FFFFFA0B 0B6000913                       lda             mon_numwka+3
 FFFFFA0E 0B7000901                       sta             mon_DSAVE+1
 FFFFFA11 016FFF9AE                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              SetRegD:
 FFFFFA14 017FFFAD6                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 FFFFFA17 017FFFBE7                       lbsr    GetNumber
*** warning 1: Long branch within short branch range could be optimized
 FFFFFA1A 0FC000912                       ldd             mon_numwka+2
 FFFFFA1D 0FD000900                       std             mon_DSAVE
 FFFFFA20 016FFF99F                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              SetRegX:
 FFFFFA23 017FFFAC7                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 FFFFFA26 017FFFBD8                       lbsr    GetNumber
*** warning 1: Long branch within short branch range could be optimized
 FFFFFA29 0FC000912                       ldd             mon_numwka+2
 FFFFFA2C 0FD000902                       std             mon_XSAVE
 FFFFFA2F 016FFF990                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              SetRegY:
 FFFFFA32 017FFFAB8                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 FFFFFA35 017FFFBC9                       lbsr    GetNumber
*** warning 1: Long branch within short branch range could be optimized
 FFFFFA38 0FC000912                       ldd             mon_numwka+2
 FFFFFA3B 0FD000904                       std             mon_YSAVE
 FFFFFA3E 016FFF981                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              SetRegU:
 FFFFFA41 017FFFAA9                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 FFFFFA44 017FFFBBA                       lbsr    GetNumber
*** warning 1: Long branch within short branch range could be optimized
 FFFFFA47 0FC000912                       ldd             mon_numwka+2
 FFFFFA4A 0FD000906                       std             mon_USAVE
 FFFFFA4D 016FFF972                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              SetRegS:
 FFFFFA50 017FFFA9A                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 FFFFFA53 017FFFBAB                       lbsr    GetNumber
*** warning 1: Long branch within short branch range could be optimized
 FFFFFA56 0FC000912                       ldd             mon_numwka+2
 FFFFFA59 0FD000908                       std             mon_SSAVE
 FFFFFA5C 016FFF963                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              SetRegDPR:
 FFFFFA5F 017FFFA8B                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 FFFFFA62 017FFFB9C                       lbsr    GetNumber
*** warning 1: Long branch within short branch range could be optimized
 FFFFFA65 0B6000913                       lda             mon_numwka+3
 FFFFFA68 0B700090E                       sta             mon_DPRSAVE
 FFFFFA6B 016FFF954                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              SetRegCCR:
 FFFFFA6E 017FFFA7C                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 FFFFFA71 017FFFB8D                       lbsr    GetNumber
*** warning 1: Long branch within short branch range could be optimized
 FFFFFA74 0B6000913                       lda             mon_numwka+3
 FFFFFA77 0B700090F                       sta             mon_CCRSAVE
 FFFFFA7A 016FFF945                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              SetRegPC:
 FFFFFA7D 017FFFA6D                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 FFFFFA80 017FFFB7E                       lbsr    GetNumber
*** warning 1: Long branch within short branch range could be optimized
 FFFFFA83 0FC000912                       ldd             mon_numwka+2
 FFFFFA86 0FD00090C                       std             mon_PCSAVE+2
 FFFFFA89 0F6000911                       ldb             mon_numwka+1
 FFFFFA8C 0F700090B                       stb             mon_PCSAVE+1
 FFFFFA8F 016FFF930                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
 
                              ;------------------------------------------------------------------------------
                              ; Jump to code
                              ;
                              ; Registers are loaded with values from the monitor register save area before
                              ; the code is jumped to.
                              ;
                              ; J <address>
                              ;------------------------------------------------------------------------------
 
                              jump_to_code:
 FFFFFA92 017FFFA58                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 FFFFFA95 017FFFB69                       lbsr    GetNumber
*** warning 1: Long branch within short branch range could be optimized
 FFFFFA98 01A010                          sei
 FFFFFA9A 1FE000908                       lds             mon_SSAVE
 FFFFFA9D 0CCFFFACC                       ldd             #jtc_exit                       ; setup stack for RTS back to monitor
 FFFFFAA0 034006                          pshs    d
 FFFFFAA2 0C6000                          ldb             #0
 FFFFFAA4 034004                          pshs    b
 FFFFFAA6 0FC000906                       ldd             mon_USAVE
 FFFFFAA9 034006                          pshs    d
 FFFFFAAB 0FC000904                       ldd             mon_YSAVE
 FFFFFAAE 034006                          pshs    d
 FFFFFAB0 0FC000902                       ldd             mon_XSAVE
 FFFFFAB3 034006                          pshs    d
 FFFFFAB5 0B600090E                       lda             mon_DPRSAVE
 FFFFFAB8 034002                          pshs    a
 FFFFFABA 0FC000900                       ldd             mon_DSAVE
 FFFFFABD 034006                          pshs    d
 FFFFFABF 0B600090F                       lda             mon_CCRSAVE
 FFFFFAC2 034002                          pshs    a
 FFFFFAC4 01503507F                       puls    far ccr,d,dpr,x,y,u
 FFFFFAC7 01506E90F000911                 jmp             far [mon_numwka+1]
                              jtc_exit:
 FFFFFACC 1FF000908                       sts             >mon_SSAVE              ; need to use extended addressing, no direct page setting
 FFFFFACF 03280F006FFF                    leas    $6FFF                                   ; reset stack to system area, dont modify flags register!
 FFFFFAD3 034001                          pshs    ccr                                             ; now the stack can be used
 FFFFFAD5 034002                          pshs    a                                                       ; save acca register so we can use it
 FFFFFAD7 01F0B8                          tfr             dpr,a                                   ; a = outgoing dpr value
 FFFFFAD9 0B700090E                       sta             >mon_DPRSAVE    ; force extended addressing mode usage here dpr is not set
 FFFFFADC 04F                             clra                                                            ; dpg register must be set to zero before values are 
 FFFFFADD 01F08B                          tfr             a,dpr                                   ; saved in the monitor register save area.
 FFFFFADF 035002                          puls    a                                                       ; get back acca
 FFFFFAE1 0FD000900                       std             mon_DSAVE                       ; save regsters, can use direct addressing now
 FFFFFAE4 0BF000902                       stx             mon_XSAVE
 FFFFFAE7 1BF000904                       sty             mon_YSAVE
 FFFFFAEA 0FF000906                       stu             mon_USAVE
 FFFFFAED 035002                          puls    a                                                       ; get back ccr
 FFFFFAEF 0B700090F                       sta             mon_CCRSAVE             ; and save it too
                                      ; Reset vectors in case they got toasted.
 FFFFFAF2 0CCFFEC8F                       ldd             #SerialPeekCharDirect
 FFFFFAF5 0FD000804                       std             CharInVec
 FFFFFAF8 0CCFFE325                       ldd             #DisplayChar
 FFFFFAFB 0FD000800                       std             CharOutVec
 FFFFFAFE 0150FCFFFFFF655                 ldd             DisplayErr
 FFFFFB03 0FD00080C                       std             MonErrVec
                                      ; todo set according to coreid
 FFFFFB06 016FFFE4B                       lbra    DumpRegs                        ; now go do a register dump
*** warning 1: Long branch within short branch range could be optimized
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
 
                              DumpIOFocusList:
 FFFFFB09 08E000000                       ldx             #0
                              dfl2:
 FFFFFB0C 0E680A000FFC000                 ldb             IOFocusList,x
 FFFFFB11 0C1018                          cmpb    #24
 FFFFFB13 02600A                          bne             dfl1
 FFFFFB15 01F010                          tfr             x,d
 FFFFFB17 017FFE92D                       lbsr    DispByteAsHex
*** warning 1: Long branch within short branch range could be optimized
 FFFFFB1A 0C6020                          ldb             #' '
 FFFFFB1C 017FFF6EE                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
                              dfl1:
 FFFFFB1F 030001                          inx
 FFFFFB21 08C000010                       cmpx    #16
 FFFFFB24 025FE6                          blo             dfl2
 FFFFFB26 017FFD5A9                       lbsr    CRLF
*** warning 1: Long branch within short branch range could be optimized
 FFFFFB29 016FFF896                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                                      
                              bootpg:
 FFFFFB2C 000                             fcb             $000
                              boot_stack:
 FFFFFB2D FFC0FF                          fcw             $FFC0FF
                              numBreakpoints:
 FFFFFB2F 000008                          fcw             8
                              mon_rom_vectab:
 FFFFFB31 FFFB33                          fcw             mon_rom_vecs
                              mon_rom_vecs:
 FFFFFB33 FFF3C2                          fcw             Monitor                                         ; enter monitor program
 FFFFFB35 FFF1D7                          fcw             INCH                                                    ; input a character
 FFFFFB37 FFF20D                          fcw             OUTCH                                                   ; output a character
 FFFFFB39 FFD0D2                          fcw             CRLF                                                    ; output carriage-return, line feed
 FFFFFB3B FFE3E6                          fcw             DisplayString
 FFFFFB3D FFE447                          fcw             DispByteAsHex
 FFFFFB3F FFE43E                          fcw             DispWordAsHex
 FFFFFB41 FFF215                          fcw             ShowSprites
 FFFFFB43 FFF2A8                          fcw             mon_srand
 FFFFFB45 FFF2D8                          fcw             mon_rand
 FFFFFB47 000000                          fcw             0                                                                       ; operating system call
 FFFFFB49 FFF545                          fcw             GetRange
 FFFFFB4B FFF601                          fcw             GetNumber
 FFFFFB4D FFECD0                          fcw             SerialPutChar   
 
                              NumFuncs        EQU     (*-mon_rom_vectab)/2
 
                              ; The following table indicates which routines need to return values in the
                              ; D and possibly X registers.
 
                              mon_rettab:
 FFFFFB4F 000                             fcb             0                       ; monitor
 FFFFFB50 800                             fcb             $800    ; INCH
 FFFFFB51 000                             fcb             0                       ; OUTCH
 FFFFFB52 000                             fcb             0                       ; CRLF
 FFFFFB53 000                             fcb             0                       ; DisplayString
 FFFFFB54 000                             fcb             0                       ; DisplayByte
 FFFFFB55 000                             fcb             0                       ; DisplayWord
 FFFFFB56 000                             fcb             0                       ; show sprites
 FFFFFB57 000                             fcb             0                       ; srand
 FFFFFB58 C00                             fcb             $C00    ; rand
 FFFFFB59 C00                             fcb             $C00    ; OS call
 FFFFFB5A 000                             fcb             0                       ; GetRange
 FFFFFB5B 800                             fcb             $800    ; GetNumber
 FFFFFB5C 000                             fcb             0                       ; SerialPutChar
                                      
                              ;------------------------------------------------------------------------------
                              ; SWI routine.
                              ;
                              ; SWI is used to call ROM monitor routines and process breakpoints.
                              ;
                              ;       swi
                              ;       fcb <desired function>
                              ;------------------------------------------------------------------------------
 
                              swi_rout:
 FFFFFB5D 0E680CFCC                       ldb             bootpg,pcr                      ; reset direct page
 FFFFFB60 01F09B                          tfr             b,dp
                              swi_rout1:
 FFFFFB62 0EE60B                          ldu             11,s                                            ; get program counter (low order 2 bytes)
 FFFFFB64 0335FF                          leau    -1,u                                            ; backup a byte
 FFFFFB66 07D000810                       tst             BreakpointFlag  ; are we in breakpoint mode?
 FFFFFB69 02700F                          beq             swiNotBkpt
 FFFFFB6B 18E000820                       ldy             #Breakpoints
 FFFFFB6E 0F6000811                       ldb             NumSetBreakpoints
 FFFFFB71 027007                          beq             swiNotBkpt
                              swi_rout2:
 FFFFFB73 2A3A01                          cmpu    ,y++    
 FFFFFB75 02704B                          beq             processBreakpoint
 FFFFFB77 05A                             decb
 FFFFFB78 026FF9                          bne             swi_rout2
                              swiNotBkpt:
 FFFFFB7A 07F000810                       clr             BreakpointFlag
 FFFFFB7D 037006                          pulu    d                                                               ; get function #, increment PC
 FFFFFB7F 0C100F                          cmpb    #NumFuncs
 FFFFFB81 122FFFAD1                       lbhi    DisplayErr
*** warning 1: Long branch within short branch range could be optimized
 FFFFFB84 0EF60B                          stu             11,s                                            ; save updated PC on stack
 FFFFFB86 0C100A                          cmpb    #MF_OSCALL
 FFFFFB88 027072                          beq             swiCallOS
 FFFFFB8A 058                             aslb                                                                    ; 2 bytes per vector
 FFFFFB8B 0AE80CFA3                       ldx             mon_rom_vectab,pcr
 FFFFFB8E 03A                             abx
 FFFFFB8F 0AE804                          ldx             ,x
 FFFFFB91 0BF000928                       stx             jmpvec
 FFFFFB94 054                             lsrb
 FFFFFB95 08EFFFB4F                       ldx             #mon_rettab
 FFFFFB98 03A                             abx
 FFFFFB99 0E6804                          ldb             ,x
 FFFFFB9B 0F7000930                       stb             mon_retflag
 FFFFFB9E 1FF000908                       sts             mon_SSAVE                               ; save the stack pointer
 FFFFFBA1 0EC601                          ldd             1,s                                                     ; get back D
 FFFFFBA3 0AE604                          ldx             4,s                                                     ; get back X
 FFFFFBA5 1AE606                          ldy             6,s                                                     ; get back Y
 FFFFFBA7 0EE608                          ldu             8,s                                                     ; get back U
 FFFFFBA9 1EE80CF81                       lds             boot_stack,pcr  ; and use our own stack
 FFFFFBAC 0AD90F000928                    jsr             [jmpvec]                                ; call the routine
                              swi_rout3:
 FFFFFBB0 1FE000908                       lds             mon_SSAVE                               ; restore stack
 FFFFFBB3 07D000930                       tst             mon_retflag
 FFFFFBB6 02A009                          bpl             swi_rout4
 FFFFFBB8 0ED601                          std             1,s                                                     ; return value in D
 FFFFFBBA 078000930                       asl             mon_retflag
 FFFFFBBD 02A002                          bpl             swi_rout4
 FFFFFBBF 0AF604                          stx             4,s                                                     ; return value in X
                              swi_rout4:
 FFFFFBC1 03B                             rti
 
                              ;------------------------------------------------------------------------------
                              ; A breakpoint was struck during program execution, process accordingly.
                              ;------------------------------------------------------------------------------
 
                              processBreakpoint:
 FFFFFBC2 0A6E04                          lda             ,s
 FFFFFBC4 0B700090F                       sta             mon_CCRSAVE
 FFFFFBC7 0EC601                          ldd             1,s
 FFFFFBC9 0FD000900                       std             mon_DSAVE
 FFFFFBCC 0E6603                          ldb             3,s
 FFFFFBCE 0F700090E                       stb             mon_DPRSAVE
 FFFFFBD1 0EC604                          ldd             4,s
 FFFFFBD3 0FD000902                       std             mon_XSAVE
 FFFFFBD6 0EC606                          ldd             6,s
 FFFFFBD8 0FD000904                       std             mon_YSAVE
 FFFFFBDB 0EC608                          ldd             8,s
 FFFFFBDD 0FD000906                       std             mon_USAVE
 FFFFFBE0 1FF000908                       sts             mon_SSAVE
 FFFFFBE3 0E660A                          ldb             10,s
 FFFFFBE5 0F700090A                       stb             mon_PCSAVE
 FFFFFBE8 0EC60B                          ldd             11,s
 FFFFFBEA 0FD00090B                       std             mon_PCSAVE+1
 FFFFFBED 1EE80CF3D                       lds             boot_stack,pcr
 FFFFFBF0 0CCFFFBB0                       ldd             #swi_rout3                      ; setup so monitor can return
 FFFFFBF3 034006                          pshs    d
 FFFFFBF5 08D021                          bsr             DisarmAllBreakpoints
 FFFFFBF7 016FFFD5A                       lbra    DumpRegs
*** warning 1: Long branch within short branch range could be optimized
 
                              xitMonitor:
 FFFFFBFA 02003B                          bra             ArmAllBreakpoints
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
 
                              swiCallOS:      
 FFFFFBFC 033401                          leau    1,u                                                     ; next byte is func number
 FFFFFBFE 0E6C00                          ldb             ,u+
 FFFFFC00 0C1019                          cmpb    #NumOSFuncs                     ; check for valid range
 FFFFFC02 122FFFA50                       lbhi    DisplayErr
*** warning 1: Long branch within short branch range could be optimized
 FFFFFC05 0EF60B                          stu             11,s                                            ; save updateed PC on stack
 FFFFFC07 058                             aslb                                                                    ; compute vector address
 FFFFFC08 08EFFF22F                       ldx             #OSCallTbl
 FFFFFC0B 06DE0F                          tst             b,x                                                     ; check for non-zero vector
 FFFFFC0D 027FA1                          beq             swi_rout3
                              osc1:
                              ;       tst             OSSEMA+1                                ; wait for availability
                              ;       beq             osc1
 FFFFFC0F 0ADF0F                          jsr             [b,x]                                           ; call the OS routine
                              oscx:
 FFFFFC11 01507FFFFEF0011                 clr             OSSEMA+1
 FFFFFC16 020F98                          bra             swi_rout3
 
                              ;------------------------------------------------------------------------------
                              ; DisarmAllBreakpoints, used when entering the monitor.
                              ;------------------------------------------------------------------------------
 
                              DisarmAllBreakpoints:
 FFFFFC18 034036                          pshs    d,x,y
 FFFFFC1A 18E000000                       ldy             #0
 FFFFFC1D 05F                             clrb
 FFFFFC1E 08E000850                       ldx             #BreakpointBytes        ; x = breakpoint byte table address
                              disarm2:
 FFFFFC21 0C1B2F                          cmpb    #numBreakpoints         ; safety check
 FFFFFC23 024010                          bhs             disarm1
 FFFFFC25 0F1000811                       cmpb    NumSetBreakpoints
 FFFFFC28 02400B                          bhs             disarm1
 FFFFFC2A 0A6837                          lda             b,x                                                             ; get memory byte
 FFFFFC2C 0A7B09000820                    sta             [Breakpoints,y]         ; and store it back to memory
 FFFFFC30 031202                          leay    2,y                                                             ; increment for next address
 FFFFFC32 05C                             incb                                                                            ; increment to next byte
 FFFFFC33 020FEC                          bra             disarm2                                         ; loop back
                              disarm1:
 FFFFFC35 0350B6                          puls    d,x,y,pc
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
 
                              ArmAllBreakpoints:
 FFFFFC37 034036                          pshs    d,x,y
 FFFFFC39 18E000000                       ldy             #0
 FFFFFC3C 05F                             clrb
 FFFFFC3D 08E000850                       ldx             #BreakpointBytes        ; x = breakpoint byte table address
                              arm2:
 FFFFFC40 0150F1FFFFFFB2F                 cmpb    numBreakpoints          ; safety check
 FFFFFC45 024010                          bhs             arm1
 FFFFFC47 0F1000811                       cmpb    NumSetBreakpoints
 FFFFFC4A 02400B                          bhs             arm1
 FFFFFC4C 0A6B09000820                    lda             [Breakpoints,y]         ; load byte at memory address
 FFFFFC50 0A7B0D                          sta             b,x                                                             ; save in table
 FFFFFC52 031202                          leay    2,y                                                             ; increment for next address
 FFFFFC54 05C                             incb                                                                            ; increment to next byte
 FFFFFC55 020FE9                          bra             arm2                                                    ; loop back
                              arm1:
 FFFFFC57 0350B6                          puls    d,x,y,pc
 
                              ;------------------------------------------------------------------------------
                              ; b+ h0 123456  ; set hardware breakpoint #0 to address 123456
                              ; b+ 987654     ; set software breakpoint to address 987654
                              ;------------------------------------------------------------------------------
 
                              ArmBreakpoint:
 FFFFFC59 034036                          pshs    d,x,y
 FFFFFC5B 0B6000811                       lda             NumSetBreakpoints               ; check if too many breakpoints set
 FFFFFC5E 0150B1FFFFFFB2F                 cmpa    numBreakpoints
                              ;       lbhs    DisplayErr
 FFFFFC63 017FFF887                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 FFFFFC66 017FFF867                       lbsr    MonGetch
*** warning 1: Long branch within short branch range could be optimized
 FFFFFC69 07F000919                       clr             mon_numwka+9
 FFFFFC6C 0C1068                          cmpb    #'h'
 FFFFFC6E 02600B                          bne             armb1
 FFFFFC70 017FFF85D                       lbsr    MonGetch
*** warning 1: Long branch within short branch range could be optimized
 FFFFFC73 0F7000919                       stb             mon_numwka+9
 FFFFFC76 017FFF874                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 FFFFFC79 020002                          bra             armb2
                              armb1:
 FFFFFC7B 0313FF                          dey
                              armb2:
 FFFFFC7D 017FFF8EE                       lbsr    GetHexNumber                            ; get address parameter
*** warning 1: Long branch within short branch range could be optimized
 FFFFFC80 07D000919                       tst             mon_numwka+9
 FFFFFC83 02701A                          beq             armb3
 FFFFFC85 0FC000912                       ldd             mon_numwka+2
 FFFFFC88 0150FDFFFFFFF02                 std             BRKAD0+2
 FFFFFC8D 0FC000910                       ldd             mon_numwka
 FFFFFC90 0150FDFFFFFFF00                 std             BRKAD0
 FFFFFC95 0C608F                          ldb             #$08F                                                           ; enable breakpoint with exact match
 FFFFFC97 0150F7FFFFFFF10                 stb             BRKCTRL0
 FFFFFC9C 016FFF723                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              armb3:
 FFFFFC9F 05D                             tstb
 FFFFFCA0 12BFFF9B2                       lbmi    DisplayErr
*** warning 1: Long branch within short branch range could be optimized
 FFFFFCA3 0F6000811                       ldb             NumSetBreakpoints               ; b = number of set breakpoints
 FFFFFCA6 0150A690F000911                 lda             far [mon_numwka+1]      ; get byte at address
 FFFFFCAB 08E000000                       ldx             #0
 FFFFFCAE 03A                             abx
 FFFFFCAF 0A7809000850                    sta             BreakpointBytes,x               ; and store byte in a table
 FFFFFCB3 08603F                          lda             #OPC_SWI                                                ; put a SWI instruction in place
 FFFFFCB5 0150A790F000911                 sta             far [mon_numwka+1]
 FFFFFCBA 08E000820                       ldx             #Breakpoints                            
 FFFFFCBD 058                             aslb                                                                                    ; index for 2 byte values
 FFFFFCBE 058                             aslb
 FFFFFCBF 03A                             abx
 FFFFFCC0 1BE000910                       ldy             mon_numwka                                      ; get breakpoint address
 FFFFFCC3 1AF809000820                    sty             Breakpoints,x                           ; store the address in a table
 FFFFFCC7 1BE000912                       ldy             mon_numwka+2
 FFFFFCCA 1AF809000822                    sty             Breakpoints+2,x
 FFFFFCCE 054                             lsrb                                                                                    ; size back to single byte
 FFFFFCCF 054                             lsrb
 FFFFFCD0 05C                             incb
 FFFFFCD1 0F7000811                       stb             NumSetBreakpoints
 FFFFFCD4 035036                          puls    d,x,y
 FFFFFCD6 016FFF6E9                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
 
                              DisarmBreakpoint:
 FFFFFCD9 034076                          pshs    d,x,y,u
 FFFFFCDB 017FFF80F                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 FFFFFCDE 017FFF88D                       lbsr    GetHexNumber
*** warning 1: Long branch within short branch range could be optimized
 FFFFFCE1 05D                             tstb
 FFFFFCE2 12BFFF6DD                       lbmi    Monitor
*** warning 1: Long branch within short branch range could be optimized
 FFFFFCE5 05F                             clrb
 FFFFFCE6 05F                             clrb
 FFFFFCE7 01F001                          tfr             d,x                                                                     ; x = zero too
                              disarm6:
 FFFFFCE9 0150F1FFFFFFB2F                 cmpb    numBreakpoints                  ; no more than this many may be set
 FFFFFCEE 024045                          bhs             disarm4
 FFFFFCF0 0F1000811                       cmpb    NumSetBreakpoints               ; number actually set
 FFFFFCF3 024040                          bhs             disarm4
 FFFFFCF5 1AE809000820                    ldy             Breakpoints,x                           ; y = breakpoint address
 FFFFFCF9 1BC000912                       cmpy    mon_numwka+2                            ; is it the one we want?
 FFFFFCFC 026032                          bne             disarm3                                                 ; if not, go increment to next
 FFFFFCFE 0BE000912                       ldx             mon_numwka+2                            ; x = memory address
 FFFFFD01 18E000850                       ldy             #BreakpointBytes
 FFFFFD04 0A6A0D                          lda             b,y                                                                     ; get saved byte from table
 FFFFFD06 0A7804                          sta             ,x                                                                      ; set the byte at the memory address
                                      ; compress breakpoint table by removing breakpoint
 FFFFFD08 07A000811                       dec             NumSetBreakpoints               ; set the new number of set breakpoints
 FFFFFD0B 034004                          pshs    b                                                                               ; save the position we're removing from
                              disarm7:
 FFFFFD0D 05C                             incb                                                                                    ; set index for next byte
 FFFFFD0E 0A6A05                          lda             b,y                                                                     ; get byte
 FFFFFD10 05A                             decb                                                                                    ; and store it back
 FFFFFD11 0A7A05                          sta             b,y
 FFFFFD13 05C                             incb                                                                                    ; move to next position
 FFFFFD14 0150F1FFFFFFB2F                 cmpb    numBreakpoints                  ; hit end of table?
 FFFFFD19 025FF2                          blo             disarm7
 FFFFFD1B 035004                          puls    b                                                                               ; get back position
 FFFFFD1D 058                             aslb                                                                                    ; times two for word index
 FFFFFD1E 04F                             clra
 FFFFFD1F 01F002                          tfr             d,y
 FFFFFD21 054                             lsrb                                                                                    ; back to byte index value
                              disarm8:
 FFFFFD22 0EE202                          ldu             2,y                                                                     ; get next breakpoint address
 FFFFFD24 0EFA01                          stu             ,y++                                                            ; store in current pos, increment
 FFFFFD26 05C                             incb                                                                                    ; increment count
 FFFFFD27 0150F1FFFFFFB2F                 cmpb    numBreakpoints                  ; hit end of table?
 FFFFFD2C 025FF4                          blo             disarm8
 FFFFFD2E 0350F6                          puls    d,x,y,u,pc
                              disarm3:
 FFFFFD30 030002                          leax    2,x
 FFFFFD32 05C                             incb
 FFFFFD33 020FB4                          bra             disarm6
                              disarm4:
 FFFFFD35 035076                          puls    d,x,y,u
 FFFFFD37 016FFF688                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
 
                              ListBreakpoints:
 FFFFFD3A 034016                          pshs    d,x
 FFFFFD3C 03F                             swi
 FFFFFD3D 003                             fcb             MF_CRLF
 FFFFFD3E 08E000000                       ldx             #0
 FFFFFD41 0C6000                          ldb             #0
                              lbrk1:
 FFFFFD43 0150F1FFFFFFB2F                 cmpb    numBreakpoints
 FFFFFD48 024016                          bhs             lbrk2
 FFFFFD4A 0F1000811                       cmpb    NumSetBreakpoints
 FFFFFD4D 024011                          bhs             lbrk2
 FFFFFD4F 0EC809000820                    ldd             Breakpoints,x
 FFFFFD53 030002                          leax    2,x
 FFFFFD55 05C                             incb
 FFFFFD56 034004                          pshs    b
 FFFFFD58 03F                             swi
 FFFFFD59 006                             fcb             MF_DisplayWordAsHex
 FFFFFD5A 03F                             swi
 FFFFFD5B 003                             fcb             MF_CRLF
 FFFFFD5C 035004                          puls    b
 FFFFFD5E 020FE3                          bra             lbrk1
                              lbrk2:
 FFFFFD60 035016                          puls    d,x
 FFFFFD62 016FFF65D                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                               
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              DivTest:
 FFFFFD65 017FFF785                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 FFFFFD68 017FFF7B9                       lbsr    GetTwoParams
*** warning 1: Long branch within short branch range could be optimized
 FFFFFD6B 017FFD364                       lbsr    CRLF
*** warning 1: Long branch within short branch range could be optimized
 FFFFFD6E 0FC000922                       ldd             mon_r1+2
 FFFFFD71 2BD000927                       divd    mon_r2+3
 FFFFFD74 034006                          pshs    d
 FFFFFD76 0C603D                          ldb             #'='
 FFFFFD78 017FFF492                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 FFFFFD7B 0E6601                          ldb             1,s
 FFFFFD7D 017FFE6C7                       lbsr    DispByteAsHex
*** warning 1: Long branch within short branch range could be optimized
 FFFFFD80 0C6020                          ldb             #' '
 FFFFFD82 017FFF488                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 FFFFFD85 0E6E04                          ldb             ,s
 FFFFFD87 017FFE6BD                       lbsr    DispByteAsHex
*** warning 1: Long branch within short branch range could be optimized
 FFFFFD8A 032602                          leas    2,s
 FFFFFD8C 017FFD343                       lbsr    CRLF
*** warning 1: Long branch within short branch range could be optimized
 FFFFFD8F 016FFF630                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              dbg_rout:
                              swi3_rout:
 FFFFFD92 01A010                          sei
 FFFFFD94 0A6E04                          lda             ,s
 FFFFFD96 0B700090F                       sta             mon_CCRSAVE
 FFFFFD99 0EC601                          ldd             1,s
 FFFFFD9B 0FD000900                       std             mon_DSAVE
 FFFFFD9E 0E6603                          ldb             3,s
 FFFFFDA0 0F700090E                       stb             mon_DPRSAVE
 FFFFFDA3 0EC604                          ldd             4,s
 FFFFFDA5 0FD000902                       std             mon_XSAVE
 FFFFFDA8 0EC606                          ldd             6,s
 FFFFFDAA 0FD000904                       std             mon_YSAVE
 FFFFFDAD 0EC608                          ldd             8,s
 FFFFFDAF 0FD000906                       std             mon_USAVE
 FFFFFDB2 1FF000908                       sts             mon_SSAVE
 FFFFFDB5 0EC60B                          ldd             11,s
 FFFFFDB7 0FD00090A                       std             mon_PCSAVE
 FFFFFDBA 1FF000908                       sts             mon_SSAVE
 FFFFFDBD 1CE003FFF                       lds             #$3FFF
 FFFFFDC0 0CCFFFDCA                       ldd             #swi3_exit
 FFFFFDC3 034006                          pshs    d
 FFFFFDC5 01C0EF                          cli
 FFFFFDC7 07EFFF954                       jmp             DumpRegs
                              swi3_exit:
 FFFFFDCA 1FE000908                       lds             mon_SSAVE
 FFFFFDCD 03B                             rti
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              firq_rout:
 FFFFFDCE 03B                             rti
 
                              irq_rout:
 FFFFFDCF 14F                             clrd
 FFFFFDD0 01F00B                          tfr             d,dpr
                                      setdp   $000
 FFFFFDD2 017FFEF47                       lbsr    SerialIRQ               ; check for recieved character
*** warning 1: Long branch within short branch range could be optimized
 FFFFFDD5 017FFE6C8                       lbsr    TimerIRQ
*** warning 1: Long branch within short branch range could be optimized
 
 FFFFFDD8 0B6FFC01F                       lda             IrqBase                 ; get the IRQ flag byte
 FFFFFDDB 044                             lsra
 FFFFFDDC 0BAFFC01F                       ora             IrqBase
 FFFFFDDF 084FE0                          anda    #$FE0
 FFFFFDE1 0B7FFC01F                       sta             IrqBase
 
                              ;       inc             TEXTSCR+54              ; update IRQ live indicator on screen
                              ;       inc             TEXTSCR+$2000+54
                                      
                                      ; flash the cursor
                                      ; only bother to flash the cursor for the task with the IO focus.
 FFFFFDE4 0150B6FFFFFFF14                 lda             COREID
 FFFFFDE9 0B1FFC010                       cmpa    IOFocusID
 FFFFFDEC 02600D                          bne             tr1a
 FFFFFDEE 096114                          lda             CursorFlash             ; test if we want a flashing cursor
 FFFFFDF0 027009                          beq             tr1a
 FFFFFDF2 017FFE50B                       lbsr    CalcScreenLoc   ; compute cursor location in memory
*** warning 1: Long branch within short branch range could be optimized
 FFFFFDF5 01F002                          tfr             d,y
 FFFFFDF7 06CA09002000                    inc             $2000,y                 ; get color code $2000 higher in memory
                              tr1a:
 FFFFFDFB 03B                             rti
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              iop_rout:
 FFFFFDFC 03B                             rti
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              nmi_rout:
                              ipl4_rout:
                              ipl5_rout:
                              ipl6_rout:
                              ipl7_rout:
 FFFFFDFD 0150F6FFFFFFF14                 ldb             COREID
 FFFFFE02 086049                          lda             #'I'
 FFFFFE04 08EE00028                       ldx             #TEXTSCR+40
 FFFFFE07 0A7A0D                          sta             b,x
                              rti_insn:
                              ipl1_rout:
                              ipl2_rout:
                              ipl3_rout:
 FFFFFE09 03B                             rti
 
                              ; Special Register Area
                                      org             $FFFFFFF00
                                      
                              ; Extended vector table
 
                                      org             $FFFFFFFC0
 FFFFFFC0 FFFFFFFFFD92                    fcdw            dbg_rout
 FFFFFFC4 FFFFFFFFFDCF                    fcdw            irq_rout
 FFFFFFC8 FFFFFFFFFDCE                    fcdw            firq_rout
 FFFFFFCC FFFFFFFFFDCE                    fcdw            firq_rout
 FFFFFFD0 FFFFFFFFFDFD                    fcdw            ipl4_rout
 FFFFFFD4 FFFFFFFFFDFD                    fcdw            ipl5_rout
 FFFFFFD8 FFFFFFFFFDFD                    fcdw            ipl6_rout
 FFFFFFDC FFFFFFFFFDFD                    fcdw            ipl7_rout
 
                              ; Interrupt vector table
 
                                      org             $FFFFFFFE0
 FFFFFFE0 FFFFFFFFFDFC                    fcdw            iop_rout                ; illegal operation / divide by zero
 FFFFFFE4 FFFFFFFFFD92                    fcdw            swi3_rout               ; SWI3
 FFFFFFE8 FFFFFFFFFE09                    fcdw            rti_insn                ; SWI2
 FFFFFFEC FFFFFFFFFDCE                    fcdw            firq_rout               ; FIRQ
 FFFFFFF0 FFFFFFFFFDCF                    fcdw            irq_rout                ; IRQ
 FFFFFFF4 FFFFFFFFFB5D                    fcdw            swi_rout                ; SWI
 FFFFFFF8 FFFFFFFFFDFD                    fcdw            nmi_rout                ; NMI
 FFFFFFFC FFFFFFFFE023                    fcdw            start                           ; RST

140 warning(s) in pass 2.

SYMBOL TABLE
      ABD1 02 FFFFF64B      ABD2 02 FFFFF652      ACIA 00 FFE32000  ACIA_CMD 00 00000002
 ACIA_CTRL 00 00000003 ACIA_CTRL2 00 0000000B ACIA_IRQS 00 00000004  ACIA_MMU 00 00F196FF
   ACIA_RX 00 00000000 ACIA_STAT 00 00000001   ACIA_TX 00 00000000       ACK 00 00000006
      ARM1 02 FFFFFC57      ARM2 02 FFFFFC40 ARMALLBREAKPOINTS 02 FFFFFC37     ARMB1 02 FFFFFC7B
     ARMB2 02 FFFFFC7D     ARMB3 02 FFFFFC9F ARMBREAKPOINT 02 FFFFFC59 ASCIITOBINDIGIT 02 FFFFF645
 ASCIITODECDIGIT 02 FFFFF637 ASCIITOHEXNYBBLE 02 FFFFF60F    ASMBUF 00 00000160  BCDARITH 02 FFFFD447
  BCDDOADD 02 FFFFD47D  BCDDOMUL 02 FFFFD4A3  BCDDOSUB 02 FFFFD490 BIOS_SCREENS 00 17000000
 BLANKLINE 02 FFFFE28E BLKCPYDST 00 00000020 BLKCPYSRC 00 0000001C   BLNKLN1 02 FFFFE2A1
    BOOTPG 02 FFFFFB2C BOOT_STACK 02 FFFFFB2D BREAKPOINTBYTES 00 00000850 BREAKPOINTFLAG 00 00000810
 BREAKPOINTS 00 00000820    BRKAD0 00 FFFFFF00    BRKAD1 00 FFFFFF04    BRKAD2 00 FFFFFF08
    BRKAD3 00 FFFFFF0C  BRKCTRL0 00 FFFFFF10  BRKCTRL1 00 FFFFFF11  BRKCTRL2 00 FFFFFF12
  BRKCTRL3 00 FFFFFF13        BS 00 00000008  C19ABORT 00 0000094A C19ADDRESS 00 00000940
    C19BUF 00 00000980 C19CHECKSUM 00 0000094B  C19CRC24 00 00000954 C19CRCADDRESS 00 00000956
    C19GA1 02 FFFFEE61    C19GB1 02 FFFFEE24    C19GB2 02 FFFFEE45 C19GETADDRESS2 02 FFFFEE49
 C19GETBYTE 02 FFFFEE18    C19IC1 02 FFFFEDF8    C19IC2 02 FFFFEDF7 C19INPUTCHAR 02 FFFFEDE6
     C19L2 02 FFFFEF24     C19L3 02 FFFFEEDA     C19L4 02 FFFFEED2    C19LNR 02 FFFFEF16
 C19LOADER 02 FFFFEEC0 C19NEXTRECORD 02 FFFFEDFE    C19NR1 02 FFFFEE17    C19NR2 02 FFFFEE0B
    C19NR3 02 FFFFEE12    C19P11 02 FFFFEEBA    C19PM1 02 FFFFEEB3    C19PM3 02 FFFFEE66
    C19PM4 02 FFFFEE9E    C19PM5 02 FFFFEEA1 C19PROCESSS1 02 FFFFEEB6 C19PROCESSS9 02 FFFFEEBC
 C19PUTMEM 02 FFFFEE62 C19RECLEN 00 00000949 C19RECTYPE 00 00000948 C19SOURCE 00 0000094E
 C19STARTADDRESS 00 00000944 C19SUMMARYCHECKSUM 00 0000094C C19XFERADDRESS 00 00000950 CALCSCREENLOC 02 FFFFE300
 CALC_CRC24 02 FFFFEF4D CALC_CRC24A 02 FFFFEF65 CALC_CRC24B 02 FFFFEF57 CALC_CRC24C 02 FFFFEF52
       CAN 00 00000018 CHARCOLOR 00 00000112 CHARINVEC 00 00000804 CHAROUTVEC 00 00000800
 CHECKPOINT 02 FFFFE14B   CHECKPT 00 FFFFFF15 CLEARSCREEN 02 FFFFE247 CLEARSCREENJMP 02 FFFFD300
 CMDPROMPT 02 FFFFF392 CMDPROMPTJI 00 00000808 CMDTABLE1 02 FFFFF2F6 CMDTABLE2 02 FFFFF34E
 COLORCODELOCATION 00 00000014      COLS 00 00000040 COPYSCREENTOVIRTUALSCREEN 02 FFFFE217 COPYVIRTUALSCREENTOSCREEN 02 FFFFE1E0
    COREID 00 FFFFFF14        CR 00 0000000D CRC24_INIT 02 FFFFEF49 CRC24_POLY 02 FFFFEF4B
      CRLF 02 FFFFD0D2     CRLF1 02 FFFFD0D2    CRLFST 02 FFFFE432       CS1 02 FFFFE254
       CS2 02 FFFFE26B     CS2V1 02 FFFFE223       CS3 02 FFFFE271      CSL1 02 FFFFE31F
     CTRLC 00 00000003     CTRLH 00 00000008     CTRLI 00 00000009     CTRLJ 00 0000000A
     CTRLK 00 0000000B     CTRLM 00 0000000D     CTRLS 00 00000013     CTRLT 00 00000014
     CTRLX 00 00000018     CTRLZ 00 0000001A CURSORCOL 00 00000111 CURSORFLASH 00 00000114
 CURSORROW 00 00000110     CV2S1 02 FFFFE1F5 DBGCHECKFORKEY 02 FFFFEA90     DBGK1 02 FFFFEACB
    DBGK10 02 FFFFEB30    DBGK11 02 FFFFEB89    DBGK12 02 FFFFEB8F    DBGK13 02 FFFFEB9B
    DBGK14 02 FFFFEBAB    DBGK15 02 FFFFEBBA    DBGK16 02 FFFFEBC5    DBGK17 02 FFFFEBCE
    DBGK18 02 FFFFEBD1     DBGK2 02 FFFFEA96    DBGK20 02 FFFFEAB8    DBGK22 02 FFFFEAD4
    DBGK23 02 FFFFEAE5    DBGK24 02 FFFFEAC6     DBGK3 02 FFFFEAE8     DBGK4 02 FFFFEAF4
     DBGK5 02 FFFFEB00     DBGK7 02 FFFFEB10     DBGK8 02 FFFFEB16     DBGK9 02 FFFFEB2A
 DBGKNOTALT 02 FFFFEB93 DBGKNOTCAPSLOCK 02 FFFFEB62 DBGKNOTCTRL 02 FFFFEB1A DBGKNOTNUMLOCK 02 FFFFEB4B
 DBGKNOTRSHIFT 02 FFFFEB34 DBGKNOTSCROLLLOCK 02 FFFFEB79  DBG_ROUT 02 FFFFFD92      DCCR 02 FFFFE335
      DCLF 02 FFFFE3BF     DCX10 02 FFFFE36F     DCX11 02 FFFFE37F     DCX12 02 FFFFE37B
     DCX13 02 FFFFE38B     DCX14 02 FFFFE332      DCX3 02 FFFFE3AD      DCX4 02 FFFFE3C1
      DCX5 02 FFFFE39C      DCX6 02 FFFFE346      DCX7 02 FFFFE342      DCX8 02 FFFFE353
      DCX9 02 FFFFE360       DEL 00 0000007F   DELAY3S 02 FFFFE1C3      DFL1 02 FFFFFB1F
      DFL2 02 FFFFFB0C   DISARM1 02 FFFFFC35   DISARM2 02 FFFFFC21   DISARM3 02 FFFFFD30
   DISARM4 02 FFFFFD35   DISARM6 02 FFFFFCE9   DISARM7 02 FFFFFD0D   DISARM8 02 FFFFFD22
 DISARMALLBREAKPOINTS 02 FFFFFC18 DISARMBREAKPOINT 02 FFFFFCD9 DISPBYTEASHEX 02 FFFFE447 DISPDWORDASHEX 02 FFFFE435
 DISPLAYCHAR 02 FFFFE325 DISPLAYERR 02 FFFFF655 DISPLAYSTRING 02 FFFFE3E6 DISPLAYSTRINGCRLF 02 FFFFE40A
 DISPLAYSTRINGDX 02 FFFFF65E   DISPNYB 02 FFFFE45F  DISPNYB1 02 FFFFE46E DISPWORDASHEX 02 FFFFE43E
   DIVTEST 02 FFFFFD65    DLY3S1 02 FFFFE1C6    DLY3S2 02 FFFFE1CA     DMPM1 02 FFFFF8A8
     DMPM2 02 FFFFF893     DMPM3 02 FFFFF8E1     DMPM4 02 FFFFF8D3     DMPM5 02 FFFFF8CB
 DRAM_BASE 00 10000000    DSPJ1B 02 FFFFE3FA     DSPJ2 02 FFFFE3F3    DSRETB 02 FFFFE403
 DUMPIOFOCUSLIST 02 FFFFFB09 DUMPMEMORY 02 FFFFF88B  DUMPREGS 02 FFFFF954    DUMRTS 02 FFFFE022
  EDITMEM1 02 FFFFF908  EDITMEM2 02 FFFFF8F3  EDITMEM3 02 FFFFF927  EDITMEM4 02 FFFFF912
  EDITMEM6 02 FFFFF91E EDITMEMORY 02 FFFFF8E7 ENDOFWORD 02 FFFFF48F       EOT 00 00000004
       ETB 00 00000017   FARFLAG 00 0000015F    FILLM1 02 FFFFF93A    FILLM2 02 FFFFF94A
    FILLM3 02 FFFFF951 FILLMEMORY 02 FFFFF92A FIRQ_ROUT 02 FFFFFDCE FIRST_CORE 00 00000001
   FREEMBX 02 00000002   FREEMSG 02 00000006   FREETCB 00 0000078A GETBINNUMBER 02 FFFFF59D
 GETDECNUMBER 02 FFFFF5C3 GETHEXNUMBER 02 FFFFF56E    GETKEY 02 FFFFEA92 GETNUMBER 02 FFFFF601
  GETRANGE 02 FFFFF545 GETSCREENLOCATION 02 FFFFE2A8 GETTWOPARAMS 02 FFFFF524     GRNG1 02 FFFFF560
      GSL1 02 FFFFE2BA    GTBIN1 02 FFFFF5BF    GTBIN2 02 FFFFF5A9     GTDC3 02 FFFFF642
    GTDEC1 02 FFFFF5FD    GTDEC2 02 FFFFF5CF     GTHX3 02 FFFFF634     GTHX5 02 FFFFF61A
     GTHX6 02 FFFFF627    GTHXN1 02 FFFFF599    GTHXN2 02 FFFFF57A       HC1 02 FFFFE2D8
   HELPMSG 02 FFFFF66E      HEX2 02 FFFFD2CE      HEX4 02 FFFFD2D2 HOMECURSOR 02 FFFFE2BE
 HOMECURSORJMP 02 FFFFD308     I2CW1 02 FFFFE50C    I2CWR1 02 FFFFE539   I2C_CMD 00 00000004
  I2C_CTRL 00 00000002  I2C_INIT 02 FFFFE500  I2C_PREH 00 00000001  I2C_PREL 00 00000000
   I2C_RXR 00 00000003  I2C_STAT 00 00000004   I2C_TXR 00 00000003 I2C_WAIT_RX_NACK 02 FFFFE537
 I2C_WAIT_TIP 02 FFFFE50A I2C_WR_CMD 02 FFFFE514 I2C_XMIT1 02 FFFFE51D      ICC1 02 FFFFE3E2
      ICC2 02 FFFFE3E4      ICR1 02 FFFFE3D4 IGNBLANKS 02 FFFFF4ED IGNBLANKS1 02 FFFFF4ED
     IMMU1 02 FFFFD4C4     IMMU2 02 FFFFD4FA     IMMU3 02 FFFFD512 INCCURSORPOS 02 FFFFE3C3
 INCCURSORROW 02 FFFFE3D2      INCH 02 FFFFF1D7     INCH1 02 FFFFF1EC     INCH2 02 FFFFF1D9
     INCHE 02 FFFFF1F5    INCHEK 02 FFFFF1F9   INCHEK1 02 FFFFF20C   INCHEK2 02 FFFFF209
   INCHEK3 02 FFFFF200      INIT 02 FFFFE0B1     INIT1 02 FFFFE0B6     INIT2 02 FFFFE104
   INITMMU 02 FFFFD4B7 INITSERIAL 02 FFFFEBEF IOFOCUSID 00 00FFC010 IOFOCUSLIST 00 00FFC000
 IOFOCUSNDX 00 00000100  IOP_ROUT 02 FFFFFDFC   IO_PAGE 00 FFE00000 IPL1_ROUT 02 FFFFFE09
 IPL2_ROUT 02 FFFFFE09 IPL3_ROUT 02 FFFFFE09 IPL4_ROUT 02 FFFFFDFD IPL5_ROUT 02 FFFFFDFD
 IPL6_ROUT 02 FFFFFDFD IPL7_ROUT 02 FFFFFDFD   IRQBASE 00 00FFC01F   IRQFLAG 00 00FFC012
 IRQSOURCE 00 00FFC011  IRQ_ROUT 02 FFFFFDCF    JMPVEC 00 00000928  JTC_EXIT 02 FFFFFACC
 JUMP_TO_CODE 02 FFFFFA92 KBDBUFFULL 02 FFFFEA8D   KBDFIFO 00 00000040 KBDFIFOALIAS 00 00C00040
 KBDHEADRCV 00 00000127  KBDI0002 02 FFFFE9C9  KBDI0004 02 FFFFEA0E KBDITRYAGAIN 02 FFFFEA02
 KBDRCVCOUNT 02 FFFFEA3D KBDTAILRCV 00 00000128     KBGS1 02 FFFFE978     KBGS2 02 FFFFE970
     KBGS3 02 FFFFE961     KEYBD 00 FFE30000  KEYBDACK 00 00FFCC00  KEYBDBAD 00 00FFCB00
 KEYBDBLOCK 00 00000126 KEYBDBUFFER 00 00FFC000 KEYBDCHECKFORKEYDIRECT 02 FFFFF1D5 KEYBDCLOSE 02 FFFFEBEB
  KEYBDCLR 00 FFE30002 KEYBDCONTROLCODES 02 FFFFE800 KEYBDECHO 00 00FFCA00 KEYBDEXTENDEDCODES 02 FFFFE880
 KEYBDGETID 02 FFFFE99C KEYBDGETSCANCODE 02 FFFFE97D KEYBDGETSTATUS 02 FFFFE961 KEYBDHEAD 00 00FFC800
   KEYBDID 00 00000124 KEYBDINIT 02 FFFFE9C0  KEYBDIRQ 02 FFFFEA4F KEYBDLOCKS 00 00FFCD00
 KEYBDOPEN 02 FFFFEBEA KEYBDREAD 02 FFFFEBEC KEYBDRECVBYTE 02 FFFFE900 KEYBDSEEK 02 FFFFEBEE
 KEYBDSENDBYTE 02 FFFFE919 KEYBDSETLED 02 FFFFE989 KEYBDTAIL 00 00FFC900 KEYBDWAITTX 02 FFFFE91F
 KEYBDWRITE 02 FFFFEBED    KEYLED 00 00000122 KEYSTATE1 00 00000120 KEYSTATE2 00 00000121
     KGID1 02 FFFFE9B9  KGNOTKBD 02 FFFFE9BC      KRB3 02 FFFFE905      KRB4 02 FFFFE915
    KRCXIT 02 FFFFEA4E      KWT1 02 FFFFE924      KWT2 02 FFFFE935     LBRK1 02 FFFFFD43
     LBRK2 02 FFFFFD60      LEDS 00 FFE60001    LEDXIT 02 FFFFEA22    LETTER 02 FFFFD2C1
        LF 00 0000000A LISTBREAKPOINTS 02 FFFFFD3A MAX_TASKNO 00 0000003F   MF_CRLF 00 00000003
 MF_DISPLAYBYTEASHEX 00 00000005 MF_DISPLAYSTRING 00 00000004 MF_DISPLAYWORDASHEX 00 00000006 MF_GETNUMBER 00 0000000C
 MF_GETRANGE 00 0000000B   MF_INCH 00 00000001 MF_MONITOR 00 00000000 MF_OSCALL 00 0000000A
  MF_OUTCH 00 00000002 MF_RANDOM 00 00000009 MF_SERIALPUTCHAR 00 0000000D MF_SHOWSPRITES 00 00000007
  MF_SRAND 00 00000008 MILLISECONDS 00 00FFC014       MMU 00 FFE38000  MMU_AKEY 00 FFFFFF16
  MMU_OKEY 00 FFFFFF17      MON1 02 FFFFF42D MONARMBREAKPOINT 02 FFFFF4DC MONDISARMBREAKPOINT 02 FFFFF4E7
 MONERRVEC 00 0000080C  MONGETCH 02 FFFFF4D0 MONGETNONSPACE 02 FFFFF4D5   MONITOR 02 FFFFF3C2
 MON_CCRSAVE 00 0000090F MON_DPRSAVE 00 0000090E MON_DSAVE 00 00000900  MON_INIT 00 0000092C
 MON_NUMWKA 00 00000910 MON_PCSAVE 00 0000090A    MON_R1 00 00000920    MON_R2 00 00000924
  MON_RAND 02 FFFFF2D8 MON_RETFLAG 00 00000930 MON_RETTAB 02 FFFFFB4F MON_ROM_VECS 02 FFFFFB33
 MON_ROM_VECTAB 02 FFFFFB31 MON_SRAND 02 FFFFF2A8 MON_SRAND1 02 FFFFF2B9 MON_SSAVE 00 00000908
 MON_USAVE 00 00000906 MON_VECTB 00 00000880 MON_XSAVE 00 00000902 MON_YSAVE 00 00000904
   MSCOUNT 00 FFFFFF18 MSGBADKEYBD 02 FFFFEA2E MSGC19LOADER 02 FFFFEF27 MSGCRCERR 02 FFFFEF3B
 MSGDBREGHEADINGS 02 FFFFF84B    MSGERR 02 FFFFF666 MSGF09STARTING 02 FFFFF39D MSGREGHEADINGS 02 FFFFF811
 MSGSERIALTEST 02 FFFFEDD3 MSGSTARTUP 02 FFFFE12A MSGXMNOTRANSMITTER 02 FFFFF0F8 MSGXMTIMEOUT 02 FFFFF0E4
 MULTI_SIEVE 02 FFFFE161 MULTI_SIEVE1 02 FFFFE184 MULTI_SIEVE2 02 FFFFE180 MULTI_SIEVE3 02 FFFFE16E
 MULTI_SIEVE4 02 FFFFE197       NAK 00 00000015     NHEX4 02 FFFFF882  NMAILBOX 02 00000004
 NMESERIAL 02 FFFFED9C   NMIBASE 00 00FFC01E  NMI_ROUT 02 FFFFFDFD   NMSGBLK 02 00000008
 NOTKBDIRQ 02 FFFFEA8C  NOTRXINT 02 FFFFED8A NOTRXINT1 02 FFFFED78 NOTSERINT 02 FFFFED8A
 NOTTIMERIRQ 02 FFFFE4EF NUMBREAKPOINTS 02 FFFFFB2F  NUMFUNCS 00 0000000F NUMOSFUNCS 00 00000019
 NUMSETBREAKPOINTS 00 00000811   NXBLANK 02 FFFFF886    ONEKEY 02 FFFFD1DC   OPC_SWI 00 0000003F
      OSC1 02 FFFFFC0F OSCALLTBL 02 FFFFF22F      OSCX 02 FFFFFC11    OSSEMA 00 FFEF0010
     OUTCH 02 FFFFF20D   OUTSEMA 00 FFEF0000 PARSECMD1 02 FFFFF47A     PCRLF 02 FFFFE41E
     PDATA 02 FFFFE42B       PIC 00 FFE3E000    PICPTR 00 00000028   PIC_MMU 00 00F1F6FF
     PRINT 02 FFFFE428      PRNG 00 FFE36000  PRNG_MMU 00 0071B6FF PROCESSBREAKPOINT 02 FFFFFBC2
   PROMPT1 02 FFFFF45D  PROMPT2A 02 FFFFF4AE   PROMPT3 02 FFFFF44B PROMPTCLEARSCREEN 02 FFFFF4C8
 PROMPTHELP 02 FFFFF4C0  PROMPTLN 02 FFFFF447    PSTRNG 02 FFFFE41A     QNDX0 00 00000780
     QNDX1 00 00000782     QNDX2 00 00000784     QNDX3 00 00000786     QNDX4 00 00000788
    RAMERR 02 FFFFD42C   RAMERR1 02 FFFFD445   RAMTEST 02 FFFFD400  RAMTEST1 02 FFFFD40D
  RAMTEST3 02 FFFFD417  REDIRECT 02 FFFFF49A RELEASEIOFOCUS 02 FFFFF278 REQUESTIOFOCUS 02 FFFFF261
     RIOF1 02 FFFFF29F     RIOF2 02 FFFFF28E  ROMTORAM 02 FFFFE151 ROMTORAM1 02 FFFFE157
      ROWS 00 00000020       RTC 00 FFE34000    RTCBUF 00 00007FC0  RTCR0001 02 FFFFE567
  RTCW0001 02 FFFFE5B1  RTC_READ 02 FFFFE541 RTC_RXERR 02 FFFFE58F RTC_WRITE 02 FFFFE593
  RTI_INSN 02 FFFFFE09 RUNNINGID 00 00FFC013 RUNNINGTCB 06 00000000 SCANNEXTWORD 02 FFFFF484
 SCREENCOLOR 00 00000113 SCREENDISPLAYCHAR 02 FFFFE328 SCREENLOCATION 00 00000010 SCREENLOCATION2 00 00000018
  SCROLLUP 02 FFFFE273    SCRUP1 02 FFFFE280    SC_ALT 00 00000011      SC_C 00 00000021
 SC_CAPSLOCK 00 00000058   SC_CTRL 00 00000014    SC_DEL 00 00000071 SC_EXTEND 00 000000E0
    SC_F12 00 00000007  SC_KEYUP 00 000000F0 SC_NUMLOCK 00 00000077 SC_RSHIFT 00 00000059
 SC_SCROLLLOCK 00 0000007E      SC_T 00 0000002C    SC_TAB 00 0000000D      SC_Z 00 0000001A
   SEMAABS 00 00001000  SEMA_MMU 00 00F786FF SERHEADRCV 00 00FFC018 SERHEADXMIT 00 00FFC01A
  SERHZERO 00 00000130 SERIALGETCHAR 02 FFFFEC37 SERIALINIT 02 FFFFEBEF SERIALIRQ 02 FFFFED1C
 SERIALOUTPUTTEST 02 FFFFEDB3 SERIALPEEKCHAR 02 FFFFEC6F SERIALPEEKCHARDIRECT 02 FFFFEC8F SERIALPUTCHAR 02 FFFFECD0
 SERIALPUTSTRING 02 FFFFEDA3 SERIALRCVCOUNT 02 FFFFED09 SERRCVBUF 00 00FFB000 SERRCVXOFF 00 00FFC01D
 SERRCVXON 00 00FFC01C SERTAILRCV 00 00FFC019 SERTAILXMIT 00 00FFC01B  SERTZERO 00 00000132
 SETKEYBOARDECHO 02 FFFFF211   SETREGA 02 FFFFF9F6   SETREGB 02 FFFFFA05 SETREGCCR 02 FFFFFA6E
   SETREGD 02 FFFFFA14 SETREGDPR 02 FFFFFA5F  SETREGPC 02 FFFFFA7D   SETREGS 02 FFFFFA50
   SETREGU 02 FFFFFA41   SETREGX 02 FFFFFA23   SETREGY 02 FFFFFA32      SGC2 02 FFFFEC55
 SGCNOCHARS 02 FFFFEC6A    SGCXIT 02 FFFFEC6D SHIFTEDSCANCODES 02 FFFFE700 SHIFTLEFT5 02 FFFFE1D5
 SHL_NUMWKA 02 FFFFF561 SHOWSPRITES 02 FFFFF215     SIEVE 02 FFFFE19B    SIEVE1 02 FFFFE1B3
    SIEVE2 02 FFFFE1AF    SIEVE3 02 FFFFE1A0    SIEVE4 02 FFFFE1C2     SINI1 02 FFFFEC0F
 SIRQNXTBYTE 02 FFFFED38 SIRQRXFULL 02 FFFFED8A SKIPDOLLAR 02 FFFFF46C SKIP_INIT 02 FFFFE118
       SOH 00 00000001    SOTST1 02 FFFFEDBD   SPC0001 02 FFFFECD7  SPCD0001 02 FFFFECC3
 SPCNOCHARS 02 FFFFEC8A    SPCXIT 02 FFFFEC8D SPRITE_CTRL 00 FFE10000 SPRITE_EN 00 000003C0
 SPRITE_MMU 00 00F086FF      SPS2 02 FFFFEDA7    SPSXIT 02 FFFFEDB1    SRCXIT 02 FFFFED1B
       ST1 02 FFFFE0C8      ST10 02 FFFFE126      ST11 02 FFFFE069       ST3 02 FFFFE0A8
       ST6 02 FFFFE042       ST7 02 FFFFE04C       ST8 02 FFFFE04C       ST9 02 FFFFE072
     START 02 FFFFE023    STRPTR 00 00000024 SWI3_EXIT 02 FFFFFDCA SWI3_ROUT 02 FFFFFD92
 SWICALLOS 02 FFFFFBFC SWINOTBKPT 02 FFFFFB7A  SWI_ROUT 02 FFFFFB5D SWI_ROUT1 02 FFFFFB62
 SWI_ROUT2 02 FFFFFB73 SWI_ROUT3 02 FFFFFBB0 SWI_ROUT4 02 FFFFFBC1       TAB 00 00000009
 TCB_CURSORCOL 00 00000021 TCB_CURSORROW 00 00000020  TCB_HJCB 00 0000001C TCB_HWAITMBX 00 00000022
 TCB_IOF_NEXT 00 0000002C TCB_IOF_PREV 00 00000030 TCB_MBQ_NEXT 00 00000024 TCB_MBQ_PREV 00 00000028
 TCB_MMU_MAP 00 00000038 TCB_MSGPTR_D1 00 00000014 TCB_MSGPTR_D2 00 00000018 TCB_NXTRDY 00 00000000
 TCB_NXTTCB 00 00000008 TCB_PRIORITY 00 00000010 TCB_PRVRDY 00 00000004 TCB_SPSAVE 00 00000034
 TCB_STATUS 00 0000001E TCB_TIMEOUT 00 0000000C TEXTCLOSE 02 FFFFE243  TEXTOPEN 02 FFFFE242
  TEXTREAD 02 FFFFE244   TEXTREG 00 FFE07F00   TEXTSCR 00 FFE00000  TEXTSEEK 02 FFFFE246
 TEXTWRITE 02 FFFFE245 TEXT_COLS 00 00000000 TEXT_CURPOS 00 00000022 TEXT_ROWS 00 00000001
 TIMEOUTLIST 00 0000078C TIMERINIT 02 FFFFE475  TIMERIRQ 02 FFFFE4A0   TIMES10 02 FFFFF4F6
      TR1A 02 FFFFFDFB      UCP1 02 FFFFE2FE UNSHIFTEDSCANCODES 02 FFFFE600 UPDATECURSORPOS 02 FFFFE2DA
       VIA 00 FFE60000   VIA_ACR 00 0000000B  VIA_DDRA 00 00000003   VIA_IER 00 0000000E
   VIA_IFR 00 0000000D   VIA_MMU 00 00F306FF    VIA_PA 00 00000001  VIA_T3CH 00 00000011
  VIA_T3CL 00 00000010 VIA_T3CMPH 00 00000015 VIA_T3CMPL 00 00000014  VIA_T3LH 00 00000013
  VIA_T3LL 00 00000012  W10_0001 02 FFFFE940 W300_0001 02 FFFFE954  WAIT10MS 02 FFFFE939
 WAIT300MS 02 FFFFE94D    XBLANK 02 FFFFD0AF XITMONITOR 02 FFFFFBFA XM_CALC_CHECKSUM 02 FFFFF11D
 XM_CALC_CRC 02 FFFFF12F XM_CHECKSUM 00 000009F7    XM_CRC 00 000009FE   XM_CRC1 02 FFFFF13A
   XM_CRC2 02 FFFFF196   XM_CRC3 02 FFFFF19E   XM_CRC4 02 FFFFF181    XM_CS1 02 FFFFF121
    XM_EOT 02 FFFFF0C4   XM_FLAG 00 000009F6    XM_GB1 02 FFFFEFEB    XM_GB2 02 FFFFEFFB
 XM_GETBYTE 02 FFFFEFEB   XM_IBUF 00 00000A00 XM_NOTRANSMITTER 02 FFFFF0DC   XM_OBUF 00 00000A80
 XM_OUTBYTEASHEX 02 FFFFF1B6 XM_PACKETNUM 00 000009FA XM_PROTOCOL 00 000009F5   XM_RCV1 02 FFFFF025
   XM_RCV2 02 FFFFF05B   XM_RCV3 02 FFFFF0A0   XM_RCV4 02 FFFFF020   XM_RCV5 02 FFFFF01B
 XM_RCV_CHKSUM 02 FFFFF098 XM_RCV_NAK 02 FFFFF03A XM_RCV_TO1 02 FFFFF0BC XM_RCV_TO2 02 FFFFF0BA
 XM_RECEIVE 02 FFFFF019 XM_RECEIVESTART 02 FFFFEFFE XM_RETRY1 02 FFFFF0CB   XM_SEND 02 FFFFEF7B
  XM_SEND1 02 FFFFEF9A  XM_SEND2 02 FFFFEFC8  XM_SEND3 02 FFFFEFCF  XM_SEND4 02 FFFFEF8B
  XM_SEND5 02 FFFFEF88 XM_SENDSTART 02 FFFFEF6E    XM_SOH 02 FFFFF040  XM_TIMER 00 FFFFC020
    XM_TMP 00 000009FC   XM_TMP2 00 000009F8      XOFF 00 00000013       XON 00 00000011
704 SYMBOLS

3 error(s), 1258 warning(s)
