3 error(s), 894 warning(s) unlisted in pass 1
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2013-2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; BSD 3-Clause License
                              ; Redistribution and use in source and binary forms, with or without
                              ; modification, are permitted provided that the following conditions are met:
                              ;
                              ; 1. Redistributions of source code must retain the above copyright notice, this
                              ;    list of conditions and the following disclaimer.
                              ;
                              ; 2. Redistributions in binary form must reproduce the above copyright notice,
                              ;    this list of conditions and the following disclaimer in the documentation
                              ;    and/or other materials provided with the distribution.
                              ;
                              ; 3. Neither the name of the copyright holder nor the names of its
                              ;    contributors may be used to endorse or promote products derived from
                              ;    this software without specific prior written permission.
                              ;
                              ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                              ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                              ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                              ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                              ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                              ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                              ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                              ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                              ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                              ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                              ;                                                                          
                              ; ============================================================================
                              ;
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2013-2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; BSD 3-Clause License
                              ; Redistribution and use in source and binary forms, with or without
                              ; modification, are permitted provided that the following conditions are met:
                              ;
                              ; 1. Redistributions of source code must retain the above copyright notice, this
                              ;    list of conditions and the following disclaimer.
                              ;
                              ; 2. Redistributions in binary form must reproduce the above copyright notice,
                              ;    this list of conditions and the following disclaimer in the documentation
                              ;    and/or other materials provided with the distribution.
                              ;
                              ; 3. Neither the name of the copyright holder nor the names of its
                              ;    contributors may be used to endorse or promote products derived from
                              ;    this software without specific prior written permission.
                              ;
                              ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                              ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                              ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                              ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                              ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                              ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                              ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                              ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                              ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                              ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                              ;                                                                          
                              ; ============================================================================
                              ;
                              ; ASCII control characters.
                              SOH             equ 1
                              EOT             equ 4
                              ACK             equ 6
                              BS              equ 8
                              NAK             equ 21
                              ETB             equ     $17
                              CAN             equ 24
                              DEL             equ 127
 
                              CR      EQU     $0D             ;ASCII equates
                              LF      EQU     $0A
                              TAB     EQU     $09
                              CTRLC   EQU     $03
                              CTRLH   EQU     $08
                              CTRLI   EQU     $09
                              CTRLJ   EQU     $0A
                              CTRLK   EQU     $0B
                              CTRLM   EQU $0D
                              CTRLS   EQU     $13
                              CTRLT EQU $14
                              CTRLX   EQU     $18
                              CTRLZ   EQU     $1A
                              XON             EQU     $11
                              XOFF    EQU     $13
 
                              FIRST_CORE      EQU     1
                              MAX_TASKNO      EQU 63
                              DRAM_BASE       EQU $10000000
 
                              ; ROM monitor functions
                              ;
                              MF_Monitor      EQU             0
                              MF_INCH                 EQU             1
                              MF_OUTCH                EQU     2
                              MF_CRLF                 EQU             3
                              MF_DisplayString        EQU             4
                              MF_DisplayByteAsHex             EQU     5
                              MF_DisplayWordAsHex             EQU     6
                              MF_ShowSprites  EQU             7
                              MF_Srand                EQU             8
                              MF_Random               EQU             9
                              MF_OSCALL               EQU             10
                              MF_GetRange     EQU             11      ; gets a pair of numbers last>first
                              MF_GetNumber    EQU     12
                              MF_SerialPutchar        EQU     13
 
                              mon_numwka      EQU             $910
                              mon_r1          EQU             $920
                              mon_r2          EQU             $924
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) S2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; BSD 3-Clause License
                              ; Redistribution and use in source and binary forms, with or without
                              ; modification, are permitted provided that the following conditions are met:
                              ;
                              ; 1. Redistributions of source code must retain the above copyright notice, this
                              ;    list of conditions and the following disclaimer.
                              ;
                              ; 2. Redistributions in binary form must reproduce the above copyright notice,
                              ;    this list of conditions and the following disclaimer in the documentation
                              ;    and/or other materials provided with the distribution.
                              ;
                              ; 3. Neither the name of the copyright holder nor the names of its
                              ;    contributors may be used to endorse or promote products derived from
                              ;    this software without specific prior written permission.
                              ;
                              ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                              ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                              ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                              ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                              ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                              ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                              ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                              ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                              ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                              ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                              ;                                                                          
                              ; ============================================================================
 
                              COREID  EQU             $FFFFFFFE0
                              MSCOUNT EQU             $FFFFFFFE4
                              LEDS            EQU             $FFFE60001
                              VIA                     EQU             $FFFE60000
                              VIA_PA          EQU             1
                              VIA_DDRA        EQU             3
                              VIA_ACR                 EQU             11
                              VIA_IFR                 EQU             13
                              VIA_IER                 EQU             14
                              VIA_T3LL                EQU             18
                              VIA_T3LH                EQU             19
                              VIA_T3CMPL      EQU             20
                              VIA_T3CMPH      EQU             21
                              TEXTSCR         EQU             $FFFE00000
                              TEXTREG         EQU             $FFFE07F00
                              TEXT_COLS       EQU             0
                              TEXT_ROWS       EQU             1
                              TEXT_CURPOS     EQU             34
                              COLS            EQU             64
                              ROWS            EQU             32
                              ACIA            EQU             $FFFE30100
                              ACIA_TX         EQU             0
                              ACIA_RX         EQU             0
                              ACIA_STAT       EQU             1
                              ACIA_CMD        EQU             2
                              ACIA_CTRL       EQU             3
                              ACIA_IRQS       EQU             4
                              ACIA_CTRL2      EQU             11
                              RTC                             EQU             $FFFE30500      ; I2C
                              RTCBuf          EQU             $7FC0
                              PRNG            EQU             $FFFE30600
                              KEYBD           EQU             $FFFE30400
                              KEYBDCLR        EQU             $FFFE30402
                              PIC                     EQU             $FFFE3F000
                              SPRITE_CTRL             EQU             $FFFE10000
                              SPRITE_EN                       EQU             $3C0
 
                              OUTSEMA EQU     $EF0000
                              SEMAABS EQU     $1000
                              OSSEMA  EQU     $EF0010
 
                              OPC_SWI                         EQU             $03F
                              ScreenLocation          EQU             $10
                              ColorCodeLocation       EQU             $14
                              ScreenLocation2         EQU             $18
                              BlkcpySrc                       EQU             $1C
                              BlkcpyDst                       EQU             $20
                              Strptr                          EQU             $24
                              PICptr                          EQU             $28
                              ; Forth Area
                              ; 0x30-0x60
 
                              ; Task control blocks, room for 256 tasks
                              TCB_NxtRdy              EQU             $00     ; next task on ready / timeout list
                              TCB_PrvRdy              EQU             $04     ; previous task on ready / timeout list
                              TCB_NxtTCB              EQU             $08
                              TCB_Timeout             EQU             $0C
                              TCB_Priority    EQU             $10
                              TCB_MSGPTR_D1   EQU             $14
                              TCB_MSGPTR_D2   EQU             $18
                              TCB_hJCB                        EQU             $1C
                              TCB_Status              EQU             $1E
                              TCB_CursorRow   EQU             $20
                              TCB_CursorCol   EQU             $21
                              TCB_hWaitMbx    EQU             $22     ; handle of mailbox task is waiting at
                              TCB_mbq_next    EQU             $24     ; mailbox queue next
                              TCB_mbq_prev    EQU             $28     ; mailbox queue previous
                              TCB_iof_next    EQU             $2C
                              TCB_iof_prev    EQU             $30
                              TCB_SPSave              EQU             $34     ; TCB_SPSave area
                              TCB_mmu_map             EQU             $38
 
                              KeybdHead               EQU             $FFFFFC800
                              KeybdTail               EQU             $FFFFFC900
                              KeybdEcho               EQU             $FFFFFCA00
                              KeybdBad                EQU             $FFFFFCB00
                              KeybdAck                EQU             $FFFFFCC00
                              KeybdLocks              EQU             $FFFFFCD00
                              KeybdBuffer             EQU             $FFFFFC000      ; buffer is 16 chars
 
                              BIOS_SCREENS    EQU     $17000000       ; $17000000 to $171FFFFF
 
                              ; EhBASIC vars:
                              ;
                              NmiBase         EQU             $FFC013
                              IrqBase         EQU             $FFC014
 
                              IOFocusNdx      EQU             $100
 
                              ; These variables in global OS storage area
 
                              IOFocusList     EQU             $FFC000 ; to $FF000F
                              IOFocusID               EQU             $FFC010
                              IrqSource               EQU             $FFC011
                              IRQFlag                 EQU             $FFC012
                              RunningID               EQU             $FFC013
                              milliseconds    EQU             $FFC014
 
                              ; One copy of serial buffer management
                              ; 1 serial buffer for system.
                              SerHeadRcv      EQU     $FFC015
                              SerTailRcv      EQU     $FFC016
                              SerHeadXmit     EQU     $FFC017
                              SerTailXmit     EQU     $FFC018
                              SerRcvXon               EQU     $FFC019
                              SerRcvXoff      EQU     $FFC01A
                              SerRcvBuf               EQU     $FFB000 ; 4kB serial recieve buffer
 
                              ; Top of boot stack is at $FFC0FF
 
                              ; These variables use direct page access
                              CursorRow       EQU             $110
                              CursorCol       EQU             $111
                              CharColor       EQU             $112
                              ScreenColor     EQU             $113
                              CursorFlash     EQU             $114
                              KeyState1       EQU     $120
                              KeyState2       EQU     $121
                              KeyLED          EQU     $122
                              KeybdID         EQU     $124
                              KeybdBlock      EQU     $126
                              kbdHeadRcv      EQU     $127
                              kbdTailRcv      EQU     $128
                              kbdFifo                 EQU     $40                             ; in local RAM
                              kbdFifoAlias    EQU     $C00040 ; to $C0007F    ; alias for $40 to $7F
                              SerhZero                EQU     $130
                              SertZero                EQU     $132
 
 
                              farflag EQU             $15F
                              asmbuf  EQU             $160    ; to $17F
 
                              QNdx0           EQU             $780
                              QNdx1           EQU             QNdx0+2
                              QNdx2           EQU             QNdx1+2
                              QNdx3           EQU             QNdx2+2
                              QNdx4           EQU             QNdx3+2
                              FreeTCB         EQU             QNdx4+2
                              TimeoutList     EQU             FreeTCB+2
                              FreeMbx         EQU             RunningTCB + 2
                              nMailbox        EQU             FreeMbx + 2
                              FreeMsg         EQU             nMailbox + 2
                              nMsgBlk         EQU             FreeMsg + 2
 
 
                              CharOutVec      EQU             $800
                              CharInVec       EQU             $804
                              CmdPromptJI     EQU     $808
                              MonErrVec       EQU             $80C
                              BreakpointFlag  EQU             $810
                              NumSetBreakpoints       EQU     $811    ; to 812
                              Breakpoints                     EQU             $820    ; to $82F
                              BreakpointBytes EQU             $830    ; to $83F
                              mon_vectb                               EQU             $880
 
                              ; Register save area for monitor
                              mon_DSAVE       EQU             $900
                              mon_XSAVE       EQU             $902
                              mon_YSAVE       EQU             $904
                              mon_USAVE       EQU             $906
                              mon_SSAVE       EQU             $908
                              mon_PCSAVE      EQU             $90A
                              mon_DPRSAVE     EQU             $90E
                              mon_CCRSAVE     EQU             $90F
 
                              mon_numwka      EQU             $910
                              mon_r1          EQU             $920
                              mon_r2          EQU             $924
                              jmpvec          EQU             $928
                              mon_init        EQU             $92C
                              mon_retflag     EQU     $930
 
                              ; The ORG directive must set an address a multiple of 4 in order for the Verilog
                              ; output to work correctly.
 
                                      org             $FFD0AC
 00FFD0AC 012                             nop
 00FFD0AD 012                             nop
 00FFD0AE 012                             nop
                              XBLANK
 00FFD0AF 0C6020                          ldb             #' '
 00FFD0B1 017002115                       lbsr    OUTCH
 00FFD0B4 039                             rts
 
                                      org             $FFD0D0
 00FFD0D0 012                             nop
 00FFD0D1 012                             nop
                              CRLF
                              CRLF1:
 00FFD0D2 0C600D                          ldb             #CR
 00FFD0D4 0170020F2                       lbsr    OUTCH
 00FFD0D7 0C600A                          ldb             #LF
 00FFD0D9 0170020ED                       lbsr    OUTCH
 00FFD0DC 039                             rts
 
                                      org             $FFD0F0
 00FFD0F0 012                             nop
 00FFD0F1 020FDF                          bra             CRLF1
 
                                      org             $FFD1DC
                              ONEKEY
 00FFD1DC 06E90F000804                    jmp             [CharInVec]
 
                                      org             $FFD2C0
 00FFD2C0 012                             nop
                              LETTER
 00FFD2C1 017001F05                       lbsr    OUTCH
 00FFD2C4 039                             rts
 
                                      org             $FFD2CC
 00FFD2CC 012                             nop
 00FFD2CD 012                             nop
                              HEX2
 00FFD2CE 017001169                       lbsr    DispByteAsHex
 00FFD2D1 039                             rts
                              HEX4
 00FFD2D2 01700115C                       lbsr    DispWordAsHex
 00FFD2D5 039                             rts
 
                                      org             $FFD300
                              ClearScreenJmp
 00FFD300 016000F39                       lbra    ClearScreen
                                      org             $FFD308
                              HomeCursorJmp
 00FFD308 016000FA8                       lbra    HomeCursor
 
                                      org             $FFD400
 
                              ; Local RAM test routine
                              ; Checkerboard testing.
                              ; There is 70kB of local RAM
                              ; Does not use any RAM including no stack
 
                              ramtest:
 00FFD400 18E000000                       ldy             #0
 00FFD403 086001                          lda             #1
 00FFD405 0150B7FFFE60001                 sta             LEDS
 00FFD40A 0CCAAA555                       ldd             #$AAA555
                              ramtest1:
 00FFD40D 0EDA01                          std             ,y++
 00FFD40F 18C008000                       cmpy    #$8000
 00FFD412 025FF9                          blo             ramtest1
                                      ; now readback values and compare
 00FFD414 18E000000                       ldy             #0
                              ramtest3:
 00FFD417 0ECA01                          ldd             ,y++
 00FFD419 183AAA555                       cmpd    #$AAA555
 00FFD41C 02600E                          bne             ramerr
 00FFD41E 18C008000                       cmpy    #$8000
 00FFD421 025FF4                          blo             ramtest3
 00FFD423 086002                          lda             #2
 00FFD425 0150B7FFFE60001                 sta             LEDS
 00FFD42A 06EC04                          jmp             ,u
                              ramerr:
 00FFD42C 086080                          lda             #$80
 00FFD42E 0150B7FFFE60001                 sta             LEDS
 00FFD433 0150F6FFFFFFFE0                 ldb             COREID
 00FFD438 0C1020                          cmpb    #$20
 00FFD43A 027009                          beq             ramerr1
 00FFD43C 08EE00000                       ldx             #TEXTSCR
 00FFD43F 03A                             abx
 00FFD440 086046                          lda             #'F'
 00FFD442 0A7804                          sta             ,x
 00FFD444 013                             sync
                              ramerr1:
 00FFD445 06EC04                          jmp             ,u
 
 
                                      org             $FFE000
 00FFE000 FFF35C                          FDB Monitor
 00FFE002 FFE022                          FDB DumRts      ;       NEXTCMD
 00FFE004 FFF191                          FDB INCH
 00FFE006 FFF1AF                          FDB INCHE
 00FFE008 FFF1B3                          FDB INCHEK
 00FFE00A FFF1C9                          FDB OUTCH
 00FFE00C FFE41E                          FDB PDATA
 00FFE00E FFE411                          FDB PCRLF
 00FFE010 FFE40D                          FDB PSTRNG
 00FFE012 FFE022                          FDB DumRts                      ; LRA
 00FFE014 FFE022                          FDB DumRts
 00FFE016 FFE022                          FDB DumRts
 00FFE018 FFE022                          FDB DumRts
 00FFE01A FFE022                          FDB DumRts                      ; VINIZ
 00FFE01C FFE31C                          FDB DisplayChar ;       VOUTCH
 00FFE01E FFE022                          FDB DumRts                      ; ACINIZ
 00FFE020 FFE022                          FDB DumRts                      ; AOUTCH
 
                              DumRts:
 00FFE022 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
 
                              start:
 00FFE023 086FFF                          lda             #$FFF                   ; all cores can do this
 00FFE025 0150B7FFFE60003                 sta             VIA+VIA_DDRA
 00FFE02A 086055                          lda             #$55                    ; see if we can at least set LEDs
 00FFE02C 0150B7FFFE60001                 sta             LEDS
 00FFE031 086001                          lda             #1                              ; prime OS semaphore
 00FFE033 0B7EF1010                       sta             OSSEMA+$1000
 00FFE036 0B7EF1000                       sta             OUTSEMA+$1000
 00FFE039 0CEFFE03C                       ldu             #st6                    ; U = return address
                              ;       jmp             ramtest         ; JMP dont JSR
                              st6:
 00FFE03C 1CE006FFF                       lds             #$6FFF          ; boot up stack area
 00FFE03F 0150B6FFFFFFFE0                 lda             COREID
 00FFE044 081001                          cmpa    #FIRST_CORE
                              ;       beq             st8
                              ;       sync                                            ; halt cores other than 2
                              st8:
                              ;       bne             skip_init
                              ;       bsr             romToRam
                              ;       ldd             #st7 & $FFFF
                              ;       tfr             d,x
                              ;       jmp             ,x                              ; jump to the BIOS now in local RAM
                              st7:
 00FFE046 08D170                          bsr             Delay3s         ; give some time for devices to reset
 00FFE048 07F000810                       clr             BreakpointFlag
 00FFE04B 07F000811                       clr             NumSetBreakpoints
 00FFE04E 0860AA                          lda             #$AA
 00FFE050 0150B7FFFE60001                 sta             LEDS
 00FFE055 0150B6FFFFFFFE0                 lda             COREID
 00FFE05A 081020                          cmpa    #$20
 00FFE05C 027002                          beq             st11
 00FFE05E 086001                          lda             #FIRST_CORE
                              st11:
 00FFE060 0B7FFC010                       sta             IOFocusID       ; core #2 has focus
 00FFE063 0B7FFC013                       sta             RunningID
                                      ; Clear IO focus list
 00FFE066 08E000000                       ldx             #0
                              st9:
 00FFE069 06F80A000FFC000                 clr             IOFocusList,x
 00FFE06E 030001                          inx
 00FFE070 08C000010                       cmpx    #16
 00FFE073 025FF4                          blo             st9
 00FFE075 086018                          lda             #24
 00FFE077 0B7FFC001                       sta             IOFocusList+FIRST_CORE
 
 00FFE07A 0860CE                          lda             #$0CE
 00FFE07C 097113                          sta             ScreenColor
 00FFE07E 097112                          sta             CharColor
 00FFE080 08D1BA                          bsr             ClearScreen
 00FFE082 0CCFFE31C                       ldd             #DisplayChar
 00FFE085 0FD000800                       std             CharOutVec
 00FFE088 0CCFFEC73                       ldd             #SerialPeekCharDirect
 00FFE08B 0FD000804                       std             CharInVec
                              ;       swi
                              ;       fcb             MF_OSCALL
                              ;       fcb             24                                      ; request IO focus
 00FFE08E 0150F6FFFFFFFE0                 ldb             COREID
 00FFE093 0C1001                          cmpb    #FIRST_CORE
 00FFE095 027011                          beq             init
 00FFE097 0C1020                          cmpb    #$20                            ; CmodA709 core?
 00FFE099 027060                          beq             init2
 00FFE09B 020070                          bra             skip_init
 00FFE09D 0200B7                          bra             multi_sieve
                              st3:
 00FFE09F 0860FF                          lda             #$FF
 00FFE0A1 0150B7FFFE60001                 sta             LEDS
 00FFE0A6 020FF7                          bra             st3
 
                                      ; initialize interrupt controller
                                      ; first, zero out all the vectors
                              init:
 00FFE0A8 017000479                       lbsr    rtc_read        ; get clock values
 00FFE0AB 08E000127                       ldx             #kbdHeadRcv
 00FFE0AE 0C6020                          ldb             #32                             ; number of bytes to zero out
                              init1:
 00FFE0B0 06F800                          clr             ,x+
 00FFE0B2 05A                             decb
 00FFE0B3 026FFB                          bne             init1
 00FFE0B5 08E000080                       ldx             #128                    ; register to start at
                              st1:
 00FFE0B8 06F809E3F000                    clr             PIC,x                   ; cause code
 00FFE0BC 0A7809E3F001                    sta             PIC+1,x
 00FFE0C0 0E7809E3F002                    stb             PIC+2,x
 00FFE0C4 030004                          leax    4,x
 00FFE0C6 08C000100                       cmpx    #256                    ; max reg
 00FFE0C9 025FED                          blo             st1
 00FFE0CB 0860C1                          lda             #$C1                    ; make irq edge sensitive (bit 7), enable interupt (bit 6), irq (bit 0)
 00FFE0CD 0150B7FFFE3F0FD                 sta             PIC+$FD
 00FFE0D2 086041                          lda             #$41                    ; level sensitive, enabled, irq
 00FFE0D4 0150B7FFFE3F0D1                 sta             PIC+$D1         ; serial irq is #20
 00FFE0D9 086040                          lda             #COLS
 00FFE0DB 0150B7FFFE07F00                 sta             TEXTREG+TEXT_COLS
 00FFE0E0 086020                          lda             #ROWS
 00FFE0E2 0150B7FFFE07F01                 sta             TEXTREG+TEXT_ROWS
 00FFE0E7 08D153                          bsr             ClearScreen
 00FFE0E9 08D1C8                          bsr             HomeCursor
 00FFE0EB 08E000000                       ldx             #0
 00FFE0EE 0CC000000                       ldd             #0
 00FFE0F1 0170010DF                       lbsr    ShowSprites
 00FFE0F4 0170008C9                       lbsr    KeybdInit
 00FFE0F7 0DC124                          ldd             KeybdID
 00FFE0F9 08D336                          bsr             DispWordAsHex
                              init2:
 00FFE0FB 01700036A                       lbsr    TimerInit
 00FFE0FE 017000AEE                       lbsr    InitSerial
 00FFE101 08E000080                       ldx             #128
 00FFE104 086001                          lda             #1                      ; set irq(bit0), clear firq (bit1), disable int (bit 6), clear edge sense(bit 7)
 00FFE106 0C6001                          ldb             #FIRST_CORE                     ; serving core id
                              ;       lda             #4                              ; make the timer interrupt edge sensitive
                              ;       sta             PIC+4                   ; reg #4 is the edge sensitivity setting
                              ;       sta             PIC                             ; reg #0 is interrupt enable
 00FFE108 0C6001                          ldb             #1
 00FFE10A 0F7EF1000                       stb             OUTSEMA+SEMAABS ; set semaphore to 1 available slot
                              skip_init:
 00FFE10D 01C0EF                          andcc   #$EF                    ; unmask irq
 00FFE10F 086005                          lda             #5
 00FFE111 0150B7FFFE60001                 sta             LEDS
 00FFE116 0CCFFE11F                       ldd             #msgStartup
 00FFE119 08D2C2                          bsr             DisplayString
                              st10:
 00FFE11B 03F                             swi
 00FFE11C 000                             fcb             MF_Monitor
 00FFE11D 020FFC                          bra             st10
 
                              msgStartup
 00FFE11F 072066036038030039020           fcb             "rf6809 12-bit System Starting.",CR,LF,0
 00FFE126 03103202D062069074020
 00FFE12D 05307907307406506D020
 00FFE134 05307406107207406906E
 00FFE13B 06702E00D00A000
 
                              ;------------------------------------------------------------------------------
                              ; The checkpoint register must be cleared within 1 second or a NMI interrupt
                              ; will occur. checkpoint should be called with a JSR so that the global ROM
                              ; routine is called.
                              ;
                              ; Modifies:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              checkpoint:
 00FFE140 01507FFFFFFFFE1                 clr             $FFFFFFFE1      ; writing any value will do
 00FFE145 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Copy the system ROM to local RAM
                              ; Running the code from local RAM is probably an order of magnitude faster
                              ; then running from the global ROM. It also reduces the network traffic to
                              ; run from local RAM.
                              ;
                              ; Modifies:
                              ;               d,x,y
                              ;------------------------------------------------------------------------------
 
                              romToRam:
 00FFE146 08EFFC000                       ldx             #$FFC000
 00FFE149 18E00C000                       ldy             #$00C000
                              romToRam1:
 00FFE14C 0EC801                          ldd             ,x++
 00FFE14E 0EDA01                          std             ,y++
 00FFE150 08C000000                       cmpx    #0
 00FFE153 026FF7                          bne             romToRam1
 00FFE155 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Multi-core sieve program.
                              ;------------------------------------------------------------------------------
 
                              ; First fill screen chars with 'P' indicating prime positions
                              ; Each core is responsible for the Nth position where N is the
                              ; core number minus two.
                              ;
                              multi_sieve:
 00FFE156 086050                          lda             #'P'                                    ; indicate prime
 00FFE158 0150F6FFFFFFFE0                 ldb             COREID                          ; find out which core we are
 00FFE15D 0C0001                          subb    #FIRST_CORE
 00FFE15F 08E000000                       ldx             #0                                              ; start at first char of screen
 00FFE162 03A                             abx
                              multi_sieve3:
 00FFE163 0A7809E00000                    sta             TEXTSCR,x                       ; store 'P'
 00FFE167 030008                          leax    8,x                                             ; advance to next position
 00FFE169 08C000FFF                       cmpx    #4095
 00FFE16C 025FF5                          blo             multi_sieve3
 00FFE16E 0BDFFE140                       jsr             checkpoint
*** warning 1: Long branch within short branch range could be optimized
 00FFE171 0CB002                          addb    #2                                              ; start sieve at 2 (core id)
 00FFE173 08604E                          lda             #'N'                                    ; flag position value of 'N' for non-prime
                              multi_sieve2:
 00FFE175 08E000000                       ldx             #0
 00FFE178 03A                             abx                                                                     ; skip the first position - might be prime
                              multi_sieve1:
 00FFE179 03A                             abx                                                                     ; increment
 00FFE17A 0A7809E00000                    sta             TEXTSCR,x
 00FFE17E 08C000FFF                       cmpx    #4095
 00FFE181 025FF6                          blo             multi_sieve1
 00FFE183 0BDFFE140                       jsr             checkpoint
*** warning 1: Long branch within short branch range could be optimized
 00FFE186 0CB008                          addb    #8                                              ; number of cores working on it
 00FFE188 0C1FF0                          cmpb    #4080
 00FFE18A 025FE9                          blo             multi_sieve2
                              multi_sieve4:                                   ; hang machine
 00FFE18C 013                             sync
 00FFE18D 0160011CC                       lbra    Monitor
 
                              ;------------------------------------------------------------------------------
                              ; Single core sieve.
                              ;------------------------------------------------------------------------------
 
                              sieve:
 00FFE190 086050                          lda             #'P'                                    ; indicate prime
 00FFE192 08E000000                       ldx             #0                                              ; start at first char of screen
                              sieve3:
 00FFE195 0A7809E00000                    sta             TEXTSCR,x                       ; store 'P'
 00FFE199 030001                          inx                                                                     ; advance to next position
 00FFE19B 08C000FFF                       cmpx    #4095
 00FFE19E 025FF5                          blo             sieve3
 00FFE1A0 0C6002                          ldb             #2                                              ; start sieve at 2
 00FFE1A2 08604E                          lda             #'N'                                    ; flag position value of 'N' for non-prime
                              sieve2:
 00FFE1A4 08E000000                       ldx             #0
 00FFE1A7 03A                             abx                                                                     ; skip the first position - might be prime
                              sieve1:
 00FFE1A8 03A                             abx                                                                     ; increment
 00FFE1A9 0A7809E00000                    sta             TEXTSCR,x
 00FFE1AD 08C000FFF                       cmpx    #4095
 00FFE1B0 025FC7                          blo             multi_sieve1
 00FFE1B2 05C                             incb                                                            ; number of cores working on it
 00FFE1B3 0C1FF0                          cmpb    #4080
 00FFE1B5 025FED                          blo             sieve2
                              sieve4:                                                         ; hang machine
 00FFE1B7 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Three second delay for user convenience and to allow some devices time to
                              ; reset.
                              ;------------------------------------------------------------------------------
 
                              Delay3s:
 00FFE1B8 0CC895440                       ldd             #9000000
                              dly3s1:
 00FFE1BB 0C10FF                          cmpb    #$FF
 00FFE1BD 026000                          bne             dly3s2
                              dly3s2:
 00FFE1BF 0150B7FFFE60001                 sta             LEDS
 00FFE1C4 083000001                       subd    #1
 00FFE1C7 026FF2                          bne             dly3s1
 00FFE1C9 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              ShiftLeft5:
 00FFE1CA 058                             aslb
 00FFE1CB 049                             rola
 00FFE1CC 058                             aslb
 00FFE1CD 049                             rola
 00FFE1CE 058                             aslb
 00FFE1CF 049                             rola
 00FFE1D0 058                             aslb
 00FFE1D1 049                             rola
 00FFE1D2 058                             aslb
 00FFE1D3 049                             rola
 00FFE1D4 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Parameters:
                              ;               b = core id of core to copy
                              ;------------------------------------------------------------------------------
                              ;
                              CopyVirtualScreenToScreen:
 00FFE1D5 034076                          pshs    d,x,y,u
                                      ; Compute virtual screen location for core passed in accb.
 00FFE1D7 01F098                          tfr             b,a
 00FFE1D9 048                             asla
 00FFE1DA 048                             asla
 00FFE1DB 048                             asla
 00FFE1DC 048                             asla
 00FFE1DD 08AC00                          ora             #$C00
 00FFE1DF 05F                             clrb
 00FFE1E0 01F001                          tfr             d,x
 00FFE1E2 034006                          pshs    d
 00FFE1E4 18EE00000                       ldy             #TEXTSCR
 00FFE1E7 0CE000400                       ldu             #COLS*ROWS/2
                              cv2s1:
 00FFE1EA 0EC801                          ldd             ,x++
 00FFE1EC 0EDA01                          std             ,y++
 00FFE1EE 0335FF                          leau    -1,u
 00FFE1F0 283000000                       cmpu    #0
 00FFE1F3 026FF5                          bne             cv2s1
                                      ; reset the cursor position in the text controller
 00FFE1F5 035010                          puls    x
 00FFE1F7 0E6808110                       ldb             CursorRow,x
 00FFE1FA 086040                          lda             #COLS
 00FFE1FC 03D                             mul
 00FFE1FD 01F002                          tfr             d,y
 00FFE1FF 0E6808111                       ldb             CursorCol,x
 00FFE202 01F021                          tfr             y,x
 00FFE204 03A                             abx
 00FFE205 0150BFFFFE07F22                 stx             TEXTREG+TEXT_CURPOS
 00FFE20A 0350F6                          puls    d,x,y,u,pc
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              ;
                              CopyScreenToVirtualScreen:
 00FFE20C 034076                          pshs    d,x,y,u
 00FFE20E 08D08D                          bsr             GetScreenLocation
 00FFE210 01F002                          tfr             d,y
 00FFE212 08EE00000                       ldx             #TEXTSCR
 00FFE215 0CE000400                       ldu             #COLS*ROWS/2
                              cs2v1:
 00FFE218 0EC801                          ldd             ,x++
 00FFE21A 0EDA01                          std             ,y++
 00FFE21C 0335FF                          leau    -1,u
 00FFE21E 283000000                       cmpu    #0
 00FFE221 026FF5                          bne             cs2v1
 00FFE223 0350F6                          puls    d,x,y,u,pc
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
 00FFE225 054045058054053043052           fcb             "TEXTSCR "
 00FFE22C 020
 00FFE22D FFE237                          fcw             TextOpen
 00FFE22F FFE238                          fcw             TextClose
 00FFE231 FFE239                          fcw             TextRead
 00FFE233 FFE23A                          fcw             TextWrite
 00FFE235 FFE23B                          fcw             TextSeek
 
                              TextOpen:
 00FFE237 039                             rts
                              TextClose:
 00FFE238 039                             rts
                              TextRead:
 00FFE239 039                             rts
                              TextWrite:
 00FFE23A 039                             rts
                              TextSeek:
 00FFE23B 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Clear the screen and the screen color memory
                              ; We clear the screen to give a visual indication that the system
                              ; is working at all.
                              ;
                              ; Modifies:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              ClearScreen:
 00FFE23C 034076                          pshs    d,x,y,u
 00FFE23E 08E000800                       ldx             #COLS*ROWS
 00FFE241 01F013                          tfr             x,u
 00FFE243 08D058                          bsr             GetScreenLocation
 00FFE245 01F002                          tfr             d,y
 00FFE247 0C6020                          ldb             #' '                            ; space char
                              cs1:
 00FFE249 0E7A00                          stb             ,y+                                     ; set text to space
 00FFE24B 0301FF                          leax    -1,x                            ; decrement x
 00FFE24D 026FFA                          bne             cs1
 00FFE24F 0150F6FFFFFFFE0                 ldb             COREID                  ; update colors only if we have focus
 00FFE254 0F1FFC010                       cmpb    IOFocusID
 00FFE257 02000D                          bra             cs3
 00FFE259 18EE02000                       ldy             #TEXTSCR+$2000
                              ;       lda             CharColor
 00FFE25C 0860CE                          lda             #$0CE
 00FFE25E 01F031                          tfr             u,x                                     ; get back count
                              cs2:
 00FFE260 0A7A00                          sta             ,y+
 00FFE262 0301FF                          dex                                                             ; decrement x
 00FFE264 026FFA                          bne             cs2
                              cs3:
 00FFE266 0350F6                          puls    d,x,y,u,pc
 
                              ;------------------------------------------------------------------------------
                              ; Scroll text on the screen upwards
                              ;
                              ; Modifies:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              ScrollUp:
 00FFE268 034076                          pshs    d,x,y,u
 00FFE26A 18E0003FF                       ldy             #(COLS*ROWS-1)/2        ; y = num chars/2 to move
 00FFE26D 08D02E                          bsr             GetScreenLocation
 00FFE26F 01F001                          tfr             d,x
 00FFE271 01F003                          tfr             d,u
 00FFE273 030040                          leax    COLS,x          ; x = index to source row
                              scrup1:
 00FFE275 0EC801                          ldd             ,x++                    ; move 2 characters
 00FFE277 0EDC01                          std             ,u++
 00FFE279 0313FF                          dey
 00FFE27B 026FF8                          bne             scrup1
 00FFE27D 08601F                          lda             #ROWS-1
 00FFE27F 08D002                          bsr             BlankLine
 00FFE281 0350F6                          puls    d,x,y,u,pc
 
                              ;------------------------------------------------------------------------------
                              ; Blank out a line on the display
                              ;
                              ; Modifies:
                              ;               none
                              ; Parameters:
                              ;       acca = line number to blank
                              ;------------------------------------------------------------------------------
 
                              BlankLine:
 00FFE283 034016                          pshs    d,x
 00FFE285 034002                          pshs    a
 00FFE287 08D014                          bsr             GetScreenLocation
 00FFE289 01F001                          tfr             d,x
 00FFE28B 035002                          puls    a
 00FFE28D 0C6040                          ldb             #COLS   ; b = # chars to blank out from video controller
 00FFE28F 03D                             mul                                     ; d = screen index (row# * #cols)
 00FFE290 03080B                          leax    d,x
 00FFE292 086020                          lda             #' '
 00FFE294 0C6040                          ldb             #COLS   ; b = # chars to blank out from video controller
                              blnkln1:
 00FFE296 0A7800                          sta             ,x+
 00FFE298 05A                             decb
 00FFE299 026FFB                          bne             blnkln1
 00FFE29B 035096                          puls    d,x,pc
 
                              ;------------------------------------------------------------------------------
                              ; Get the location of the screen memory. The location
                              ; depends on whether or not the task has the output focus.
                              ;
                              ; Modifies:
                              ;               d
                              ; Retuns:
                              ;               d = screen location
                              ;------------------------------------------------------------------------------
 
                              GetScreenLocation:
 00FFE29D 0150B6FFFFFFFE0                 lda             COREID                  ; which core are we?
 00FFE2A2 0B1FFC010                       cmpa    IOFocusID               ; do we have the IO focus
 00FFE2A5 026008                          bne             gsl1                            ; no, go pick virtual screen address
 00FFE2A7 081020                          cmpa    #$20                            ; CmodA709?
 00FFE2A9 027004                          beq             gsl1
 00FFE2AB 0CCE00000                       ldd             #TEXTSCR                ; yes, we update the real screen
 00FFE2AE 039                             rts
                              gsl1:
 00FFE2AF 0CC007800                       ldd             #$7800
 00FFE2B2 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; HomeCursor
                              ; Set the cursor location to the top left of the screen.
                              ;
                              ; Modifies:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              HomeCursor:
 00FFE2B3 034016                          pshs    d,x
 00FFE2B5 00F110                          clr             CursorRow
 00FFE2B7 00F111                          clr             CursorCol
 00FFE2B9 0150F6FFFFFFFE0                 ldb             COREID
 00FFE2BE 0F1FFC010                       cmpb    IOFocusID
 00FFE2C1 02600A                          bne             hc1
 00FFE2C3 0C1020                          cmpb    #$20
 00FFE2C5 027006                          beq             hc1
 00FFE2C7 04F                             clra
 00FFE2C8 0150B7FFFE07F22                 sta             TEXTREG+TEXT_CURPOS
                              hc1:
 00FFE2CD 035096                          puls    d,x,pc
 
                              ;------------------------------------------------------------------------------
                              ; Update the cursor position in the text controller based on the
                              ;  CursorRow,CursorCol.
                              ;
                              ; Modifies:
                              ;               none
                              ;------------------------------------------------------------------------------
                              ;
                              UpdateCursorPos:
 00FFE2CF 034016                          pshs    d,x
 00FFE2D1 0150F6FFFFFFFE0                 ldb             COREID                          ; update cursor position in text controller
 00FFE2D6 0F1FFC010                       cmpb    IOFocusID                       ; only for the task with the output focus
 00FFE2D9 026018                          bne             ucp1
 00FFE2DB 0C1020                          cmpb    #$20                                    ; and not for CmodA709
 00FFE2DD 027014                          beq             ucp1                                    
 00FFE2DF 096110                          lda             CursorRow
 00FFE2E1 08403F                          anda    #$3F                                    ; limit of 63 rows
 00FFE2E3 0150F6FFFE07F00                 ldb             TEXTREG+TEXT_COLS
 00FFE2E8 03D                             mul
 00FFE2E9 01F001                          tfr             d,x
 00FFE2EB 0D6111                          ldb             CursorCol
 00FFE2ED 03A                             abx
 00FFE2EE 0150BFFFFE07F22                 stx             TEXTREG+TEXT_CURPOS
                              ucp1:
 00FFE2F3 035096                          puls    d,x,pc
 
                              ;------------------------------------------------------------------------------
                              ; Calculate screen memory location from CursorRow,CursorCol.
                              ; Also refreshes the cursor location.
                              ;
                              ; Modifies:
                              ;               d
                              ; Returns:
                              ;       d = screen location
                              ;------------------------------------------------------------------------------
                              ;
                              CalcScreenLoc:
 00FFE2F5 034010                          pshs    x
 00FFE2F7 096110                          lda             CursorRow
 00FFE2F9 0C6040                          ldb             #COLS
 00FFE2FB 03D                             mul
 00FFE2FC 01F001                          tfr             d,x
 00FFE2FE 0D6111                          ldb             CursorCol
 00FFE300 03A                             abx
 00FFE301 0150F6FFFFFFFE0                 ldb             COREID                          ; update cursor position in text controller
 00FFE306 0F1FFC010                       cmpb    IOFocusID                       ; only for the task with the output focus
 00FFE309 026009                          bne             csl1                                    
 00FFE30B 0C1020                          cmpb    #$20
 00FFE30D 027005                          beq             csl1
 00FFE30F 0150BFFFFE07F22                 stx             TEXTREG+TEXT_CURPOS
                              csl1:
 00FFE314 08DF87                          bsr             GetScreenLocation
 00FFE316 03080B                          leax    d,x
 00FFE318 01F010                          tfr             x,d
 00FFE31A 035090                          puls    x,pc
 
                              ;------------------------------------------------------------------------------
                              ; Display a character on the screen.
                              ; If the task doesn't have the I/O focus then the character is written to
                              ; the virtual screen.
                              ;
                              ; Modifies:
                              ;               none
                              ; Parameters:
                              ;       accb = char to display
                              ;------------------------------------------------------------------------------
                              ;
                              DisplayChar:
 00FFE31C 01700097B                       lbsr    SerialPutChar
                              ScreenDisplayChar:
 00FFE31F 034016                          pshs    d,x
 00FFE321 0C100D                          cmpb    #CR                                     ; carriage return ?
 00FFE323 026007                          bne             dccr
 00FFE325 00F111                          clr             CursorCol               ; just set cursor column to zero on a CR
 00FFE327 08DFA6                          bsr             UpdateCursorPos
                              dcx14:
 00FFE329 01600008C                       lbra            dcx4
                              dccr:
 00FFE32C 0C1091                          cmpb    #$91                            ; cursor right ?
 00FFE32E 02600D                          bne             dcx6
 00FFE330 096111                          lda             CursorCol
 00FFE332 081040                          cmpa    #COLS
 00FFE334 024003                          bhs             dcx7
 00FFE336 04C                             inca
 00FFE337 097111                          sta             CursorCol
                              dcx7:
 00FFE339 08DF94                          bsr             UpdateCursorPos
 00FFE33B 035096                          puls    d,x,pc
                              dcx6:
 00FFE33D 0C1090                          cmpb    #$90                            ; cursor up ?
 00FFE33F 026009                          bne             dcx8            
 00FFE341 096110                          lda             CursorRow
 00FFE343 027FF4                          beq             dcx7
 00FFE345 04A                             deca
 00FFE346 097110                          sta             CursorRow
 00FFE348 020FEF                          bra             dcx7
                              dcx8:
 00FFE34A 0C1093                          cmpb    #$93                            ; cursor left ?
 00FFE34C 026009                          bne             dcx9
 00FFE34E 096111                          lda             CursorCol
 00FFE350 027FE7                          beq             dcx7
 00FFE352 04A                             deca
 00FFE353 097111                          sta             CursorCol
 00FFE355 020FE2                          bra             dcx7
                              dcx9:
 00FFE357 0C1092                          cmpb    #$92                            ; cursor down ?
 00FFE359 02600B                          bne             dcx10
 00FFE35B 096110                          lda             CursorRow
 00FFE35D 081020                          cmpa    #ROWS
 00FFE35F 027FD8                          beq             dcx7
 00FFE361 04C                             inca
 00FFE362 097110                          sta             CursorRow
 00FFE364 020FD3                          bra             dcx7
                              dcx10:
 00FFE366 0C1094                          cmpb    #$94                            ; cursor home ?
 00FFE368 02600C                          bne             dcx11
 00FFE36A 096111                          lda             CursorCol
 00FFE36C 027004                          beq             dcx12
 00FFE36E 00F111                          clr             CursorCol
 00FFE370 020FC7                          bra             dcx7
                              dcx12:
 00FFE372 00F110                          clr             CursorRow
 00FFE374 020FC3                          bra             dcx7
                              dcx11:
 00FFE376 0C1099                          cmpb    #$99                            ; delete ?
 00FFE378 026008                          bne             dcx13
 00FFE37A 08DF79                          bsr             CalcScreenLoc
 00FFE37C 01F001                          tfr             d,x
 00FFE37E 096111                          lda             CursorCol               ; acc = cursor column
 00FFE380 020011                          bra             dcx5
                              dcx13
 00FFE382 0C1008                          cmpb    #CTRLH                  ; backspace ?
 00FFE384 02601E                          bne             dcx3
 00FFE386 096111                          lda             CursorCol
 00FFE388 02702E                          beq             dcx4
 00FFE38A 04A                             deca
 00FFE38B 097111                          sta             CursorCol
 00FFE38D 08DF66                          bsr             CalcScreenLoc
 00FFE38F 01F001                          tfr             d,x
 00FFE391 096111                          lda             CursorCol
                              dcx5:
 00FFE393 0E6001                          ldb             1,x
 00FFE395 0E7801                          stb             ,x++
 00FFE397 04C                             inca
 00FFE398 081040                          cmpa    #COLS
 00FFE39A 025FF7                          blo             dcx5
 00FFE39C 0C6020                          ldb             #' '
 00FFE39E 0301FF                          dex
 00FFE3A0 0E7804                          stb             ,x
 00FFE3A2 020014                          bra             dcx4
                              dcx3:
 00FFE3A4 0C100A                          cmpb    #LF                             ; linefeed ?
 00FFE3A6 02700E                          beq             dclf
 00FFE3A8 034004                          pshs    b
 00FFE3AA 08DF49                          bsr     CalcScreenLoc
 00FFE3AC 01F001                          tfr             d,x
 00FFE3AE 035004                          puls    b
 00FFE3B0 0E7804                          stb             ,x
                                      ; ToDo character color
                              ;       lda             CharColor
                              ;       sta             $2000,x
 00FFE3B2 08D006                          bsr             IncCursorPos
 00FFE3B4 020002                          bra             dcx4
                              dclf:
 00FFE3B6 08D011                          bsr             IncCursorRow
                              dcx4:
 00FFE3B8 035096                          puls    d,x,pc
 
                              ;------------------------------------------------------------------------------
                              ; Increment the cursor position, scroll the screen if needed.
                              ;
                              ; Modifies:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              IncCursorPos:
 00FFE3BA 034016                          pshs    d,x
 00FFE3BC 096111                          lda             CursorCol
 00FFE3BE 04C                             inca
 00FFE3BF 097111                          sta             CursorCol
 00FFE3C1 081040                          cmpa    #COLS
 00FFE3C3 025014                          blo             icc1
 00FFE3C5 00F111                          clr             CursorCol               ; column = 0
 00FFE3C7 020002                          bra             icr1
                              IncCursorRow:
 00FFE3C9 034016                          pshs    d,x
                              icr1:
 00FFE3CB 096110                          lda             CursorRow
 00FFE3CD 04C                             inca
 00FFE3CE 097110                          sta             CursorRow
 00FFE3D0 081020                          cmpa    #ROWS
 00FFE3D2 025005                          blo             icc1
 00FFE3D4 04A                             deca                                                    ; backup the cursor row, we are scrolling up
 00FFE3D5 097110                          sta             CursorRow
 00FFE3D7 08DE8F                          bsr             ScrollUp
                              icc1:
 00FFE3D9 08DEF4                          bsr             UpdateCursorPos
                              icc2:
 00FFE3DB 035096                          puls    d,x,pc  
 
                              ;------------------------------------------------------------------------------
                              ; Display a string on the screen.
                              ;
                              ; Modifies:
                              ;               none
                              ; Parameters:
                              ;               d = pointer to string
                              ;------------------------------------------------------------------------------
                              ;
                              DisplayString:
 00FFE3DD 034016                          pshs    d,x
 00FFE3DF 01F001                          tfr             d,x
 00FFE3E1 0150B6FFFFFFFE0                 lda             COREID
 00FFE3E6 081020                          cmpa    #$20
 00FFE3E8 027005                          beq             dspj1B
                              dspj2:                                          ; lock semaphore for access
 00FFE3EA 0B6EF0001                       lda             OUTSEMA+1
 00FFE3ED 027FFB                          beq             dspj2
                              dspj1B:
 00FFE3EF 0E6800                          ldb             ,x+                             ; move string char into acc
 00FFE3F1 027005                          beq             dsretB          ; is it end of string ?
 00FFE3F3 017000DD3                       lbsr    OUTCH                   ; display character
 00FFE3F6 020FF7                          bra             dspj1B
                              dsretB:
 00FFE3F8 07FEF0001                       clr             OUTSEMA+1       ; unlock semaphore
 00FFE3FB 035096                          puls    d,x,pc
 
                              DisplayStringCRLF:
 00FFE3FD 034006                          pshs    d
 00FFE3FF 08DFDC                          bsr             DisplayString
 00FFE401 0C600D                          ldb             #CR
 00FFE403 017000DC3                       lbsr    OUTCH
 00FFE406 0C600A                          ldb             #LF
 00FFE408 017000DBE                       lbsr    OUTCH
 00FFE40B 035086                          puls    d,pc
                                      
                              ;
                              ; PRINT CR, LF, STRING
                              ;
                              PSTRNG
 00FFE40D 08D002                          BSR             PCRLF
 00FFE40F 02000D                          BRA             PDATA
                              PCRLF
 00FFE411 034010                          PSHS    X
 00FFE413 08EFFE425                       LDX             #CRLFST
 00FFE416 08D006                          BSR             PDATA
 00FFE418 035010                          PULS    X
 00FFE41A 039                             RTS
 
                              PRINT
 00FFE41B 0BDFFF1C9                       JSR             OUTCH
                              PDATA
 00FFE41E 0E6800                          LDB             ,X+
 00FFE420 0C1004                          CMPB    #$04
 00FFE422 026FF7                          BNE             PRINT
 00FFE424 039                             RTS
 
                              CRLFST
 00FFE425 00D00A004                       fcb     CR,LF,4
 
                              DispDWordAsHex:
 00FFE428 08D007                          bsr             DispWordAsHex
 00FFE42A 01E001                          exg             d,x
 00FFE42C 08D003                          bsr             DispWordAsHex
 00FFE42E 01E001                          exg             d,x
 00FFE430 039                             rts
 
                              DispWordAsHex:
 00FFE431 01E089                          exg             a,b
 00FFE433 08D005                          bsr             DispByteAsHex
 00FFE435 01E089                          exg             a,b
 00FFE437 08D001                          bsr             DispByteAsHex
 00FFE439 039                             rts
 
                              DispByteAsHex:
 00FFE43A 034004                    pshs  b
 00FFE43C 054                             lsrb
 00FFE43D 054                             lsrb
 00FFE43E 054                             lsrb
 00FFE43F 054                             lsrb
 00FFE440 054                             lsrb
 00FFE441 054                             lsrb
 00FFE442 054                             lsrb
 00FFE443 054                             lsrb
 00FFE444 08D00C                          bsr             DispNyb
 00FFE446 035004                          puls    b
 00FFE448 034004                          pshs    b
 00FFE44A 054                             lsrb
 00FFE44B 054                             lsrb
 00FFE44C 054                             lsrb
 00FFE44D 054                             lsrb
 00FFE44E 08D002                          bsr             DispNyb
 00FFE450 035004                          puls    b
 
                              DispNyb
 00FFE452 034004                          pshs    b
 00FFE454 0C400F                          andb    #$0F
 00FFE456 0C100A                          cmpb    #10
 00FFE458 025007                          blo             DispNyb1
 00FFE45A 0CB037                          addb    #'A'-10
 00FFE45C 017000D6A                       lbsr    OUTCH
 00FFE45F 035084                          puls    b,pc
                              DispNyb1
 00FFE461 0CB030                          addb    #'0'
 00FFE463 017000D63                       lbsr    OUTCH
 00FFE466 035084                          puls    b,pc
 
                              ;==============================================================================
                              ; Timer
                              ;==============================================================================
 
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; Timer routines for a WDC6522 compatible circuit.
                              ;
                              ; This source file is free software: you can redistribute it and/or modify 
                              ; it under the terms of the GNU Lesser General Public License as published 
                              ; by the Free Software Foundation, either version 3 of the License, or     
                              ; (at your option) any later version.                                      
                              ;                                                                          
                              ; This source file is distributed in the hope that it will be useful,      
                              ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                              ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                              ; GNU General Public License for more details.                             
                              ;                                                                          
                              ; You should have received a copy of the GNU General Public License        
                              ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                              ;                                                                          
                              ; ============================================================================
                              ;
                              TimerInit:
 00FFE468 0CC061A80                       ldd             #$61A80                                 ; compare to 400000 (100 Hz assuming 40MHz clock)
 00FFE46B 0150F7FFFE60014                 stb             VIA+VIA_T3CMPL
 00FFE470 0150B7FFFE60015                 sta             VIA+VIA_T3CMPH
 00FFE475 01507FFFFE60012                 clr             VIA+VIA_T3LL
 00FFE47A 01507FFFFE60013                 clr             VIA+VIA_T3LH
 00FFE47F 0150B6FFFE6000B                 lda             VIA+VIA_ACR                     ; set continuous mode for timer
 00FFE484 08A100                          ora             #$100
 00FFE486 0150B7FFFE6000B                 sta             VIA+VIA_ACR                     
 00FFE48B 086880                          lda             #$880                                           ; enable timer #3 interrupts
 00FFE48D 0150B7FFFE6000E                 sta             VIA+VIA_IER
 00FFE492 039                             rts
 
                              TimerIRQ:
                                      ; Reset the edge sense circuit in the PIC
 00FFE493 08601F                          lda             #31                                                     ; Timer is IRQ #31
 00FFE495 0150B7FFFE3F010                 sta             PIC+16                                  ; register 16 is edge sense reset reg   
 00FFE49A 0150B6FFFE3F0FF                 lda             PIC+$FF                                 ; Timer active interrupt flag
 00FFE49F 027041                          beq             notTimerIRQ
 00FFE4A1 01507FFFFE3F0FF                 clr             PIC+$FF                                 ; clear the flag
 00FFE4A6 08601F                          lda             #31                                                     ; Timer is IRQ #31
 00FFE4A8 0B7FFC011                       sta             IrqSource               ; stuff a byte indicating the IRQ source for PEEK()
 00FFE4AB 01507FFFFE60012                 clr             VIA+VIA_T3LL            ; should clear the interrupt
 00FFE4B0 01507FFFFE60013                 clr             VIA+VIA_T3LH
 00FFE4B5 08601F                          lda             #31                                                     ; Timer is IRQ #31
 00FFE4B7 0150B7FFFE3F010                 sta             PIC+16                                  ; register 16 is edge sense reset reg   
 00FFE4BC 01507FFFFE3F0FF                 clr             PIC+$FF                                 ; clear the flag
 00FFE4C1 07CE0003F                       inc             $E0003F                                 ; update timer IRQ screen flag
 00FFE4C4 0FCFFC016                       ldd             milliseconds+2
 00FFE4C7 0C300000A                       addd    #10
 00FFE4CA 0FDFFC016                       std             milliseconds+2
 00FFE4CD 0FCFFC014                       ldd             milliseconds
 00FFE4D0 0C9000                          adcb    #0
 00FFE4D2 0F7FFC015                       stb             milliseconds+1
 00FFE4D5 089000                          adca    #0
 00FFE4D7 0B7FFC014                       sta             milliseconds
 
                                      ; Update XModem timer, we just always do it rather than testing if XModem
                                      ; is active. The increment is set to give approximately 3s before the MSB
                                      ; gets set.
 00FFE4DA 0F6FFC020                       ldb             xm_timer
 00FFE4DD 0CB004                          addb    #4
 00FFE4DF 0F7FFC020                       stb             xm_timer
                              notTimerIRQ:
 00FFE4E2 039                             rts
                                      
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2013-2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; BSD 3-Clause License
                              ; Redistribution and use in source and binary forms, with or without
                              ; modification, are permitted provided that the following conditions are met:
                              ;
                              ; 1. Redistributions of source code must retain the above copyright notice, this
                              ;    list of conditions and the following disclaimer.
                              ;
                              ; 2. Redistributions in binary form must reproduce the above copyright notice,
                              ;    this list of conditions and the following disclaimer in the documentation
                              ;    and/or other materials provided with the distribution.
                              ;
                              ; 3. Neither the name of the copyright holder nor the names of its
                              ;    contributors may be used to endorse or promote products derived from
                              ;    this software without specific prior written permission.
                              ;
                              ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                              ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                              ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                              ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                              ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                              ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                              ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                              ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                              ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                              ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                              ;                                                                          
                              ; ============================================================================
                              ;
                              ;===============================================================================
                              ; Generic I2C routines
                              ;
                              ; It is assumed there may be more than one I2C controller in the system, so
                              ; the address of the controller is passed in the X register.
                              ;===============================================================================
 
                              I2C_PREL        EQU             $0
                              I2C_PREH        EQU             $1
                              I2C_CTRL        EQU             $2
                              I2C_RXR         EQU             $3
                              I2C_TXR         EQU             $3
                              I2C_CMD         EQU             $4
                              I2C_STAT        EQU             $4
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; i2c initialization, sets the clock prescaler
                              ;
                              ; Parameters:
                              ;               x = I2C controller address
                              ; Returns: none
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              i2c_init:
 00FFE4E3 034004                          pshs    b
 00FFE4E5 0C6004                          ldb             #4                                                                      ; setup prescale for 400kHz clock
 00FFE4E7 0E7804                          stb             I2C_PREL,x
 00FFE4E9 06F001                          clr             I2C_PREH,x
 00FFE4EB 035084                          puls    b,pc
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Wait for I2C transfer to complete
                              ;
                              ; Parameters
                              ;       x - I2C controller base address
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              i2c_wait_tip:
 00FFE4ED 034004                          pshs            b
                              i2cw1:
 00FFE4EF 0E6004                          ldb                     I2C_STAT,x              ; would use lvb, but lb is okay since its the I/O area
 00FFE4F1 0C5001                          bitb            #1                                              ; wait for tip to clear
 00FFE4F3 026FFA                          bne                     i2cw1
 00FFE4F5 035084                          puls            b,pc
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Write command to i2c
                              ;
                              ; Parameters
                              ;               accb - data to transmit
                              ;               acca - command value
                              ;               x       - I2C controller base address
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              i2c_wr_cmd:
 00FFE4F7 0E7003                          stb             I2C_TXR,x
 00FFE4F9 0A7004                          sta             I2C_CMD,x
 00FFE4FB 08DFF0                          bsr             i2c_wait_tip
 00FFE4FD 0E6004                          ldb             I2C_STAT,x
 00FFE4FF 039                             rts
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Parameters
                              ;               x - I2C controller base address
                              ;               accb - data to send
                              ; Returns: none
                              ; Stack space: 2 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              i2c_xmit1:
 00FFE500 034006                          pshs    d                                                               ; save data value
 00FFE502 034006                          pshs    d                                                               ; and save it again
 00FFE504 0C6001                          ldb             #1
 00FFE506 0E7002                          stb             I2C_CTRL,x                      ; enable the core
 00FFE508 0C6076                          ldb             #$76                                            ; set slave address = %0111011
 00FFE50A 086090                          lda             #$90                                            ; set STA, WR
 00FFE50C 08DFE9                          bsr             i2c_wr_cmd
 00FFE50E 08D00A                          bsr             i2c_wait_rx_nack
 00FFE510 035006                          puls    d                                                               ; get back data value
 00FFE512 086050                          lda             #$50                                            ; set STO, WR
 00FFE514 08DFE1                          bsr             i2c_wr_cmd
 00FFE516 08D002                          bsr             i2c_wait_rx_nack
 00FFE518 035086                          puls    d,pc
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              i2c_wait_rx_nack:
 00FFE51A 034004                          pshs    b                                                               ; save off accb
                              i2cwr1:
 00FFE51C 0E6004                          ldb             I2C_STAT,x                      ; wait for RXack = 0
 00FFE51E 0C5080                          bitb    #$80                                            ; test for nack
 00FFE520 026FFA                          bne             i2cwr1
 00FFE522 035084                          puls    b,pc
 
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; BSD 3-Clause License
                              ; Redistribution and use in source and binary forms, with or without
                              ; modification, are permitted provided that the following conditions are met:
                              ;
                              ; 1. Redistributions of source code must retain the above copyright notice, this
                              ;    list of conditions and the following disclaimer.
                              ;
                              ; 2. Redistributions in binary form must reproduce the above copyright notice,
                              ;    this list of conditions and the following disclaimer in the documentation
                              ;    and/or other materials provided with the distribution.
                              ;
                              ; 3. Neither the name of the copyright holder nor the names of its
                              ;    contributors may be used to endorse or promote products derived from
                              ;    this software without specific prior written permission.
                              ;
                              ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                              ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                              ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                              ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                              ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                              ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                              ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                              ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                              ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                              ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                              ;
                              ; ============================================================================
 
                              ;===============================================================================
                              ; Realtime clock routines
                              ;===============================================================================
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Read the real-time-clock chip.
                              ;
                              ; The entire contents of the clock registers and sram are read into a buffer
                              ; in one-shot rather than reading the registers individually.
                              ;
                              ; Parameters: none
                              ; Returns: d = 0 on success, otherwise non-zero
                              ; Modifies: d and RTCBuf
                              ; Stack space: 6 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              rtc_read:
 00FFE524 08EE30500                       ldx                     #RTC
 00FFE527 18E007FC0                       ldy                     #RTCBuf
 00FFE52A 0C6080                          ldb                     #$80
 00FFE52C 0E7002                          stb                     I2C_CTRL,x              ; enable I2C
 00FFE52E 0CC0900DE                       ldd                     #$900DE                         ; read address, write op, STA + wr bit
 00FFE531 08DFC4                          bsr                     i2c_wr_cmd
 00FFE533 0C5080                          bitb            #$80
 00FFE535 02603C                          bne                     rtc_rxerr
 00FFE537 0CC010000                       ldd                     #$10000                         ; address zero, wr bit
 00FFE53A 08DFBB                          bsr                     i2c_wr_cmd
 00FFE53C 0C5080                          bitb            #$80
 00FFE53E 026033                          bne                     rtc_rxerr
 00FFE540 0CC0900DF                       ldd                     #$900DF                         ; read address, read op, STA + wr bit
 00FFE543 08DFB2                          bsr                     i2c_wr_cmd
 00FFE545 0C5080                          bitb            #$80
 00FFE547 02602A                          bne                     rtc_rxerr
                                      
 00FFE549 05F                             clrb
                              rtcr0001:
 00FFE54A 086020                          lda                     #$20
 00FFE54C 0A7004                          sta                     I2C_CMD,x                       ; rd bit
 00FFE54E 08DF9D                          bsr                     i2c_wait_tip
 00FFE550 08DFC8                          bsr                     i2c_wait_rx_nack
 00FFE552 0A6004                          lda                     I2C_STAT,x
 00FFE554 085080                          bita            #$80
 00FFE556 02601B                          bne                     rtc_rxerr
 00FFE558 0A6003                          lda                     I2C_RXR,x
 00FFE55A 0A7A07                          sta                     b,y
 00FFE55C 05C                             incb
 00FFE55D 0C105F                          cmpb            #$5F
 00FFE55F 025FE9                          blo                     rtcr0001
 00FFE561 086068                          lda                     #$68
 00FFE563 0A7004                          sta                     I2C_CMD,x                       ; STO, rd bit + nack
 00FFE565 08DF86                          bsr                     i2c_wait_tip
 00FFE567 0A6004                          lda                     I2C_STAT,x
 00FFE569 085080                          bita            #$80
 00FFE56B 026006                          bne                     rtc_rxerr
 00FFE56D 0A6003                          lda                     I2C_RXR,x
 00FFE56F 0A7A07                          sta                     b,y
 00FFE571 04F05F                          clrd                                                                    ; return 0
                              rtc_rxerr:
 00FFE573 06F002                          clr                     I2C_CTRL,x      ; disable I2C and return status
 00FFE575 04F                             clra
 00FFE576 039                             rts
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Write the real-time-clock chip.
                              ;
                              ; The entire contents of the clock registers and sram are written from a 
                              ; buffer (RTCBuf) in one-shot rather than writing the registers individually.
                              ;
                              ; Parameters: none
                              ; Returns: r1 = 0 on success, otherwise non-zero
                              ; Modifies: r1 and RTCBuf
                              ; Stack space: 6 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              rtc_write:
 00FFE577 08EE30500                       ldx             #RTC
 00FFE57A 18E007FC0                       ldy             #RTCBuf
                                      
 00FFE57D 0C6080                          ldb             #$80
 00FFE57F 0E7002                          stb             I2C_CTRL,x              ; enable I2C
 00FFE581 0CC0900DE                       ldd             #$900DE                         ; read address, write op, STA + wr bit
 00FFE584 08DF71                          bsr             i2c_wr_cmd
 00FFE586 0C5080                          bitb    #$80
 00FFE588 026FE9                          bne             rtc_rxerr
 00FFE58A 0CC010000                       ldd             #$10000                         ; address zero, wr bit
 00FFE58D 08DF68                          bsr             i2c_wr_cmd
 00FFE58F 0C5080                          bitb    #$80
 00FFE591 026FE0                          bne             rtc_rxerr
 
 00FFE593 0C6000                          ldb             #0
                              rtcw0001:
 00FFE595 034004                          pshs    b
 00FFE597 0E6A05                          ldb             b,y
 00FFE599 086010                          lda             #$10
 00FFE59B 08DF5A                          bsr             i2c_wr_cmd
 00FFE59D 0C5080                          bitb    #$80
 00FFE59F 035004                          puls    b
 00FFE5A1 026FD0                          bne             rtc_rxerr
 00FFE5A3 05C                             incb
 00FFE5A4 0C105F                          cmpb    #$5F
 00FFE5A6 025FED                          blo             rtcw0001
 00FFE5A8 0E6A05                          ldb             b,y
 00FFE5AA 086050                          lda             #$50                                    ; STO, wr bit
 00FFE5AC 08DF49                          bsr             i2c_wr_cmd
 00FFE5AE 0C5080                          bitb    #$80
 00FFE5B0 026FC1                          bne             rtc_rxerr
 00FFE5B2 04F05F                          clrd                                                            ; return 0
 00FFE5B4 06F002                          clr             I2C_CTRL,x              ; disable I2C and return status
 00FFE5B6 039                             rts
 
                              ;==============================================================================
                              ; Keyboard I/O
                              ;==============================================================================
 
                                      ;--------------------------------------------------------------------------
                                      ; PS2 scan codes to ascii conversion tables.
                                      ;--------------------------------------------------------------------------
                                      ;
                                      org     (* + 127) & $FFFFFF80
 
                              unshiftedScanCodes:
 00FFE600 02E0A902E0A50A30A10A2           fcb     $2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
 00FFE607 0AC
 00FFE608 02E0AA0A80A60A4009060           fcb     $2e,$aa,$a8,$a6,$a4,$09,$60,$2e
 00FFE60F 02E
 00FFE610 02E02E02E02E02E071031           fcb     $2e,$2e,$2e,$2e,$2e,$71,$31,$2e
 00FFE617 02E
 00FFE618 02E02E07A073061077032           fcb     $2e,$2e,$7a,$73,$61,$77,$32,$2e
 00FFE61F 02E
 00FFE620 02E063078064065034033           fcb     $2e,$63,$78,$64,$65,$34,$33,$2e
 00FFE627 02E
 00FFE628 02E020076066074072035           fcb     $2e,$20,$76,$66,$74,$72,$35,$2e
 00FFE62F 02E
 00FFE630 02E06E062068067079036           fcb     $2e,$6e,$62,$68,$67,$79,$36,$2e
 00FFE637 02E
 00FFE638 02E02E06D06A075037038           fcb     $2e,$2e,$6d,$6a,$75,$37,$38,$2e
 00FFE63F 02E
 00FFE640 02E02C06B06906F030039           fcb     $2e,$2c,$6b,$69,$6f,$30,$39,$2e
 00FFE647 02E
 00FFE648 02E02E02F06C03B07002D           fcb     $2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
 00FFE64F 02E
 00FFE650 02E02E02702E05B03D02E           fcb     $2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
 00FFE657 02E
 00FFE658 0AD02E00D05D02E05C02E           fcb     $ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
 00FFE65F 02E
 00FFE660 02E02E02E02E02E02E008           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
 00FFE667 02E
 00FFE668 02E09502E09309402E02E           fcb     $2e,$95,$2e,$93,$94,$2e,$2e,$2e
 00FFE66F 02E
 00FFE670 09807F09202E09109001B           fcb     $98,$7f,$92,$2e,$91,$90,$1b,$af
 00FFE677 0AF
 00FFE678 0AB02E09702E02E0960AE           fcb     $ab,$2e,$97,$2e,$2e,$96,$ae,$2e
 00FFE67F 02E
 
 00FFE680 02E02E02E0A702E02E02E           fcb     $2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
 00FFE687 02E
 00FFE688 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE68F 02E
 00FFE690 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE697 02E
 00FFE698 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE69F 02E
 00FFE6A0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE6A7 02E
 00FFE6A8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE6AF 02E
 00FFE6B0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE6B7 02E
 00FFE6B8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE6BF 02E
 00FFE6C0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE6C7 02E
 00FFE6C8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE6CF 02E
 00FFE6D0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE6D7 02E
 00FFE6D8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE6DF 02E
 00FFE6E0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE6E7 02E
 00FFE6E8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE6EF 02E
 00FFE6F0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE6F7 02E
 00FFE6F8 02E02E0FA02E02E02E02E           fcb     $2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
 00FFE6FF 02E
 
                              shiftedScanCodes:
 00FFE700 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE707 02E
 00FFE708 02E02E02E02E02E00907E           fcb     $2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
 00FFE70F 02E
 00FFE710 02E02E02E02E02E051021           fcb     $2e,$2e,$2e,$2e,$2e,$51,$21,$2e
 00FFE717 02E
 00FFE718 02E02E05A053041057040           fcb     $2e,$2e,$5a,$53,$41,$57,$40,$2e
 00FFE71F 02E
 00FFE720 02E043058044045024023           fcb     $2e,$43,$58,$44,$45,$24,$23,$2e
 00FFE727 02E
 00FFE728 02E020056046054052025           fcb     $2e,$20,$56,$46,$54,$52,$25,$2e
 00FFE72F 02E
 00FFE730 02E04E04204804705905E           fcb     $2e,$4e,$42,$48,$47,$59,$5e,$2e
 00FFE737 02E
 00FFE738 02E02E04D04A05502602A           fcb     $2e,$2e,$4d,$4a,$55,$26,$2a,$2e
 00FFE73F 02E
 00FFE740 02E03C04B04904F029028           fcb     $2e,$3c,$4b,$49,$4f,$29,$28,$2e
 00FFE747 02E
 00FFE748 02E03E03F04C03A05005F           fcb     $2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
 00FFE74F 02E
 00FFE750 02E02E02202E07B02B02E           fcb     $2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
 00FFE757 02E
 00FFE758 02E02E00D07D02E07C02E           fcb     $2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
 00FFE75F 02E
 00FFE760 02E02E02E02E02E02E008           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
 00FFE767 02E
 00FFE768 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE76F 02E
 00FFE770 02E07F02E02E02E02E01B           fcb     $2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
 00FFE777 02E
 00FFE778 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE77F 02E
 
 00FFE780 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE787 02E
 00FFE788 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE78F 02E
 00FFE790 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE797 02E
 00FFE798 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE79F 02E
 00FFE7A0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7A7 02E
 00FFE7A8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7AF 02E
 00FFE7B0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7B7 02E
 00FFE7B8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7BF 02E
 00FFE7C0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7C7 02E
 00FFE7C8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7CF 02E
 00FFE7D0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7D7 02E
 00FFE7D8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7DF 02E
 00FFE7E0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7E7 02E
 00FFE7E8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7EF 02E
 00FFE7F0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7F7 02E
 00FFE7F8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE7FF 02E
 
                              ; control
                              keybdControlCodes:
 00FFE800 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE807 02E
 00FFE808 02E02E02E02E02E00907E           fcb     $2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
 00FFE80F 02E
 00FFE810 02E02E02E02E02E011021           fcb     $2e,$2e,$2e,$2e,$2e,$11,$21,$2e
 00FFE817 02E
 00FFE818 02E02E01A013001017040           fcb     $2e,$2e,$1a,$13,$01,$17,$40,$2e
 00FFE81F 02E
 00FFE820 02E003018004005024023           fcb     $2e,$03,$18,$04,$05,$24,$23,$2e
 00FFE827 02E
 00FFE828 02E020016006014012025           fcb     $2e,$20,$16,$06,$14,$12,$25,$2e
 00FFE82F 02E
 00FFE830 02E00E00200800701905E           fcb     $2e,$0e,$02,$08,$07,$19,$5e,$2e
 00FFE837 02E
 00FFE838 02E02E00D00A01502602A           fcb     $2e,$2e,$0d,$0a,$15,$26,$2a,$2e
 00FFE83F 02E
 00FFE840 02E03C00B00900F029028           fcb     $2e,$3c,$0b,$09,$0f,$29,$28,$2e
 00FFE847 02E
 00FFE848 02E03E03F00C03A01005F           fcb     $2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
 00FFE84F 02E
 00FFE850 02E02E02202E07B02B02E           fcb     $2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
 00FFE857 02E
 00FFE858 02E02E00D07D02E07C02E           fcb     $2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
 00FFE85F 02E
 00FFE860 02E02E02E02E02E02E008           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
 00FFE867 02E
 00FFE868 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE86F 02E
 00FFE870 02E07F02E02E02E02E01B           fcb     $2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
 00FFE877 02E
 00FFE878 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE87F 02E
 
                              keybdExtendedCodes:
 00FFE880 02E02E02E02E0A30A10A2           fcb     $2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
 00FFE887 02E
 00FFE888 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE88F 02E
 00FFE890 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE897 02E
 00FFE898 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE89F 02E
 00FFE8A0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE8A7 02E
 00FFE8A8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE8AF 02E
 00FFE8B0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE8B7 02E
 00FFE8B8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE8BF 02E
 00FFE8C0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE8C7 02E
 00FFE8C8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE8CF 02E
 00FFE8D0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE8D7 02E
 00FFE8D8 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE8DF 02E
 00FFE8E0 02E02E02E02E02E02E02E           fcb     $2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
 00FFE8E7 02E
 00FFE8E8 02E09502E09309402E02E           fcb     $2e,$95,$2e,$93,$94,$2e,$2e,$2e
 00FFE8EF 02E
 00FFE8F0 09809909202E09109002E           fcb     $98,$99,$92,$2e,$91,$90,$2e,$2e
 00FFE8F7 02E
 00FFE8F8 02E02E09702E02E09602E           fcb     $2e,$2e,$97,$2e,$2e,$96,$2e,$2e
 00FFE8FF 02E
 
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2013-2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ;       Keyboard driver routines to interface to a PS2 style keyboard
                              ; Converts the scancode to ascii
                              ;
                              ; This source file is free software: you can redistribute it and/or modify 
                              ; it under the terms of the GNU Lesser General Public License as published 
                              ; by the Free Software Foundation, either version 3 of the License, or     
                              ; (at your option) any later version.                                      
                              ;                                                                          
                              ; This source file is distributed in the hope that it will be useful,      
                              ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                              ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                              ; GNU General Public License for more details.                             
                              ;                                                                          
                              ; You should have received a copy of the GNU General Public License        
                              ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                              ;                                                                          
                              ; ============================================================================
                              ;
                              SC_F12  EQU     $07
                              SC_C    EQU             $21
                              SC_T    EQU         $2C
                              SC_Z            EQU     $1A
                              SC_DEL  EQU                     $71     ; extend
                              SC_KEYUP        EQU             $F0     ; should be $f0
                              SC_EXTEND EQU     $E0
                              SC_CTRL EQU                     $14
                              SC_RSHIFT               EQU     $59
                              SC_NUMLOCK      EQU     $77
                              SC_SCROLLLOCK           EQU     $7E
                              SC_CAPSLOCK             EQU             $58
                              SC_ALT  EQU                     $11
 
                              ;#define SC_LSHIFT      EQU             $12
                              ;SC_DEL         EQU             $71             ; extend
                              ;SC_LCTRL       EQU             $58
 
                              SC_TAB  EQU     $0D
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Recieve a byte from the keyboard, used after a command is sent to the
                              ; keyboard in order to wait for a response.
                              ;
                              ; Parameters: none
                              ; Returns: accd = recieved byte ($00 to $FF), -1 on timeout
                              ; Modifies: acc
                              ; Stack Space: 2 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdRecvByte:
 00FFE900 034010                          pshs    x
 00FFE902 08E000064                       ldx             #100                                            ; wait up to 1s
                              krb3:
 00FFE905 08D05A                          bsr             KeybdGetStatus  ; wait for response from keyboard
 00FFE907 05D                             tstb
 00FFE908 02B00B                          bmi             krb4                                            ; is input buffer full ? yes, branch
 00FFE90A 08D02D                          bsr             Wait10ms                                ; wait a bit
 00FFE90C 0301FF                          dex
 00FFE90E 026FF5                          bne             krb3                                            ; go back and try again
 00FFE910 0CCFFFFFF                       ldd             #-1                                                     ; return -1
 00FFE913 035090                          puls    x,pc
                              krb4:
 00FFE915 08D066                          bsr             KeybdGetScancode
 00FFE917 035090                          puls    x,pc
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Send a byte to the keyboard.
                              ;
                              ; Parameters: accb byte to send
                              ; Returns: none
                              ; Modifies: none
                              ; Stack Space: 0 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdSendByte:
 00FFE919 0150F7FFFE30400                 stb             KEYBD
 00FFE91E 039                             rts
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Wait until the keyboard transmit is complete
                              ;
                              ; Parameters: none
                              ; Returns: r1 = 0 if successful, r1 = -1 timeout
                              ; Modifies: r1
                              ; Stack Space: 3 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdWaitTx:
 00FFE91F 034010                          pshs    x
 00FFE921 08E000064                       ldx             #100                            ; wait a max of 1s
                              kwt1:
 00FFE924 08D03B                          bsr             KeybdGetStatus
 00FFE926 0C4040                          andb    #$40                            ; check for transmit complete bit; branch if bit set
 00FFE928 02600B                          bne             kwt2
 00FFE92A 08D00D                          bsr             Wait10ms                ; delay a little bit
 00FFE92C 0301FF                          dex
 00FFE92E 026FF4                          bne             kwt1                            ; go back and try again
 00FFE930 0CCFFFFFF                       ldd             #-1                                     ; timed out, return -1
 00FFE933 035090                          puls    x,pc
                              kwt2:
 00FFE935 04F                             clra                                                    ; wait complete, return 0
 00FFE936 05F                             clrb                                                    
 00FFE937 035090                          puls    x,pc                            
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Wait for 10 ms
                              ;
                              ; Parameters: none
                              ; Returns: none
                              ; Modifies: none
                              ; Stack Space: 2 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              Wait10ms:
 00FFE939 034006                          pshs    d
 00FFE93B 0150B6FFFFFFFE7                 lda             MSCOUNT+3
                              W10_0001:
 00FFE940 01F089                          tfr             a,b
 00FFE942 0150F0FFFFFFFE7                 subb    MSCOUNT+3
 00FFE947 0C1FFA                          cmpb    #$FFA
 00FFE949 022FF5                          bhi             W10_0001
 00FFE94B 035086                          puls    d,pc
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Wait for 300 ms (256 ms)
                              ;
                              ; Parameters: none
                              ; Returns: none
                              ; Modifies: none
                              ; Stack Space: 2 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              Wait300ms:
 00FFE94D 034006                          pshs    d
 00FFE94F 0150B6FFFFFFFE7                 lda             MSCOUNT+3
                              W300_0001:
 00FFE954 01F089                          tfr             a,b
 00FFE956 0150F0FFFFFFFE7                 subb    MSCOUNT+3
 00FFE95B 0C1F00                          cmpb    #$F00
 00FFE95D 022FF5                          bhi     W300_0001
 00FFE95F 035086                          puls    d,pc
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Get the keyboard status
                              ;
                              ; Parameters: none
                              ; Returns: d = status
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdGetStatus:
                              kbgs3:
 00FFE961 0150F6FFFE30401                 ldb             KEYBD+1
 00FFE966 0C5080                          bitb    #$80
 00FFE968 02600E                          bne             kbgs1
 00FFE96A 0C5001                          bitb    #$01            ; check parity error flag
 00FFE96C 026002                          bne             kbgs2
 00FFE96E 04F                             clra
 00FFE96F 039                             rts
                              kbgs2:
 00FFE970 0C60FE                          ldb             #$FE            ; request resend
 00FFE972 08DFA5                          bsr             KeybdSendByte
 00FFE974 08DFA9                          bsr             KeybdWaitTx
 00FFE976 020FE9                          bra             kbgs3
                              kbgs1:                                  ; return negative status
 00FFE978 0CAF00                          orb             #$F00
 00FFE97A 086FFF                          lda             #-1
 00FFE97C 039                             rts
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Get the scancode from the keyboard port
                              ;
                              ; Parameters: none
                              ; Returns: acca = scancode
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdGetScancode:
 00FFE97D 04F                             clra
 00FFE97E 0150F6FFFE30400                 ldb             KEYBD                           ; get the scan code
 00FFE983 01507FFFFE30401                 clr             KEYBD+1                 ; clear receive register (write $00 to status reg)
 00FFE988 039                             rts
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Set the LEDs on the keyboard.
                              ;
                              ; Parameters: d LED status to set
                              ; Returns: none
                              ; Modifies: none
                              ; Stack Space: 2 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdSetLED:
 00FFE989 034004                          pshs    b
 00FFE98B 0C60ED                          ldb             #$ED                                            ; set LEDs command
 00FFE98D 08DF8A                          bsr             KeybdSendByte
 00FFE98F 08DF8E                          bsr             KeybdWaitTx
 00FFE991 08DF6D                          bsr             KeybdRecvByte   ; should be an ack
 00FFE993 035004                          puls    b
 00FFE995 08DF82                          bsr             KeybdSendByte
 00FFE997 08DF86                          bsr             KeybdWaitTx
 00FFE999 08DF65                          bsr             KeybdRecvByte   ; should be an ack
 00FFE99B 039                             rts
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Get ID - get the keyboards identifier code.
                              ;
                              ; Parameters: none
                              ; Returns: d = $AB83, $00 on fail
                              ; Modifies: d, KeybdID updated
                              ; Stack Space: 2 words
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdGetID:
 00FFE99C 0C60F2                          ldb             #$F2
 00FFE99E 08DF79                          bsr             KeybdSendByte
 00FFE9A0 08DF7D                          bsr             KeybdWaitTx
 00FFE9A2 08DF5C                          bsr             KeybdRecvByte
 00FFE9A4 0C5080                          bitb    #$80
 00FFE9A6 026014                          bne             kgnotKbd
 00FFE9A8 0C10AB                          cmpb    #$AB
 00FFE9AA 026010                          bne             kgnotKbd
 00FFE9AC 08DF52                          bsr             KeybdRecvByte
 00FFE9AE 0C5080                          bitb    #$80
 00FFE9B0 02600A                          bne             kgnotKbd
 00FFE9B2 0C1083                          cmpb    #$83
 00FFE9B4 026006                          bne             kgnotKbd
 00FFE9B6 0CC00AB83                       ldd             #$AB83
                              kgid1:
 00FFE9B9 0DD124                          std             KeybdID
 00FFE9BB 039                             rts
                              kgnotKbd:
 00FFE9BC 04F                             clra
 00FFE9BD 05F                             clrb
 00FFE9BE 020FF9                          bra             kgid1
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Initialize the keyboard.
                              ;
                              ; Parameters:
                              ;               none
                              ;       Modifies:
                              ;               none
                              ; Returns:
                              ;               none
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdInit:
 00FFE9C0 034026                          pshs    d,y
 00FFE9C2 18E000005                       ldy             #5
 00FFE9C5 00F120                          clr             KeyState1               ; records key up/down state
 00FFE9C7 00F121                          clr             KeyState2               ; records shift,ctrl,alt state
                              kbdi0002:
 00FFE9C9 08DF6E                          bsr             Wait10ms
 00FFE9CB 01507FFFFE30401                 clr             KEYBD+1                 ; clear receive register (write $00 to status reg)
 00FFE9D0 0C6FFF                          ldb             #-1                                     ; send reset code to keyboard
 00FFE9D2 0150F7FFFE30401                 stb             KEYBD+1                 ; write $FF to status reg to clear TX state
 00FFE9D7 08DF40                          bsr             KeybdSendByte   ; now write to transmit register
 00FFE9D9 08DF44                          bsr             KeybdWaitTx             ; wait until no longer busy
 00FFE9DB 08DF23                          bsr             KeybdRecvByte   ; look for an ACK ($FA)
 00FFE9DD 0C10FA                          cmpb    #$FA
 00FFE9DF 026021                          bne             kbdiTryAgain
 00FFE9E1 08DF1D                          bsr             KeybdRecvByte   ; look for BAT completion code ($AA)
 00FFE9E3 0C10FC                          cmpb    #$FC                            ; reset error ?
 00FFE9E5 02701B                          beq             kbdiTryAgain
 00FFE9E7 0C10AA                          cmpb    #$AA                            ; reset complete okay ?
 00FFE9E9 026017                          bne             kbdiTryAgain
 
                                      ; After a reset, scan code set #2 should be active
                              .config:
 00FFE9EB 0C60F0                          ldb             #$F0                    ; send scan code select
 00FFE9ED 0150F7FFFE60001                 stb             LEDS
 00FFE9F2 08DF25                          bsr             KeybdSendByte
 00FFE9F4 08DF29                          bsr             KeybdWaitTx
 00FFE9F6 05D                             tstb
 00FFE9F7 02B009                          bmi             kbdiTryAgain
 00FFE9F9 08DF05                          bsr             KeybdRecvByte   ; wait for response from keyboard
 00FFE9FB 04D                             tsta
 00FFE9FC 02B004                          bmi             kbdiTryAgain
 00FFE9FE 0C10FA                          cmpb    #$FA                                    ; ACK
 00FFEA00 02700C                          beq             kbdi0004
                              kbdiTryAgain:
 00FFEA02 0313FF                          dey
 00FFEA04 026FC3                          bne       kbdi0002
                              .keybdErr:
 00FFEA06 0CCFFEA2E                       ldd             #msgBadKeybd
 00FFEA09 017FFF9F1                       lbsr    DisplayStringCRLF
*** warning 1: Long branch within short branch range could be optimized
 00FFEA0C 020014                          bra             ledxit
                              kbdi0004:
 00FFEA0E 0C6002                          ldb             #2                      ; select scan code set #2
 00FFEA10 08DF07                          bsr             KeybdSendByte
 00FFEA12 08DF0B                          bsr             KeybdWaitTx
 00FFEA14 05D                             tstb
 00FFEA15 02BFEB                          bmi             kbdiTryAgain
 00FFEA17 08DEE7                          bsr             KeybdRecvByte   ; wait for response from keyboard
 00FFEA19 04D                             tsta
 00FFEA1A 02BFE6                          bmi             kbdiTryAgain
 00FFEA1C 0C10FA                          cmpb    #$FA
 00FFEA1E 026FE2                          bne             kbdiTryAgain
 00FFEA20 08DF7A                          bsr             KeybdGetID
                              ledxit:
 00FFEA22 0C6007                          ldb             #$07
 00FFEA24 08DF63                          bsr             KeybdSetLED
 00FFEA26 08DF25                          bsr             Wait300ms
 00FFEA28 0C6000                          ldb             #$00
 00FFEA2A 08DF5D                          bsr             KeybdSetLED
 00FFEA2C 0350A6                          puls    d,y,pc
 
                              msgBadKeybd:
 00FFEA2E 04B06507906206F061072           fcb             "Keyboard error",0
 00FFEA35 06402006507207206F072
 00FFEA3C 000
 
                              ;------------------------------------------------------------------------------
                              ; Calculate number of character in input buffer
                              ;
                              ; Parameters:
                              ;               y = $Cn00000 where n is core id
                              ; Returns:
                              ;               d = number of bytes in buffer.
                              ;------------------------------------------------------------------------------
 
                              kbdRcvCount:
 00FFEA3D 04F                             clra
 00FFEA3E 0E6A08128                       ldb             kbdTailRcv,y
 00FFEA41 0E0A08127                       subb    kbdHeadRcv,y
 00FFEA44 02C008                          bge             krcXit
 00FFEA46 0C6040                          ldb             #$40
 00FFEA48 0E0A08127                       subb    kbdHeadRcv,y
 00FFEA4B 0EBA08128                       addb    kbdTailRcv,y
                              krcXit:
 00FFEA4E 039                             rts
 
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              KeybdIRQ:
 00FFEA4F 0150B6FFFE30401                 lda             KEYBD+1                                         ; check status
 00FFEA54 085080                          bita    #$80                                                    ; was key pressed?
 00FFEA56 027034                          beq             notKbdIRQ                                       ; if not, exit
 00FFEA58 0150F6FFFE30400                 ldb             KEYBD                                                   ; get the scan code
 00FFEA5D 01507FFFFE30401                 clr             KEYBD+1                                         ; clear receive register (write $00 to status reg)
 00FFEA62 034004                          pshs    b                                                                       ; save it off
 00FFEA64 0B6FFC010                       lda             IOFocusID                                       ; compute core memory address $Cn0000
 00FFEA67 05F                             clrb
 00FFEA68 048                             asla
 00FFEA69 048                             asla
 00FFEA6A 048                             asla
 00FFEA6B 048                             asla
 00FFEA6C 08AC00                          ora             #$C00                                                   ; address $Cn0000       
 00FFEA6E 01F002                          tfr             d,y                                                             ; y =
 00FFEA70 08DFCB                          bsr             kbdRcvCount                             ; get count of scan codes in buffer
 00FFEA72 0C1040                          cmpb    #64                                                             ; check if buffer full?
 00FFEA74 024017                          bhs             kbdBufFull                              ; if buffer full, ignore new keystroke
 00FFEA76 01F021                          tfr             y,x                                                             ; compute fifo address
 00FFEA78 0E6A08128                       ldb             kbdTailRcv,y                    ; b = buffer index
 00FFEA7B 035002                          puls    a                                                                       ; get back scancode
 00FFEA7D 030040                          leax    kbdFifo,x                                       ; x = base address for fifo
 00FFEA7F 0A7845                          sta             b,x                                                             ; store in buffer
 00FFEA81 05C                             incb                                                                            ; increment buffer index
 00FFEA82 0C403F                          andb    #$3f                                                    ; wrap around at 64 chars
 00FFEA84 0E7A08128                       stb             kbdTailRcv,y                    ; update it
 00FFEA87 08601C                          lda             #28                                                             ; Keyboard is IRQ #28
 00FFEA89 0B7FFC011                       sta             IrqSource                                       ; stuff a byte indicating the IRQ source for PEEK()
                              notKbdIRQ:
 00FFEA8C 039                             rts     
                              kbdBufFull:
 00FFEA8D 032601                          leas    1,s                                                             ; get rid of saved scancode
 00FFEA8F 039                             rts
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              DBGCheckForKey:
 00FFEA90 020ECF                          bra             KeybdGetStatus
 
 
                              ; KeyState2 variable bit meanings
                              ;1176543210
                              ; ||||||||+ = shift
                              ; |||||||+- = alt
                              ; ||||||+-- = control
                              ; |||||+--- = numlock
                              ; ||||+---- = capslock
                              ; |||+----- = scrolllock
                              ; ||+------ = <empty>
                              ; |+------- =    "
                              ; |         =    "
                              ; |         =    "
                              ; |         =    "
                              ; +-------- = extended
 
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                              ; Keyboard get routine.
                              ;
                              ; The routine may get characters directly from the scancode input or less
                              ; directly from the scancode buffer, if things are interrupt driven.
                              ;
                              ; Parameters:
                              ;               b:  bit 11 = blocking status 1=blocking, 0=non blocking
                              ;               b:      bit 1  = scancode source 1=scancode buffer, 0=direct
                              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
                              GetKey:
 00FFEA92 034030                          pshs    x,y
 00FFEA94 0D7126                          stb             KeybdBlock                              ; save off blocking status
                              dbgk2:
 00FFEA96 0D6126                          ldb             KeybdBlock
 00FFEA98 034004                          pshs    b
 00FFEA9A 0C5001                          bitb    #1                                                              ; what is the scancode source
 00FFEA9C 02701A                          beq             dbgk20                                          ; branch if direct read
 00FFEA9E 0150B6FFFFFFFE0                 lda             COREID                                          ; compute core memory address
 00FFEAA3 05F                             clrb
 00FFEAA4 048                             asla
 00FFEAA5 048                             asla
 00FFEAA6 048                             asla
 00FFEAA7 048                             asla
 00FFEAA8 08AC00                          ora             #$C00
 00FFEAAA 01F002                          tfr             d,y                                                             ; y = $Cn0000
 00FFEAAC 08DF8F                          bsr             kbdRcvCount
 00FFEAAE 05D                             tstb                                                                            ; anything in buffer?
 00FFEAAF 035004                          puls    b
 00FFEAB1 026018                          bne             dbgk1                                                   ; branch if something in buffer
 00FFEAB3 05D                             tstb
 00FFEAB4 02BFE0                          bmi             dbgk2                                                   ; if no key and blocking - loop
 00FFEAB6 02000E                          bra             dbgk24
                              dbgk20:
 00FFEAB8 18E000000                       ldy             #0
 00FFEABB 08DEA4                          bsr             KeybdGetStatus
 00FFEABD 0C4080                          andb    #$80                                                    ; is key available?
 00FFEABF 035004                          puls    b
 00FFEAC1 026008                          bne             dbgk1                                                   ; branch if key
 00FFEAC3 05D                             tstb                                                                            ; block?
 00FFEAC4 02BFD0                          bmi             dbgk2                                                   ; If no key and blocking - loop
                              dbgk24:
 00FFEAC6 0CCFFFFFF                       ldd             #-1                                                             ; return -1 if no block and no key
 00FFEAC9 0350B0                          puls    x,y,pc
                              dbgk1:
 00FFEACB 18C000000                       cmpy    #0
 00FFEACE 026004                          bne             dbgk22
 00FFEAD0 08DEAB                          bsr             KeybdGetScancode        ; get scancode directly
 00FFEAD2 020011                          bra             dbgk23
                              dbgk22:
                                      ; Retrieve value from scancode buffer
 00FFEAD4 01F021                          tfr             y,x
 00FFEAD6 030040                          leax    kbdFifo,x                                       ; x = fifo address
 00FFEAD8 0E6A08127                       ldb             kbdHeadRcv,y                    ; b = buffer index
 00FFEADB 0A6A0D                          lda             b,x                                                             ; get the scancode
 00FFEADD 05C                             incb                                                                            ; increment fifo index
 00FFEADE 0C403F                          andb    #$3f                                                    ; and wrap around
 00FFEAE0 0E7A08127                       stb             kbdHeadRcv,y                    ; save it back
 00FFEAE3 01F089                          tfr             a,b                                                             ; the scancode is needed in accb
                              dbgk23:
                              ;       lbsr    DispByteAsHex
                                      ; Make sure there is a small delay between scancode reads
 00FFEAE5 08E000014                       ldx             #20
                              dbgk3:
 00FFEAE8 0301FF                          dex
 00FFEAEA 026FFC                          bne             dbgk3
                                      ; switch on scan code
 00FFEAEC 0C10F0                          cmpb    #SC_KEYUP
 00FFEAEE 026004                          bne             dbgk4
 00FFEAF0 0D7120                          stb             KeyState1                                       ; make KeyState1 <> 0
 00FFEAF2 020FA2                          bra             dbgk2                                                   ; loop back
                              dbgk4:
 00FFEAF4 0C10E0                          cmpb    #SC_EXTEND
 00FFEAF6 026008                          bne             dbgk5
 00FFEAF8 096121                          lda             KeyState2
 00FFEAFA 08A800                          ora             #$800
 00FFEAFC 097121                          sta             KeyState2
 00FFEAFE 020F96                          bra             dbgk2
                              dbgk5:
 00FFEB00 0C1014                          cmpb    #SC_CTRL
 00FFEB02 026016                          bne             dbgkNotCtrl
 00FFEB04 00D120                          tst             KeyState1
 00FFEB06 026008                          bne             dbgk7
 00FFEB08 096121                          lda             KeyState2
 00FFEB0A 08A004                          ora             #4
 00FFEB0C 097121                          sta             KeyState2
 00FFEB0E 020006                          bra             dbgk8
                              dbgk7:
 00FFEB10 096121                          lda             KeyState2
 00FFEB12 084FFB                          anda    #~4
 00FFEB14 097121                          sta             KeyState2
                              dbgk8:
 00FFEB16 00F120                          clr             KeyState1
 00FFEB18 020F7C                          bra             dbgk2
                              dbgkNotCtrl:
 00FFEB1A 0C1059                          cmpb    #SC_RSHIFT
 00FFEB1C 026016                          bne             dbgkNotRshift
 00FFEB1E 00D120                          tst             KeyState1
 00FFEB20 026008                          bne             dbgk9
 00FFEB22 096121                          lda             KeyState2
 00FFEB24 08A001                          ora             #1
 00FFEB26 097121                          sta             KeyState2
 00FFEB28 020006                          bra             dbgk10
                              dbgk9:
 00FFEB2A 096121                          lda             KeyState2
 00FFEB2C 084FFE                          anda    #~1
 00FFEB2E 097121                          sta             KeyState2
                              dbgk10:
 00FFEB30 00F120                          clr             KeyState1
 00FFEB32 020F62                          bra             dbgk2
                              dbgkNotRshift:
 00FFEB34 0C1077                          cmpb    #SC_NUMLOCK
 00FFEB36 026013                          bne             dbgkNotNumlock
 00FFEB38 096121                          lda             KeyState2
 00FFEB3A 088010                          eora    #16
 00FFEB3C 097121                          sta             KeyState2
 00FFEB3E 096122                          lda             KeyLED
 00FFEB40 088002                          eora    #2
 00FFEB42 097122                          sta             KeyLED
 00FFEB44 01F089                          tfr             a,b
 00FFEB46 04F                             clra
 00FFEB47 08DE40                          bsr             KeybdSetLED
 00FFEB49 020F4B                          bra             dbgk2
                              dbgkNotNumlock:
 00FFEB4B 0C1058                          cmpb    #SC_CAPSLOCK
 00FFEB4D 026013                          bne             dbgkNotCapslock
 00FFEB4F 096121                          lda             KeyState2
 00FFEB51 088020                          eora    #32
 00FFEB53 097121                          sta             KeyState2
 00FFEB55 096122                          lda             KeyLED
 00FFEB57 088004                          eora    #4
 00FFEB59 097122                          sta             KeyLED
 00FFEB5B 01F089                          tfr             a,b
 00FFEB5D 04F                             clra
 00FFEB5E 08DE29                          bsr             KeybdSetLED
 00FFEB60 020F34                          bra             dbgk2
                              dbgkNotCapslock:
 00FFEB62 0C107E                          cmpb    #SC_SCROLLLOCK
 00FFEB64 026013                          bne             dbgkNotScrolllock
 00FFEB66 096121                          lda             KeyState2
 00FFEB68 088040                          eora    #64
 00FFEB6A 097121                          sta             KeyState2
 00FFEB6C 096122                          lda             KeyLED
 00FFEB6E 088001                          eora    #1
 00FFEB70 097122                          sta             KeyLED
 00FFEB72 01F089                          tfr             a,b
 00FFEB74 04F                             clra
 00FFEB75 08DE12                          bsr             KeybdSetLED
 00FFEB77 020F1D                          bra             dbgk2
                              dbgkNotScrolllock:
 00FFEB79 0C1011                          cmpb    #SC_ALT
 00FFEB7B 026016                          bne             dbgkNotAlt
 00FFEB7D 00D120                          tst             KeyState1
 00FFEB7F 026008                          bne             dbgk11
 00FFEB81 096121                          lda             KeyState2
 00FFEB83 08A002                          ora             #2
 00FFEB85 097121                          sta             KeyState2
 00FFEB87 020006                          bra             dbgk12
                              dbgk11:
 00FFEB89 096121                          lda             KeyState2
 00FFEB8B 084FFD                          anda    #~2
 00FFEB8D 097121                          sta             KeyState2
                              dbgk12:
 00FFEB8F 00F120                          clr             KeyState1
 00FFEB91 020F03                          bra             dbgk2
                              dbgkNotAlt:
 00FFEB93 00D120                          tst             KeyState1
 00FFEB95 027004                          beq             dbgk13
 00FFEB97 00F120                          clr             KeyState1
 00FFEB99 020EFB                          bra             dbgk2
                              dbgk13:
 00FFEB9B 096121                          lda             KeyState2               ; Check for CTRL-ALT-DEL
 00FFEB9D 084006                          anda    #6
 00FFEB9F 081006                          cmpa    #6
 00FFEBA1 026008                          bne             dbgk14
 00FFEBA3 0C1071                          cmpb    #SC_DEL 
 00FFEBA5 026004                          bne             dbgk14
 00FFEBA7 06E90FFFFFFC                    jmp             [$FFFFFC]               ; jump to NMI vector
                              dbgk14:
 00FFEBAB 00D121                          tst             KeyState2               ; extended code?
 00FFEBAD 02A00B                          bpl             dbgk15
 00FFEBAF 096121                          lda             KeyState2
 00FFEBB1 0847FF                          anda    #$7FF
 00FFEBB3 097121                          sta             KeyState2
 00FFEBB5 08EFFE880                       ldx             #keybdExtendedCodes
 00FFEBB8 020017                          bra             dbgk18
                              dbgk15:
 00FFEBBA 096121                          lda             KeyState2               ; Is CTRL down?
 00FFEBBC 085004                          bita    #4
 00FFEBBE 027005                          beq             dbgk16
 00FFEBC0 08EFFE800                       ldx             #keybdControlCodes
 00FFEBC3 02000C                          bra             dbgk18
                              dbgk16:
 00FFEBC5 085001                          bita    #1                                      ; Is shift down?
 00FFEBC7 027005                          beq             dbgk17
 00FFEBC9 08EFFE700                       ldx             #shiftedScanCodes
 00FFEBCC 020003                          bra             dbgk18
                              dbgk17:
 00FFEBCE 08EFFE600                       ldx             #unshiftedScanCodes
                              dbgk18:
 00FFEBD1 0E690FFFE600                    ldb             b,x                                     ; load accb with ascii from table
 00FFEBD5 04F                             clra
 00FFEBD6 0350B0                          puls    x,y,pc                  ; and return
                                      
 
 00FFEBD8 04B04505904204F041052           fcb             "KEYBOARD"
 00FFEBDF 044
 00FFEBE0 FFEBEA                          fcw             KeybdOpen
 00FFEBE2 FFEBEB                          fcw             KeybdClose
 00FFEBE4 FFEBEC                          fcw             KeybdRead
 00FFEBE6 FFEBED                          fcw             KeybdWrite
 00FFEBE8 FFEBEE                          fcw             KeybdSeek
 
                              ; Keyboard Open:
                              ; Initialize the keyboard buffer head and tail indexes
                              ;
                              KeybdOpen:
 00FFEBEA 039                             rts
 
                              ; Keyboard Close:
                              ; Nothing to do except maybe clear the keyboard buffer
                              ;
                              KeybdClose:
 00FFEBEB 039                             rts
                              ;
                              KeybdRead:
 00FFEBEC 039                             rts
                              ;
                              KeybdWrite:
 00FFEBED 039                             rts
 
                              KeybdSeek:
 00FFEBEE 039                             rts
 
                              ;==============================================================================
                              ; Serial I/O
                              ;==============================================================================
 
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; Serial port routines for a WDC6551 compatible circuit.
                              ;
                              ; This source file is free software: you can redistribute it and/or modify 
                              ; it under the terms of the GNU Lesser General Public License as published 
                              ; by the Free Software Foundation, either version 3 of the License, or     
                              ; (at your option) any later version.                                      
                              ;                                                                          
                              ; This source file is distributed in the hope that it will be useful,      
                              ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                              ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                              ; GNU General Public License for more details.                             
                              ;                                                                          
                              ; You should have received a copy of the GNU General Public License        
                              ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                              ;                                                                          
                              ; ============================================================================
                              ;
                              ;------------------------------------------------------------------------------
                              ; Initialize serial port.
                              ;
                              ; Clear buffer indexes. Two bytes are used for the buffer index even though
                              ; only a single byte is needed. This is for convenience in calculating the
                              ; number of characters in the buffer, done later. The upper byte remains at
                              ; zero.
                              ; The port is initialized for 9600 baud, 1 stop bit and 8 bits data sent.
                              ; The internal baud rate generator is used.
                              ;
                              ; Parameters:
                              ;               none
                              ; Modifies:
                              ;               d
                              ; Returns:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                                      setdp   $FFC
 
                              InitSerial:
                              SerialInit:
 00FFEBEF 034008                          pshs    dpr
 00FFEBF1 086FFC                          lda             #$FFC
 00FFEBF3 01F08B                          tfr             a,dpr
 00FFEBF5 04F                             clra
 00FFEBF6 05F                             clrb
 00FFEBF7 00F015                          clr             SerHeadRcv
 00FFEBF9 00F016                          clr             SerTailRcv
 00FFEBFB 00F017                          clr             SerHeadXmit
 00FFEBFD 00F018                          clr             SerTailXmit
 00FFEBFF 00F019                          clr             SerRcvXon
 00FFEC01 00F01A                          clr             SerRcvXoff
 00FFEC03 0150B6FFFFFFFE0                 lda             COREID
                              sini1:
 00FFEC08 091010                          cmpa    IOFocusID
 00FFEC0A 026FFC                          bne             sini1
 00FFEC0C 0C600B                          ldb             #$0B                                            ; dtr,rts active, rxint enabled (bit 1=0), no parity
 00FFEC0E 0150F7FFFE30102                 stb             ACIA+ACIA_CMD
 00FFEC13 0C601E                          ldb             #$1E                                            ; baud 9600, 1 stop bit, 8 bit, internal baud gen
 00FFEC15 0150F7FFFE30103                 stb             ACIA+ACIA_CTRL
 00FFEC1A 0C60AC                          ldb             #$0AC                                           ; disable fifos (bit zero, one), reset fifos
 00FFEC1C 0150F7FFFE3010B                 stb             ACIA+ACIA_CTRL2 
 00FFEC21 035088                          puls    dpr,pc
 
                              ;------------------------------------------------------------------------------
                              ; SerialGetChar
                              ;
                              ; Check the serial port buffer to see if there's a char available. If there's
                              ; a char available then return it. If the buffer is almost empty then send an
                              ; XON.
                              ;
                              ; Stack Space:
                              ;               3 words
                              ; Parameters:
                              ;               none
                              ; Modifies:
                              ;               none
                              ; Returns:
                              ;               d = character or -1
                              ;------------------------------------------------------------------------------
 
                              SerialGetChar:
 00FFEC23 034039                          pshs    ccr,x,y,dpr
 00FFEC25 086FFC                          lda             #$FFC
 00FFEC27 01F08B                          tfr             a,dpr
 00FFEC29 01A010                          sei                                                                             ; disable interrupts
 00FFEC2B 08D090                          bsr             SerialRcvCount                  ; check number of chars in receive buffer
 00FFEC2D 0C1008                          cmpb    #8                                                      ; less than 8?
 00FFEC2F 02200C                          bhi             sgc2
 00FFEC31 0D6019                          ldb             SerRcvXon                               ; skip sending XON if already sent
 00FFEC33 026008                          bne       sgc2            ; XON already sent?
 00FFEC35 0C6011                          ldb             #XON                                            ; if <8 send an XON
 00FFEC37 00F01A                          clr             SerRcvXoff                      ; clear XOFF status
 00FFEC39 0D7019                          stb             SerRcvXon                               ; flag so we don't send it multiple times
 00FFEC3B 08D05D                          bsr             SerialPutChar
                              sgc2:
 00FFEC3D 0D6015                          ldb             SerHeadRcv                      ; check if anything is in buffer
 00FFEC3F 0D1016                          cmpb    SerTailRcv
 00FFEC41 02700D                          beq             sgcNoChars                      ; no?
 00FFEC43 03080FFFB000                    leax    SerRcvBuf                               ; x = buffer address
 00FFEC47 04F                             clra
 00FFEC48 0E680FFFB000                    ldb             b,x                                                     ; get byte from buffer
 00FFEC4C 00C015                          inc             SerHeadRcv                      ; 4k wrap around
 00FFEC4E 020003                          bra             sgcXit
                              sgcNoChars:
 00FFEC50 0CCFFFFFF                       ldd             #-1
                              sgcXit:
 00FFEC53 0350B9                          puls    ccr,x,y,dpr,pc
 
                              ;------------------------------------------------------------------------------
                              ; SerialPeekChar
                              ;
                              ; Check the serial port buffer to see if there's a char available. If there's
                              ; a char available then return it. But don't update the buffer indexes. No need
                              ; to send an XON here.
                              ;
                              ; Stack Space:
                              ;               2 words
                              ; Parameters:
                              ;               none
                              ; Modifies:
                              ;               none
                              ; Returns:
                              ;               d = character or -1
                              ;------------------------------------------------------------------------------
 
                              SerialPeekChar:
 00FFEC55 034019                          pshs    x,ccr,dpr
 00FFEC57 086FFC                          lda             #$FFC
 00FFEC59 01F08B                          tfr             a,dpr
 00FFEC5B 01A010                          sei
 00FFEC5D 0D6015                          ldb             SerHeadRcv                              ; check if anything is in buffer
 00FFEC5F 0D1016                          cmpb    SerTailRcv
 00FFEC61 02700B                          beq             spcNoChars                              ; no?
 00FFEC63 03080FFFB000                    leax    SerRcvBuf
 00FFEC67 04F                             clra
 00FFEC68 0E680FFFB000                    ldb             b,x                                                             ; get byte from buffer
 00FFEC6C 020003                          bra             spcXit
                              spcNoChars:
 00FFEC6E 0CCFFFFFF                       ldd             #-1
                              spcXit:
 00FFEC71 035099                          puls    x,ccr,dpr,pc
 
                              ;------------------------------------------------------------------------------
                              ; SerialPeekChar
                              ;               Get a character directly from the I/O port. This bypasses the input
                              ; buffer.
                              ;
                              ; Stack Space:
                              ;               0 words
                              ; Parameters:
                              ;               none
                              ; Modifies:
                              ;               d
                              ; Returns:
                              ;               d = character or -1
                              ;------------------------------------------------------------------------------
 
                              SerialPeekCharDirect:
 00FFEC73 034009                          pshs    ccr,dpr
 00FFEC75 086FFC                          lda             #$FFC
 00FFEC77 01F08B                          tfr             a,dpr
 00FFEC79 0150B6FFFFFFFE0                 lda             COREID                                                  ; Ensure we have the IO Focus
 00FFEC7E 091010                          cmpa    IOFocusID
 00FFEC80 026013                          bne             spcd0001
                                      ; Disallow interrupts between status read and rx read.
 00FFEC82 01A010                          sei
 00FFEC84 0150F6FFFE30101                 ldb             ACIA+ACIA_STAT
 00FFEC89 0C5008                          bitb    #8                                                                      ; look for Rx not empty
 00FFEC8B 027008                          beq             spcd0001
 00FFEC8D 04F                             clra
 00FFEC8E 0150F6FFFE30100                 ldb             ACIA+ACIA_RX
 00FFEC93 035089                          puls    ccr,dpr,pc
                              spcd0001:
 00FFEC95 0CCFFFFFF                       ldd             #-1
 00FFEC98 035089                          puls    ccr,dpr,pc
 
                              ;------------------------------------------------------------------------------
                              ; SerialPutChar
                              ;    Put a character to the serial transmitter. This routine blocks until the
                              ; transmitter is empty. 
                              ;
                              ; Stack Space
                              ;               0 words
                              ; Parameters:
                              ;               b = character to put
                              ; Modifies:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              SerialPutChar:
 00FFEC9A 03400B                          pshs    a,ccr,dpr
 00FFEC9C 086FFC                          lda             #$FFC
 00FFEC9E 01F08B                          tfr             a,dpr
                              spc0001:
 00FFECA0 0150B6FFFFFFFE0                 lda             COREID                                  ; Ensure we have the IO Focus
 00FFECA5 091010                          cmpa    IOFocusID
 00FFECA7 026FF7                          bne             spc0001
 00FFECA9 01C0EF                          cli                                                                             ; provide a window for an interrupt to occur
 00FFECAB 01A010                          sei
                                      ; Between the status read and the transmit do not allow an
                                      ; intervening interrupt.
 00FFECAD 0150B6FFFE30101                 lda             ACIA+ACIA_STAT  ; wait until the uart indicates tx empty
 00FFECB2 085010                          bita    #16                                                     ; bit #4 of the status reg
 00FFECB4 027FEA                          beq             spc0001                     ; branch if transmitter is not empty
 00FFECB6 0150F7FFFE30100                 stb             ACIA+ACIA_TX            ; send the byte
 00FFECBB 03508B                          puls    a,ccr,dpr,pc
 
                              ;------------------------------------------------------------------------------
                              ; Calculate number of character in input buffer. Direct page must be set
                              ; already.
                              ;
                              ; Parameters:
                              ;               none
                              ; Returns:
                              ;               d = number of bytes in buffer.
                              ;------------------------------------------------------------------------------
 
                              SerialRcvCount:
 00FFECBD 04F                             clra
 00FFECBE 0D6016                          ldb             SerTailRcv
 00FFECC0 0D0015                          subb    SerHeadRcv
 00FFECC2 02C007                          bge             srcXit
 00FFECC4 0CC001000                       ldd             #$1000
 00FFECC7 093015                          subd    SerHeadRcv
 00FFECC9 0D3016                          addd    SerTailRcv
                              srcXit:
 00FFECCB 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Serial IRQ routine
                              ;
                              ; Keeps looping as long as it finds characters in the ACIA recieve buffer/fifo.
                              ; Received characters are buffered. If the buffer becomes full, new characters
                              ; will be lost.
                              ;
                              ; Parameters:
                              ;               none
                              ; Modifies:
                              ;               d,x
                              ; Returns:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              SerialIRQ:
 00FFECCC 034008                          pshs    dpr                                                     ; set direct page register to boot variables
 00FFECCE 086FFC                          lda             #$FFC
 00FFECD0 01F08B                          tfr             a,dpr
 00FFECD2 0150B6FFFE3F0D3                 lda             PIC+$D3                                 ; Serial active interrupt flag
 00FFECD7 027042                          beq             notSerInt
                              sirqNxtByte:
 00FFECD9 0150F6FFFE30104                 ldb             ACIA+ACIA_IRQS  ; look for IRQs
 00FFECDE 02A03B                          bpl             notSerInt                               ; quick test for any irqs
 00FFECE0 0150F6FFFE30101                 ldb             ACIA+ACIA_STAT  ; check the status
 00FFECE5 0C5008                          bitb    #$08                                            ; bit 3 = rx full (not empty)
 00FFECE7 027030                          beq             notRxInt1
 00FFECE9 0150F6FFFE30100                 ldb             ACIA+ACIA_RX            ; get data from Rx buffer to clear interrupt
 00FFECEE 096016                          lda             SerTailRcv                      ; check if recieve buffer full
 00FFECF0 04C                             inca
 00FFECF1 091015                          cmpa    SerHeadRcv
 00FFECF3 027026                          beq             sirqRxFull
 00FFECF5 097016                          sta             SerTailRcv                      ; update tail pointer
 00FFECF7 04A                             deca                                                                    ; backup
 00FFECF8 01E089                          exg             a,b
 00FFECFA 03080FFFB000                    leax    SerRcvBuf                               ; x = buffer address
 00FFECFE 0A780FFFB000                    sta             b,x                                                     ; store recieved byte in buffer
 00FFED02 00D01A                          tst             SerRcvXoff                      ; check if xoff already sent
 00FFED04 026FD3                          bne             sirqNxtByte
 00FFED06 08DFB5                          bsr             SerialRcvCount  ; if more than 4070 chars in buffer
 00FFED08 0C1FE6                          cmpb    #4070
 00FFED0A 025FCD                          blo             sirqNxtByte
 00FFED0C 0C6013                          ldb             #XOFF                                           ; send an XOFF
 00FFED0E 00F019                          clr             SerRcvXon                               ; clear XON status
 00FFED10 0D701A                          stb             SerRcvXoff                      ; set XOFF status
 00FFED12 0150F7FFFE30100                 stb             ACIA+ACIA_TX
 00FFED17 020FC0                          bra             sirqNxtByte     ; check the status for another byte
                                      ; Process other serial IRQs
                              notRxInt1:
 00FFED19 035088                          puls    dpr,pc
                              sirqRxFull:
                              notRxInt:
                              notSerInt:
 00FFED1B 035088                          puls    dpr,pc
 
                              nmeSerial:
 00FFED1D 05306507206906106C000           fcb             "Serial",0
 
                              ;------------------------------------------------------------------------------
                              ; Put a string to the serial port.
                              ;
                              ; Parameters:
                              ;               d = pointer to string
                              ; Modifies:
                              ;               none
                              ; Returns:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              SerialPutString:
 00FFED24 034016                          pshs    d,x
 00FFED26 01F001                          tfr             d,x
                              sps2:
 00FFED28 0E6804                          ldb             ,x
 00FFED2A 027006                          beq             spsXit
 00FFED2C 030001                          inx
 00FFED2E 08DF6A                          bsr             SerialPutChar
 00FFED30 020FF6                          bra             sps2
                              spsXit:
 00FFED32 035096                          puls    d,x,pc
 
                              ;------------------------------------------------------------------------------
                              ; A little routine to test serial output.
                              ;
                              ; Parameters:
                              ;               none
                              ; Modifies:
                              ;               none
                              ; Returns:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              SerialOutputTest:
 00FFED34 034006                          pshs    d
 00FFED36 0CCFFED54                       ldd             #msgSerialTest
 00FFED39 017FFF6A1                       lbsr    DisplayString
*** warning 1: Long branch within short branch range could be optimized
 00FFED3C 08DEB1                          bsr             SerialInit
                              sotst1:
 00FFED3E 0C6011                          ldb             #XON
 00FFED40 08DF58                          bsr             SerialPutChar
 00FFED42 08DF56                          bsr             SerialPutChar
 00FFED44 08DF54                          bsr             SerialPutChar
 00FFED46 0CCFFED54                       ldd             #msgSerialTest
 00FFED49 08DFD9                          bsr             SerialPutString
 00FFED4B 017000443                       lbsr    INCH
 00FFED4E 0C1003                          cmpb    #CTRLC
 00FFED50 026FEC                          bne             sotst1
 00FFED52 035086                          puls    d,pc
 
                              msgSerialTest:
 00FFED54 05306507206906106C020           fcb     "Serial port test",CR,LF,0
 00FFED5B 07006F072074020074065
 00FFED62 07307400D00A000
 
                                      setdp   $000
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; BSD 3-Clause License
                              ; Redistribution and use in source and binary forms, with or without
                              ; modification, are permitted provided that the following conditions are met:
                              ;
                              ; 1. Redistributions of source code must retain the above copyright notice, this
                              ;    list of conditions and the following disclaimer.
                              ;
                              ; 2. Redistributions in binary form must reproduce the above copyright notice,
                              ;    this list of conditions and the following disclaimer in the documentation
                              ;    and/or other materials provided with the distribution.
                              ;
                              ; 3. Neither the name of the copyright holder nor the names of its
                              ;    contributors may be used to endorse or promote products derived from
                              ;    this software without specific prior written permission.
                              ;
                              ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                              ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                              ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                              ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                              ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                              ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                              ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                              ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                              ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                              ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                              ;                                                                          
                              ; ============================================================================
                              ;
                              ; S19 variables
                              ;
                              s19Address                      EQU             $940    ; to $943
                              s19StartAddress EQU             $944    ; to $947
                              s19Rectype                      EQU             $948
                              s19Reclen                               EQU             $949
                              s19Abort                                EQU             $94A
                              s19Checksum                     EQU             $94B
                              s19SummaryChecksum      EQU             $94C
                              s19Source                               EQU             $94E
                              s19XferAddress  EQU     $950    ; to $951
 
                              ; ------------------------------------------------------------------------------
                              ; Input a character either from a file in memory or from the serial port.
                              ;
                              ; Parameters:
                              ;               none
                              ;       Returns:
                              ;               accb = character input
                              ; ------------------------------------------------------------------------------
 
                              s19InputChar:
 00FFED67 07D00094E                       tst             s19Source
 00FFED6A 02700D                          beq             s19ic1
 00FFED6C 0E690F000950                    ldb             [s19XferAddress]
 00FFED70 07C000951                       inc             s19XferAddress+1        ; increment low byte of address pointer
 00FFED73 026003                          bne             s19ic2
 00FFED75 07C000950                       inc             s19XferAddress          ; increment high byte of address pointer
                              s19ic2:
 00FFED78 039                             rts
                              s19ic1:
 00FFED79 0CCFFFFFF                       ldd             #-1                                                     ; block until input is available
 00FFED7C 03F                             swi
 00FFED7D 001                             fcb             MF_INCH                                 ; monitor input rout
 00FFED7E 039                             rts     
 
                              ; ------------------------------------------------------------------------------
                              ; Skip over input to the next record.
                              ; ------------------------------------------------------------------------------
 
                              s19NextRecord:
 00FFED7F 08DFE6                          bsr             s19InputChar
 00FFED81 0C100A                          cmpb    #LF                                                     ; line feed marks end of record
 00FFED83 027013                          beq             s19nr1
 00FFED85 0C1003                          cmpb    #CTRLC                                  ; should not get this in a file transfer
 00FFED87 026003                          bne             s19nr2
 00FFED89 0F700094A                       stb             s19Abort
                              s19nr2:
 00FFED8C 0C101A                          cmpb    #CTRLZ                                  ; end of file marker?
 00FFED8E 026003                          bne             s19nr3
 00FFED90 0F700094A                       stb             s19Abort
                              s19nr3:
 00FFED93 07D00094A                       tst             s19Abort
 00FFED96 027FE7                          beq             s19NextRecord
                              s19nr1:
 00FFED98 039                             rts
 
                              ; ------------------------------------------------------------------------------
                              ; Update the checksum.
                              ; ------------------------------------------------------------------------------
 
                              s19AddCheck:
 00FFED99 034004                          pshs    b
 00FFED9B 0FB00094B                       addb    s19Checksum
 00FFED9E 0F700094B                       stb             s19Checksum
 00FFEDA1 035084                          puls    b,pc
 
                              ; ------------------------------------------------------------------------------
                              ; Input a byte. There are three characters per byte since things are 12-bit.
                              ;
                              ;       Parameters:
                              ;               none
                              ; Returns:
                              ;               accb = byte value converted from text
                              ; ------------------------------------------------------------------------------
 
                              s19GetByte:
 00FFEDA3 08DFC2                          bsr             s19InputChar                    ; get the first character
 00FFEDA5 0170007F7                       lbsr    AsciiToHexNybble        ; convert to nybble
 00FFEDA8 07D00094A                       tst             s19Abort                                        ; check for abort
 00FFEDAB 027002                          beq             s19gb1
 00FFEDAD 04F                             clra
 00FFEDAE 039                             rts
                              s19gb1:                                                                         ; shift the value four bits
 00FFEDAF 058                             aslb
 00FFEDB0 058                             aslb
 00FFEDB1 058                             aslb
 00FFEDB2 058                             aslb
 00FFEDB3 034004                          pshs    b                                                                       ; save off value
 00FFEDB5 08DFB0                          bsr             s19InputChar                    ; get the second character
 00FFEDB7 0170007E5                       lbsr    AsciiToHexNybble        ; convert to nybble
 00FFEDBA 07D00094A                       tst             s19Abort                                        ; check for abort
 00FFEDBD 026011                          bne             s19gb2
 00FFEDBF 0EAE00                          orb             ,s+                                                             ; merge new nybble into value
 00FFEDC1 058                             aslb                                                                            ; shift the value four more bits
 00FFEDC2 058                             aslb
 00FFEDC3 058                             aslb
 00FFEDC4 058                             aslb
 00FFEDC5 034004                          pshs    b                                                                       ; save off value
 00FFEDC7 08DF9E                          bsr             s19InputChar                    ; get the third character
 00FFEDC9 0170007D3                       lbsr    AsciiToHexNybble        ; convert to nybble
 00FFEDCC 0EAE00                          orb             ,s+                                                             ; merge in value
 00FFEDCE 04F                             clra                                                                            ; make byte 000 to FFF in D
 00FFEDCF 039                             rts
                              s19gb2:
 00FFEDD0 032601                          leas    1,s                                                             ; discard saved byte
 00FFEDD2 04F                             clra
 00FFEDD3 039                             rts
 
                              ; ------------------------------------------------------------------------------
                              ; Zero out address
                              ; ------------------------------------------------------------------------------
 
                              s19ClearAddress:
 00FFEDD4 07F000940                       clr             s19Address
 00FFEDD7 07F000941                       clr             s19Address+1
 00FFEDDA 07F000942                       clr             s19Address+2
 00FFEDDD 07F000943                       clr             s19Address+3
 00FFEDE0 039                             rts
                                      
                              ; ------------------------------------------------------------------------------
                              ; Get an address composed of two bytes (24 bit)
                              ;
                              ; Side Effects:
                              ;               updates s19Address variable
                              ; Returns:
                              ;       none
                              ; ------------------------------------------------------------------------------
 
                              s19GetAddress2:
 00FFEDE1 08DFF1                          bsr             s19ClearAddress
 00FFEDE3 08DFBE                          bsr             s19GetByte
 00FFEDE5 08DFB2                          bsr             s19AddCheck
 00FFEDE7 0F7000942                       stb             s19Address+2
 00FFEDEA 07D00094A                       tst             s19Abort
 00FFEDED 026007                          bne             s19ga1
 00FFEDEF 08DFB2                          bsr             s19GetByte
 00FFEDF1 08DFA6                          bsr             s19AddCheck
 00FFEDF3 0F7000943                       stb             s19Address+3
                              s19ga1:
 00FFEDF6 039                             rts
                                      
                              ; ------------------------------------------------------------------------------
                              ; Get an address composed of three bytes (36 bit)
                              ;
                              ; Side Effects:
                              ;               updates s19Address variable
                              ; Returns:
                              ;       none
                              ; ------------------------------------------------------------------------------
 
                              s19GetAddress3:
 00FFEDF7 08DFDB                          bsr             s19ClearAddress
 00FFEDF9 08DFA8                          bsr             s19GetByte
 00FFEDFB 08DF9C                          bsr             s19AddCheck
 00FFEDFD 0F7000941                       stb             s19Address+1
 00FFEE00 07D00094A                       tst             s19Abort
 00FFEE03 026013                          bne             s19ga2
 00FFEE05 08DF9C                          bsr             s19GetByte
 00FFEE07 08DF90                          bsr             s19AddCheck
 00FFEE09 0F7000942                       stb             s19Address+2
 00FFEE0C 07D00094A                       tst             s19Abort
 00FFEE0F 026007                          bne             s19ga2
 00FFEE11 08DF90                          bsr             s19GetByte
 00FFEE13 08DF84                          bsr             s19AddCheck
 00FFEE15 0F7000943                       stb             s19Address+3
                              s19ga2:
 00FFEE18 039                             rts
 
                              ; ------------------------------------------------------------------------------
                              ; Put a byte to memory.
                              ; ------------------------------------------------------------------------------
 
                              s19PutMem:
 00FFEE19 05F                             clrb                                                            ; accb = current byte count
                              s19pm3:
 00FFEE1A 034004                          pshs    b                                                       ; save byte count
 00FFEE1C 08DF85                          bsr             s19GetByte
 00FFEE1E 08DF79                          bsr             s19AddCheck
 00FFEE20 07D00094A                       tst             s19Abort
 00FFEE23 02601E                          bne             s19pm1
 00FFEE25 0150E790F000941                 stb             far [s19Address+1]      ; store the byte using far addressing
 00FFEE2A 07C000943                       inc             s19Address+3
 00FFEE2D 026008                          bne             s19pm2
 00FFEE2F 07C000942                       inc             s19Address+2
 00FFEE32 026003                          bne             s19pm2
 00FFEE34 07C000941                       inc             s19Address+1
                              s19pm2:
 00FFEE37 035004                          puls    b                                                       ; get back byte count
 00FFEE39 05C                             incb                                                            ; increment and
 00FFEE3A 0F1000949                       cmpb    s19Reclen                       ; compare to record length
 00FFEE3D 025FDB                          blo             s19pm3
 00FFEE3F 08DF62                          bsr             s19GetByte              ; get the checksum byte
 00FFEE41 020F56                          bra             s19AddCheck
                              s19pm1:
 00FFEE43 032601                          leas    1,s                                             ; faster than actual pull
 00FFEE45 08DF5C                          bsr             s19GetByte              ; get the checksum byte
 00FFEE47 020F50                          bra             s19AddCheck
 
                              ; ------------------------------------------------------------------------------
                              ; Processing for S1 record type.
                              ; ------------------------------------------------------------------------------
 
                              s19ProcessS1:
 00FFEE49 08DF96                          bsr             s19GetAddress2
 00FFEE4B 08DFCC                          bsr             s19PutMem
 00FFEE4D 07D00094B                       tst             s19Checksum
 00FFEE50 027008                          beq             s19p11
 00FFEE52 07C00094C                       inc             s19SummaryChecksum
 00FFEE55 0CCFFEF19                       ldd             #msgChecksumErr
 00FFEE58 03F                             swi
 00FFEE59 004                             fcb             MF_DisplayString
                              s19p11:
 00FFEE5A 020099                          bra             s19lnr
 
                              ; ------------------------------------------------------------------------------
                              ; Processing for S2 record type.
                              ; ------------------------------------------------------------------------------
 
                              s19ProcessS2:
 00FFEE5C 08DF99                          bsr             s19GetAddress3
 00FFEE5E 08DFB9                          bsr             s19PutMem
 00FFEE60 07D00094B                       tst             s19Checksum
 00FFEE63 027008                          beq             s19p21
 00FFEE65 07C00094C                       inc             s19SummaryChecksum
 00FFEE68 0CCFFEF19                       ldd             #msgChecksumErr
 00FFEE6B 03F                             swi
 00FFEE6C 004                             fcb             MF_DisplayString
                              s19p21:
 00FFEE6D 020086                          bra             s19lnr
 
                              ; S3,4,5,6 not processed
 
                              ; ------------------------------------------------------------------------------
                              ; Processing for S7 record type. Gets a two byte (24 bit) start address.
                              ; ------------------------------------------------------------------------------
 
                              s19ProcessS9:
 00FFEE6F 08DF70                          bsr             s19GetAddress2
 00FFEE71 0FC000942                       ldd             s19Address+2
 00FFEE74 0FD000946                       std             s19StartAddress+2
 00FFEE77 0FC000940                       ldd             s19Address+0
 00FFEE7A 0FD000944                       std             s19StartAddress+0
 00FFEE7D 020083                          bra             s19l2
                                      
                              ; ------------------------------------------------------------------------------
                              ; Processing for S8 record type. Gets a three byte (36 bit) start address.
                              ; ------------------------------------------------------------------------------
 
                              s19ProcessS8:
 00FFEE7F 08DF76                          bsr             s19GetAddress3
 00FFEE81 0FC000942                       ldd             s19Address+2
 00FFEE84 0FD000946                       std             s19StartAddress+2
 00FFEE87 0FC000940                       ldd             s19Address+0
 00FFEE8A 0FD000944                       std             s19StartAddress+0
 00FFEE8D 020073                          bra             s19l2
 
                              ; ------------------------------------------------------------------------------
                              ; S19 Loader
                              ;
                              ; Not all record types are processed. Some are skipped over.
                              ; ------------------------------------------------------------------------------
 
                              S19Loader:
 00FFEE8F 07F00094E                       clr             s19Source
 00FFEE92 0170006FC                       lbsr    GetNumber                               ; check for a file storage address
 00FFEE95 05D                             tstb
 00FFEE96 027009                          beq             s19l4                                           ; if not a memory file
 00FFEE98 07C00094E                       inc             s19Source                               ; set flag indicating a memory file
 00FFEE9B 0FC000912                       ldd             mon_numwka+2            ; set transfer address variable
 00FFEE9E 0FD000950                       std             s19XferAddress
                              s19l4:
 00FFEEA1 07F00094A                       clr             s19Abort                                ; clear the abort flag
 00FFEEA4 0CCFFEF05                       ldd             #msgS19Loader           ; signon banner
 00FFEEA7 03F                             swi
 00FFEEA8 004                             fcb             MF_DisplayString
 00FFEEA9 07F00094C                       clr             s19SummaryChecksum
                              s19l3:
 00FFEEAC 08DEB9                          bsr             s19InputChar            ; get a character from input
 00FFEEAE 0C101A                          cmpb    #CTRLZ                                  ; is it CTRL-Z?
 00FFEEB0 027050                          beq             s19l2
 00FFEEB2 07F00094B                       clr             s19Checksum
 00FFEEB5 0C1043                          cmpb    #'C'                                            ; records must start with the letter C
 00FFEEB7 02603C                          bne             s19lnr
 00FFEEB9 08DEAC                          bsr             s19InputChar            ; get the next character
 00FFEEBB 0C1030                          cmpb    #'0'                                            ; must be a numeric digit
 00FFEEBD 025036                          blo             s19lnr
 00FFEEBF 0C1039                          cmpb    #'9'
 00FFEEC1 022032                          bhi             s19lnr
 00FFEEC3 0F7000948                       stb             s19Rectype                      ; save off in record type
 00FFEEC6 08DEDB                          bsr             s19GetByte                      ; get a byte indicating record length
 00FFEEC8 08DECF                          bsr             s19AddCheck
 00FFEECA 0F7000949                       stb             s19Reclen
 00FFEECD 07D00094A                       tst             s19Abort                                ; check for abort
 00FFEED0 026030                          bne             s19l2
 00FFEED2 0F6000948                       ldb             s19Rectype                      ; process according to record type
 00FFEED5 0C1030                          cmpb    #'0'
 00FFEED7 02701C                          beq             s19lnr
 00FFEED9 0C1031                          cmpb    #'1'
 00FFEEDB 027F6C                          beq             s19ProcessS1            ; data record with a two byte address
 00FFEEDD 0C1032                          cmpb    #'2'
 00FFEEDF 027F7B                          beq             s19ProcessS2            ; data record with a three byte address
 00FFEEE1 0C1033                          cmpb    #'3'
 00FFEEE3 027010                          beq             s19lnr
 00FFEEE5 0C1035                          cmpb    #'5'                                            ; record count? ignore
 00FFEEE7 02700C                          beq             s19lnr
 00FFEEE9 0C1037                          cmpb    #'7'                                            ; ignore record with 48 bit address
 00FFEEEB 027015                          beq             s19l2
 00FFEEED 0C1038                          cmpb    #'8'
 00FFEEEF 027F8E                          beq             s19ProcessS8            ; two byte start address
 00FFEEF1 0C1039                          cmpb    #'9'
 00FFEEF3 027F7A                          beq             s19ProcessS9            ; three byte start address
                              s19lnr:
 00FFEEF5 0C602E                          ldb             #'.'                                            ; output a progress indicator
 00FFEEF7 03F                             swi
 00FFEEF8 002                             fcb             MF_OUTCH
 00FFEEF9 08DE84                          bsr             s19NextRecord           ; skip to the next record
 00FFEEFB 07D00094A                       tst             S19Abort                                ; check for abort
 00FFEEFE 026002                          bne             s19l2
 00FFEF00 020FAA                          bra             s19l3                                           ; loop back to process more records
                              s19l2:
 00FFEF02 016000457                       lbra    Monitor
 
                              msgS19Loader:
 00FFEF05 05303103902004C06F061           fcb     "S19 Loader Active",CR,LF,0
 00FFEF0C 064065072020041063074
 00FFEF13 06907606500D00A000
                              msgChecksumErr:
 00FFEF19 053031039020043068065           fcb     "S19 Checksum Err",CR,LF,0
 00FFEF20 06306B07307506D020045
 00FFEF27 07207200D00A000
 
                                      
                              ; ============================================================================
                              ;        __
                              ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                              ;    \  __ /    All rights reserved.
                              ;     \/_//     robfinch<remove>@opencores.org
                              ;       ||
                              ;  
                              ;
                              ; BSD 3-Clause License
                              ; Redistribution and use in source and binary forms, with or without
                              ; modification, are permitted provided that the following conditions are met:
                              ;
                              ; 1. Redistributions of source code must retain the above copyright notice, this
                              ;    list of conditions and the following disclaimer.
                              ;
                              ; 2. Redistributions in binary form must reproduce the above copyright notice,
                              ;    this list of conditions and the following disclaimer in the documentation
                              ;    and/or other materials provided with the distribution.
                              ;
                              ; 3. Neither the name of the copyright holder nor the names of its
                              ;    contributors may be used to endorse or promote products derived from
                              ;    this software without specific prior written permission.
                              ;
                              ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                              ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                              ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                              ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                              ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                              ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                              ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                              ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                              ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                              ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                              ;                                                                          
                              ; ============================================================================
                              ;
                              ; Xmodem variables
                              ;
                              xm_timer                                EQU             $FFC020
                              xm_protocol                     EQU             $9F5
                              xm_flag                                 EQU             $9F6
                              xm_checksum                     EQU             $9F7
                              xm_tmp2                                 EQU             $9F8
                              xm_packetnum            EQU             $9FA
                              xm_tmp                                  EQU             $9FC
                              xm_crc                                  EQU             $9FE
                              xm_ibuf                                 EQU             $A00    ; to $A7F
                              xm_obuf                                 EQU             $A80    ; to $AFF
 
                              ; ------------------------------------------------------------------------------
                              ; Send data using XModem.
                              ; ------------------------------------------------------------------------------
 
                              xm_SendStart:
 00FFEF2C 0170005A3                       lbsr    GetRange
 00FFEF2F 0BE000922                       ldx             mon_r1+2                                ; x = buffer address
 00FFEF32 01F013                          tfr             x,u
 00FFEF34 0C6001                          ldb             #1                                                      ; packet numbers start at one
 00FFEF36 0F70009FB                       stb             xm_packetnum+1
                                      ; Wait for receiver to send a NAK
                              xm_send:                                                        
 00FFEF39 0CCFFFFFF                       ldd             #-1                                                     ; select blocking input
 00FFEF3C 03F                             swi
 00FFEF3D 001                             fcb             MF_INCH
 00FFEF3E 0C1015                          cmpb    #NAK                                            ; should have got a NAK
 00FFEF40 027004                          beq             xm_send5
 00FFEF42 0C1043                          cmpb    #'C'                                            ; or a 'C'
 00FFEF44 026FF3                          bne             xm_send
                              xm_send5:
 00FFEF46 0F70009F5                       stb             xm_protocol
                              xm_send4:
 00FFEF49 0C6001                          ldb             #SOH                                            ; send start
 00FFEF4B 03F                             swi
 00FFEF4C 1C9                             fcb             OUTCH                   
 00FFEF4D 0F60009FB                       ldb             xm_packetnum+1  ; send packet number
 00FFEF50 03F                             swi
 00FFEF51 002                             fcb             MF_OUTCH
 00FFEF52 053                             comb                                                                    ; one's complement
 00FFEF53 03F                             swi
 00FFEF54 002                             fcb             MF_OUTCH                                ; send packet number complement
 00FFEF55 04F                             clra                                                                    ; acca = byte count
 00FFEF56 01F013                          tfr             x,u                                                     ; u = buffer address
                              xm_send1:
 00FFEF58 0E6C00                          ldb             ,u+                                                     ; grab a byte from the buffer
 00FFEF5A 03F                             swi
 00FFEF5B 002                             fcb             MF_OUTCH                                ; send it out
 00FFEF5C 04C                             inca
 00FFEF5D 081080                          cmpa    #128                                            ; number of bytes in payload
 00FFEF5F 025FF7                          blo             xm_send1
 00FFEF61 0F60009F5                       ldb             xm_protocol
 00FFEF64 0C1043                          cmpb    #'C'                                            ; CRC protocol?
 00FFEF66 02601E                          bne             xm_send2
 00FFEF68 08D17F                          bsr             xm_calc_crc                     ; compute CRC
 00FFEF6A 0FC0009FE                       ldd             xm_crc                                  ; get crc
 00FFEF6D 044                             lsra                                                                    ; transfer high eight bits first, so
 00FFEF6E 056                             rorb                                                                    ; right shift D by eight
 00FFEF6F 044                             lsra
 00FFEF70 056                             rorb
 00FFEF71 044                             lsra
 00FFEF72 056                             rorb
 00FFEF73 044                             lsra
 00FFEF74 056                             rorb
 00FFEF75 044                             lsra
 00FFEF76 056                             rorb
 00FFEF77 044                             lsra
 00FFEF78 056                             rorb
 00FFEF79 044                             lsra
 00FFEF7A 056                             rorb
 00FFEF7B 044                             lsra
 00FFEF7C 056                             rorb
 00FFEF7D 03F                             swi
 00FFEF7E 002                             fcb             MF_OUTCH                                ; send out the byte
 00FFEF7F 0FC0009FE                       ldd             xm_crc                                  ; get back CRC
 00FFEF82 03F                             swi                                                                     
 00FFEF83 002                             fcb             MF_OUTCH                                ; and send out low byte
 00FFEF84 020007                          bra             xm_send3
                              xm_send2:
 00FFEF86 08D14F                          bsr             xm_calc_checksum
 00FFEF88 0F60009F7                       ldb             xm_checksum
 00FFEF8B 03F                             swi
 00FFEF8C 002                             fcb             MF_OUTCH
                              xm_send3:
 00FFEF8D 03F                             swi
 00FFEF8E 0CCFFFFFF                       ldd             #-1                                                     ; block until input is present
 00FFEF91 001                             fcb             MF_INCH
 00FFEF92 0C1006                          cmpb    #ACK
 00FFEF94 026FB3                          bne             xm_send4                                ; not an ACK then resend the record
 00FFEF96 07C0009FA                       inc             xm_packetnum            ; increment packet number
 00FFEF99 030080                          leax    128,x                                           ; advance buffer pointer
 00FFEF9B 0BC000926                       cmpx    mon_r2+2
 00FFEF9E 025FA9                          blo             xm_send4                                ; go send next record
 00FFEFA0 0C6004                          ldb             #EOT                                            ; send end of transmission
 00FFEFA2 03F                             swi
 00FFEFA3 002                             fcb             MF_OUTCH
 00FFEFA4 03F                             swi
 00FFEFA5 002                             fcb             MF_OUTCH
 00FFEFA6 03F                             swi
 00FFEFA7 002                             fcb             MF_OUTCH
 00FFEFA8 039                             rts
 
                              ; ------------------------------------------------------------------------------
                              ; Get a byte, checking for a receive timeout.
                              ;
                              ; Returns:
                              ;               accb = byte (0 to 255) or -1 if timed out
                              ; ------------------------------------------------------------------------------
 
                              xm_getbyte:
                              xm_gb1:
 00FFEFA9 07DFFC020                       tst             xm_timer                ; check the timeout - 2048 ticks (3 seconds approx.)
 00FFEFAC 02B009                          bmi             xm_gb2
 00FFEFAE 04F                             clra                                                    ; non-blocking
 00FFEFAF 05F                             clrb
 00FFEFB0 03F                             swi     
 00FFEFB1 001                             fcb             MF_INCH                 ; try and get a character
 00FFEFB2 02BFF5                          bmi             xm_gb1                  ; if no character, try again
 00FFEFB4 08D1BA                          bsr             xm_outbyteAsHex
 00FFEFB6 039                             rts
                              xm_gb2:
 00FFEFB7 0C6FFF                          ldb             #-1
 00FFEFB9 039                             rts
 
                              ; ------------------------------------------------------------------------------
                              ; XModem Receive
                              ;
                              ; Parameters:
                              ;               none
                              ; Modifies:
                              ;               All
                              ;       Returns:
                              ;               none
                              ; ------------------------------------------------------------------------------
 
                              xm_ReceiveStart:
 00FFEFBA 017FFF1FB                       lbsr    Delay3s                         ; give a little bit of time for sender
*** warning 1: Long branch within short branch range could be optimized
 00FFEFBD 017FFF1F8                       lbsr    Delay3s
*** warning 1: Long branch within short branch range could be optimized
 00FFEFC0 017FFF1F5                       lbsr    Delay3s
*** warning 1: Long branch within short branch range could be optimized
 00FFEFC3 0170005CB                       lbsr    GetNumber                       ; Get the transfer address
 00FFEFC6 05D                             tstb                                                            ; Make sure we got a value
 00FFEFC7 127000392                       lbeq    Monitor
 00FFEFCA 0BE000912                       ldx             mon_numwka+2    ; X = transfer address
 00FFEFCD 07F0009FA                       clr             xm_packetnum    ; initialize
 00FFEFD0 086043                          lda             #'C'                                    ; try for CRC first
 00FFEFD2 0B70009F5                       sta             xm_protocol
                              xm_receive:
 00FFEFD5 086002                          lda             #2                                              ; number of times to retry -1
                              xm_rcv5:
 00FFEFD7 0F60009F5                       ldb             xm_protocol             ; indicate we want a transfer (send protocol byte)
 00FFEFDA 03F                             swi
 00FFEFDB 00D                             fcb             MF_SerialPutchar
                              xm_rcv4:
 00FFEFDC 07FFFC020                       clr             xm_timer                ; clear the timeout
                              xm_rcv1:
 00FFEFDF 08DFC8                          bsr             xm_getbyte
 00FFEFE1 05D                             tstb
 00FFEFE2 02B0A1                          bmi             xm_retry1               ; timeout on protocol id?
 00FFEFE4 0C1001                          cmpb    #SOH                            ; it should be start of a transfer
 00FFEFE6 027012                          beq             xm_SOH
 00FFEFE8 0C1004                          cmpb    #EOT
 00FFEFEA 027092                          beq             xm_EOT                  ; or end of transfer (EOT)
 00FFEFEC 0C1018                          cmpb    #CAN
 00FFEFEE 027FE5                          beq             xm_receive      ; might be a cancel
 00FFEFF0 0C1017                          cmpb    #ETB
 00FFEFF2 02708A                          beq             xm_EOT
                              xm_rcv_nak:                                     ; wasn't a valid start so
 00FFEFF4 0C6015                          ldb             #NAK                            ; send a NAK
 00FFEFF6 03F                             swi
 00FFEFF7 00D                             fcb             MF_SerialPutchar        ; and try again
 00FFEFF8 020FE2                          bra             xm_rcv4
                              xm_SOH:
 00FFEFFA 08DFAD                          bsr             xm_getbyte      ; get packet number
 00FFEFFC 02B078                          bmi             xm_rcv_to1
 00FFEFFE 0F70009FB                       stb             xm_packetnum+1
 00FFF001 034004                          pshs    b                                               ; save it
 00FFF003 08DFA4                          bsr             xm_getbyte      ; get complement of packet number
 00FFF005 02B06D                          bmi             xm_rcv_to2
 00FFF007 0EBE04                          addb    ,s                                      ; add the two values
 00FFF009 0C40FF                          andb    #$FF                            ; the sum should be $FF
 00FFF00B 0C00FF                          subb    #$FF
 00FFF00D 0F70009F6                       stb             xm_flag                 ; should be storing a zero if there is no error
 00FFF010 18E000000                       ldy             #0                                      ; y = payload byte counter
 00FFF013 01F013                          tfr             x,u
                              xm_rcv2:
 00FFF015 08DF92                          bsr             xm_getbyte
 00FFF017 02B05D                          bmi             xm_rcv_to1
 00FFF019 0E7C00                          stb             ,u+                                     ; store the byte to memory
 00FFF01B 031201                          iny
 00FFF01D 18C000080                       cmpy    #128                            ; 128 bytes per payload
 00FFF020 025FF3                          blo             xm_rcv2
 00FFF022 08DF85                          bsr             xm_getbyte      ; get checksum or CRC byte
 00FFF024 02B050                          bmi             xm_rcv_to1
 00FFF026 0F70009FC                       stb             xm_tmp                  ; stuff checksum/CRC byte
 00FFF029 0F60009F5                       ldb             xm_protocol
 00FFF02C 0C1043                          cmpb    #'C'
 00FFF02E 026022                          bne             xm_rcv_chksum
 00FFF030 08DF77                          bsr             xm_getbyte      ; get low order CRC byte
 00FFF032 02B042                          bmi             xm_rcv_to1
 00FFF034 0B60009FC                       lda             xm_tmp                  ; get the high byte
 00FFF037 058                             aslb                                                    ; prepare to combine high and low order
 00FFF038 058                             aslb
 00FFF039 058                             aslb
 00FFF03A 058                             aslb
 00FFF03B 044                             lsra                                                    ; shift low nybble of acca into accb
 00FFF03C 056                             rorb
 00FFF03D 044                             lsra
 00FFF03E 056                             rorb
 00FFF03F 044                             lsra
 00FFF040 056                             rorb
 00FFF041 044                             lsra
 00FFF042 056                             rorb
 00FFF043 08400F                          anda    #$00F                                   ; mask off any extra bits
 00FFF045 0FD0009F8                       std     xm_tmp2
 00FFF048 08D09F                          bsr             xm_calc_crc             ; compute the CRC-16 for the received data
 00FFF04A 0FC0009FE                       ldd             xm_crc                          ; and compare to received value
 00FFF04D 1B30009F8                       cmpd    xm_tmp2
 00FFF050 020008                          bra             xm_rcv3
                              xm_rcv_chksum:
 00FFF052 08D083                          bsr             xm_calc_checksum
 00FFF054 0F60009F7                       ldb             xm_checksum
 00FFF057 0F10009FC                       cmpb    xm_tmp                          ; where we stuffed the byte
                              xm_rcv3:
 00FFF05A 026F98                          bne             xm_rcv_nak              ; if not the same, NAK
 00FFF05C 07D0009F6                       tst             xm_flag
 00FFF05F 026F93                          bne             xm_rcv_nak              ; bad packet number?
 00FFF061 0C6006                          ldb             #ACK                                    ; packet recieved okay, send back an ACK
 00FFF063 03F                             swi
 00FFF064 00D                             fcb             MF_SerialPutchar
 00FFF065 0F60009FB                       ldb             xm_packetnum+1  ; did we receive the same packet
 00FFF068 0F10009FA                       cmpb    xm_packetnum
 00FFF06B 027F6F                          beq             xm_rcv4                         ; same packet received, dont update buffer pointer
 00FFF06D 0F70009FA                       stb             xm_packetnum    ; update last seen packet number
 00FFF070 030080                          leax    128,x                                   ; increment buffer pointer
 00FFF072 020F68                          bra             xm_rcv4                         ; and go back for next packet
                              xm_rcv_to2:
 00FFF074 032601                          leas    1,s                                             ; get rid of stacked byte
                              xm_rcv_to1:
 00FFF076 0CCFFF09E                       ldd             #msgXmTimeout
 00FFF079 03F                             swi
 00FFF07A 004                             fcb             MF_DisplayString
 00FFF07B 0160002DE                       lbra    Monitor
                              xm_EOT:                                                         ; end of transmission received, return
 00FFF07E 0C6006                          ldb             #ACK                                    ; ACK the EOT
 00FFF080 03F                             swi
 00FFF081 00D                             fcb             MF_SerialPutchar
 00FFF082 0160002D7                       lbra    Monitor
                              xm_retry1:
 00FFF085 04A                             deca
 00FFF086 02AF4F                          bpl             xm_rcv5
 00FFF088 0B60009F5                       lda             xm_protocol
 00FFF08B 081015                          cmpa    #NAK                                    ; are we already lowered down to checksum protocol?
 00FFF08D 027007                          beq             xm_noTransmitter        ; did we try both checksum and CRC?
 00FFF08F 086015                          lda             #NAK
 00FFF091 0B70009F5                       sta             xm_protocol
 00FFF094 020F3F                          bra             xm_receive
                              xm_noTransmitter:
 00FFF096 0CCFFF0B2                       ldd             #msgXmNoTransmitter
 00FFF099 03F                             swi
 00FFF09A 004                             fcb             MF_DisplayString
 00FFF09B 0160002BE                       lbra    Monitor 
 
                              msgXmTimeout:
 00FFF09E 05806D06F06406506D03A           fcb             "Xmodem: timed out",CR,LF,0
 00FFF0A5 02007406906D065064020
 00FFF0AC 06F07507400D00A000
                              msgXmNoTransmitter:
 00FFF0B2 05804D06F06406506D03A           fcb             "XModem: transmitter not responding",CR,LF,0
 00FFF0B9 02007407206106E07306D
 00FFF0C0 06907407406507202006E
 00FFF0C7 06F074020072065073070
 00FFF0CE 06F06E06406906E06700D
 00FFF0D5 00A000
 
                              ; ------------------------------------------------------------------------------
                              ; Calculate checksum value. The checksum is simply the low order eight bits of
                              ; the sum of all the bytes in the payload area.
                              ;
                              ; Stack space:
                              ;               two words
                              ;       Modifies:
                              ;               xm_checksum             contains the checksum value for the record
                              ; Parameters:
                              ;               X = buffer address
                              ;       Returns:
                              ;               none
                              ; ------------------------------------------------------------------------------
 
                              xm_calc_checksum:
 00FFF0D7 034016                          pshs    d,x
 00FFF0D9 04F                             clra
 00FFF0DA 05F                             clrb
                              xm_cs1:
 00FFF0DB 0EB800                          addb    ,x+
 00FFF0DD 04C                             inca
 00FFF0DE 081080                          cmpa    #128
 00FFF0E0 025FF9                          blo             xm_cs1
 00FFF0E2 0C40FF                          andb    #$FF
 00FFF0E4 0F70009F7                       stb             xm_checksum
 00FFF0E7 035096                          puls    d,x,pc
 
                              ; ------------------------------------------------------------------------------
                              ; Compute CRC-16 of buffer.
                              ;
                              ;int calcrc(char *ptr, int count)
                              ;{
                              ;    int  crc;
                              ;    char i;
                              ;    crc = 0;
                              ;    while (--count >= 0)
                              ;    {
                              ;        crc = crc ^ (int) (*ptr++ << 8);
                              ;        i = 8;
                              ;        do
                              ;        {
                              ;            if (crc & 0x8000)
                              ;                crc = crc << 1 ^ 0x1021;
                              ;            else
                              ;                crc = crc << 1;
                              ;        } while(--i);
                              ;    }
                              ;    return (crc);
                              ;}
                              ;
                              ; Modifies:
                              ;               xm_crc variable
                              ; Parameters:
                              ;               u = buffer address
                              ; Returns:
                              ;               none
                              ; ------------------------------------------------------------------------------
 
                              xm_calc_crc:
 00FFF0E9 034076                          pshs    d,x,y,u
 00FFF0EB 07F0009FE                       clr             xm_crc
 00FFF0EE 07F0009FF                       clr             xm_crc+1        
 00FFF0F1 0CE000000                       ldu             #0                                      ; u = byte count
                              xm_crc1:
 00FFF0F4 0E6800                          ldb             ,x+                                     ; get byte
 00FFF0F6 07F0009FC                       clr             xm_tmp                  ; save in temp
 00FFF0F9 0F70009FD                       stb             xm_tmp+1
 00FFF0FC 0780009FD                       asl             xm_tmp+1                ; shift temp eight bits to left         
 00FFF0FF 0790009FC                       rol             xm_tmp
 00FFF102 0780009FD                       asl             xm_tmp+1
 00FFF105 0790009FC                       rol             xm_tmp
 00FFF108 0780009FD                       asl             xm_tmp+1
 00FFF10B 0790009FC                       rol             xm_tmp
 00FFF10E 0780009FD                       asl             xm_tmp+1
 00FFF111 0790009FC                       rol             xm_tmp
 00FFF114 0780009FD                       asl             xm_tmp+1
 00FFF117 0790009FC                       rol             xm_tmp
 00FFF11A 0780009FD                       asl             xm_tmp+1
 00FFF11D 0790009FC                       rol             xm_tmp
 00FFF120 0780009FD                       asl             xm_tmp+1
 00FFF123 0790009FC                       rol             xm_tmp
 00FFF126 0780009FD                       asl             xm_tmp+1
 00FFF129 0790009FC                       rol             xm_tmp
 00FFF12C 0FC0009FE                       ldd             xm_crc          ; crc = crc ^ tmp
 00FFF12F 0B80009FC                       eora    xm_tmp
 00FFF132 0F80009FD                       eorb    xm_tmp+1
 00FFF135 0FD0009FE                       std             xm_crc
 00FFF138 18E000000                       ldy             #0
                              xm_crc4:
 00FFF13B 0F60009FE                       ldb             xm_crc          ; get high byte
 00FFF13E 0C5008                          bitb    #$8                             ; check for $8000
 00FFF140 02700E                          beq             xm_crc2         ; no? then just go shift
 00FFF142 0FC0009FE                       ldd             xm_crc          ; load
 00FFF145 058                             aslb                                            ; shift
 00FFF146 049                             rola
 00FFF147 0C8021                          eorb    #$021                   ; and xor
 00FFF149 088001                          eora    #$001
 00FFF14B 0FD0009FE                       std             xm_crc          ; store it back
 00FFF14E 020008                          bra             xm_crc3
                              xm_crc2:
 00FFF150 0FC0009FE                       ldd             xm_crc          ; load
 00FFF153 058                             aslb                                            ; shift
 00FFF154 049                             rola
 00FFF155 0FD0009FE                       std             xm_crc          ; and store
                              xm_crc3:
 00FFF158 031201                          iny
 00FFF15A 18C000008                       cmpy    #8                              ; repeat eight times
 00FFF15D 025FDC                          blo             xm_crc4
 00FFF15F 033401                          leau    1,u                             ; increment byte count
 00FFF161 283000080                       cmpu    #128
 00FFF164 0FC0009FE                       ldd             xm_crc          ; we want only a 16-bit CRC
 00FFF167 08400F                          anda    #$0F
 00FFF169 0FD0009FE                       std             xm_crc
 00FFF16C 025F86                          blo             xm_crc1
 00FFF16E 0350F6                          puls    d,x,y,u,pc
 
                              xm_outbyteAsHex:
 00FFF170 034006                          pshs    d
 00FFF172 0FC000800                       ldd             CharOutVec                                              ; get current char out vector
 00FFF175 034006                          pshs    d                                                                                       ; save it
 00FFF177 0CCFFE31F                       ldd             #ScreenDisplayChar              ; set output vector to screen display
 00FFF17A 0FD000800                       std             CharOUtVec
 00FFF17D 0EC602                          ldd             2,s                                                                             ; get passed data
 00FFF17F 017FFF2B8                       lbsr    DispByteAsHex                                   ; and display on-screen
*** warning 1: Long branch within short branch range could be optimized
 00FFF182 0C6020                          ldb             #' '
 00FFF184 017FFF198                       lbsr    ScreenDisplayChar
*** warning 1: Long branch within short branch range could be optimized
 00FFF187 035006                          puls    d                                                                                       ; get back old char out vector
 00FFF189 0FD000800                       std             CharOutVec                                              ; and restore it
 00FFF18C 035006                          puls    d                                                                                       ; restore input arguments
 00FFF18E 039                             rts
 
                                      
 
                              ;------------------------------------------------------------------------------
                              ; Check if there is a keyboard character available. If so return true (<0)
                              ; otherwise return false (0) in accb.
                              ;------------------------------------------------------------------------------
                              ;
                              KeybdCheckForKeyDirect:
 00FFF18F 0208FF                          bra             DBGCheckForKey
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              INCH:
 00FFF191 034004                          pshs    b
                              INCH2:
 00FFF193 0150F6FFFFFFFE0                 ldb             COREID
 00FFF198 0F1FFC010                       cmpb    IOFocusID       ; if we do not have focus, block
 00FFF19B 026FF6                          bne             INCH2                   
                              ;       ldb             #$800                   ; block if no key available, get scancode directly
                              ;       bra             GetKey
                              ;       jsr             [CharInVec]     ; vector is being overwritten somehow
 00FFF19D 017FFFAD3                       lbsr    SerialPeekCharDirect
*** warning 1: Long branch within short branch range could be optimized
                              ;       lbsr    SerialGetChar
 00FFF1A0 04D                             tsta
 00FFF1A1 02B003                          bmi             INCH1                   ; block if no key available
 00FFF1A3 032601                          leas    1,s                             ; get rid of blocking status
 00FFF1A5 039                             rts                                                     ; return character
                              INCH1:
 00FFF1A6 035004                          puls    b                                       ; check blocking status
 00FFF1A8 05D                             tstb
 00FFF1A9 02BFE6                          bmi     INCH                    ; if blocking, loop
 00FFF1AB 0CCFFFFFF                       ldd             #-1                             ; return -1 if no char available
 00FFF1AE 039                             rts
 
                              INCHE:
 00FFF1AF 08DFE0                          bsr             INCH
 00FFF1B1 020009                          bra             INCHEK3
 
                              INCHEK:
 00FFF1B3 08DFDC                          bsr             INCH
 00FFF1B5 01507DFFFFFCA00                 tst             KeybdEcho
 00FFF1BA 02700C                          beq             INCHEK1
                              INCHEK3:
 00FFF1BC 08100D                          cmpa    #CR
 00FFF1BE 026005                          bne             INCHEK2
 00FFF1C0 017FFDF0F                       lbsr            CRLF
*** warning 1: Long branch within short branch range could be optimized
 00FFF1C3 020003                          bra             INCHEK1
                              INCHEK2:
 00FFF1C5 017FFF154                       lbsr    DisplayChar
*** warning 1: Long branch within short branch range could be optimized
                              INCHEK1:
 00FFF1C8 039                             rts
 
                              OUTCH:
 00FFF1C9 06E90F000800                    jmp             [CharOutVec]
 
                              ;------------------------------------------------------------------------------
                              ; r1 0=echo off, non-zero = echo on
                              ;------------------------------------------------------------------------------
                              ;
                              SetKeyboardEcho:
 00FFF1CD 0150F7FFFFFCA00                 stb             KeybdEcho
 00FFF1D2 039                             rts
 
 
                              ;------------------------------------------------------------------------------
                              ; Parameters:
                              ;               x,d     bitmap of sprites to enable
                              ;------------------------------------------------------------------------------
 
                              ShowSprites:
 00FFF1D3 0150BFFFFE103C0                 stx             SPRITE_CTRL+SPRITE_EN
 00FFF1D8 0150FDFFFE103C2                 std             SPRITE_CTRL+SPRITE_EN+2
 00FFF1DD 039                             rts
 
                              ;==============================================================================
                              ; Femtiki Operating System.
                              ;==============================================================================
 
                              OSCallTbl:
 00FFF1DE 000000                          fcw             0
 00FFF1E0 000000                          fcw             0
 00FFF1E2 000000                          fcw             0
 00FFF1E4 000000                          fcw             0
 00FFF1E6 000000                          fcw             0
 00FFF1E8 000000                          fcw             0
 00FFF1EA 000000                          fcw             0
 00FFF1EC 000000                          fcw             0
 00FFF1EE 000000                          fcw             0
 00FFF1F0 000000                          fcw             0
 00FFF1F2 000000                          fcw             0
 00FFF1F4 000000                          fcw             0
 00FFF1F6 000000                          fcw             0
 00FFF1F8 000000                          fcw             0
 00FFF1FA 000000                          fcw             0
 00FFF1FC 000000                          fcw             0
 00FFF1FE 000000                          fcw             0
 00FFF200 000000                          fcw             0
 00FFF202 000000                          fcw             0
 00FFF204 000000                          fcw             0
 00FFF206 000000                          fcw             0
 00FFF208 000000                          fcw             0
 00FFF20A FFF227                          fcw             ReleaseIOFocus
 00FFF20C 000000                          fcw             0
 00FFF20E FFF210                          fcw             RequestIOFocus
 
                              NumOSFuncs      EQU     (*-OSCallTbl)/2
 
                              RequestIOFocus:
 00FFF210 0150F6FFFFFFFE0                 ldb             COREID
 00FFF215 08EFFC000                       ldx             #IOFocusList
 00FFF218 03A                             abx
 00FFF219 0A7804                          sta             ,x
 00FFF21B 07DFFC010                       tst             IOFocusID
 00FFF21E 1260008DC                       lbne    oscx
 00FFF221 0F7FFC010                       stb             IOFocusID
 00FFF224 0160008D6                       lbra    oscx
 
                              ReleaseIOFocus:
 00FFF227 0150F6FFFFFFFE0                 ldb             COREID
 00FFF22C 08EFFC000                       ldx             #IOFocusList
 00FFF22F 03A                             abx
 00FFF230 06F804                          clr             ,x                                              ; clear the request indicator
 00FFF232 017FFEFD7                       lbsr    CopyScreenToVirtualScreen
*** warning 1: Long branch within short branch range could be optimized
 00FFF235 0F1FFC010                       cmpb    IOFocusID                       ; are we the one with the focus?
 00FFF238 1260008C2                       lbne    oscx
                                      ; We had the focus, so now a new core needs the focus.
                                      ; Search the focus list for a requestor. If no requester
                                      ; is found, give focus to core #1.
 00FFF23B 08600F                          lda             #15
                              riof2:
 00FFF23D 05C                             incb
 00FFF23E 0C400F                          andb    #15
 00FFF240 03A                             abx
 00FFF241 06D804                          tst             ,x
 00FFF243 026009                          bne             riof1
 00FFF245 04A                             deca
 00FFF246 026FF5                          bne             riof2
                                      ; If no focus is requested by anyone, give to core #1
 00FFF248 0C6001                          ldb             #1
 00FFF24A 086018                          lda             #24
 00FFF24C 0A7804                          sta             ,x
                              riof1:
 00FFF24E 0F7FFC010                       stb             IOFocusID
 00FFF251 017FFEF81                       lbsr    CopyVirtualScreenToScreen
*** warning 1: Long branch within short branch range could be optimized
 00FFF254 0160008A6                       lbra    oscx
                                              
                                      
                              ;==============================================================================
                              ;==============================================================================
 
                              ;------------------------------------------------------------------------------
                              ; Seed the random number generator. All channels are seeded with the same
                              ; value.
                              ;
                              ; Parameters:
                              ;               d = 'z' part of seed
                              ;               x = 'w' part of seed
                              ; Returns:
                              ;               none
                              ;------------------------------------------------------------------------------
 
                              mon_srand:
 00FFF257 18E000000                       ldy     #0
                              mon_srand1:
 00FFF25A 0151BFFFFE30604                 sty     PRNG+4                          ; select channel
 00FFF25F 01507FFFFE30608                 clr     PRNG+8
 00FFF264 01507FFFFE30609                 clr PRNG+9
 00FFF269 0150FDFFFE3060A                 std     PRNG+10                         ; update low half of value
 00FFF26E 01507FFFFE3060C                 clr PRNG+12
 00FFF273 01507FFFFE3060D                 clr PRNG+13
 00FFF278 0150BFFFFE3060E                 stx     PRNG+14                         ; update low half of value
 00FFF27D 031201                          iny
 00FFF27F 18C000400                       cmpy    #$400                           ; 1k channels
 00FFF282 025FD6                          blo             mon_srand1
 00FFF284 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Get a random number and generate the next one.
                              ;
                              ; Parameters:
                              ;               d = channel to use
                              ; Returns:
                              ;               x,d = 36 bit random value
                              ;------------------------------------------------------------------------------
 
                              mon_rand:
 00FFF285 0150FDFFFE30604                 std     PRNG+4                          ; select channel
 00FFF28A 0150BEFFFE30600                 ldx     PRNG+0
 00FFF28F 0150FCFFFE30602                 ldd     PRNG+2
 00FFF294 0150F7FFFE30603                 stb     PRNG+3                          ; trigger calc of next number
 00FFF299 039                             rts
 
                              ;==============================================================================
                              ; System Monitor
                              ;==============================================================================
 
                              ; Command Tables
 
                              cmdTable1:
 00FFF29A 03C83E                          fcb             '<','>'+$800
 00FFF29C 04282B                          fcb             'B','+'+$800
 00FFF29E 04282D                          fcb             'B','-'+$800
 00FFF2A0 044852                          fcb             'D','R'+$800
 00FFF2A2 844                             fcb             'D'+$800
 00FFF2A3 83A                             fcb             ':'+$800
 00FFF2A4 046049847                       fcb             "FI",'G'+$800
 00FFF2A7 04604984C                       fcb             "FI",'L'+$800
 00FFF2AA 04684C                          fcb             'F','L'+$800
 00FFF2AC 84A                             fcb             'J'+$800
 00FFF2AD 05204104D054045053854           fcb             "RAMTES",'T'+$800
 00FFF2B4 053050844                       fcb             "SP",'D'+$800
 00FFF2B7 054049852                       fcb             "TI",'R'+$800
 00FFF2BA 855                             fcb             'U'+$800
 00FFF2BB 065078069874                    fcb             "exi",'t'+$800
 00FFF2BF 83F                             fcb             '?'+$800
 00FFF2C0 04304C853                       fcb             "CL",'S'+$800
 00FFF2C3 053031839                       fcb             "S1",'9'+$800
 00FFF2C6 04A044834                       fcb             "JD",'4'+$800
 00FFF2C9 05804D852                       fcb             "XM",'R'+$800
 00FFF2CC 05804D853                       fcb             "XM",'S'+$800
 00FFF2CF 052841                          fcb             'R','A'+$800
 00FFF2D1 052842                          fcb             'R','B'+$800
 00FFF2D3 052044050852                    fcb             "RDP",'R'+$800
 00FFF2D7 052844                          fcb             'R','D'+$800
 00FFF2D9 052858                          fcb             'R','X'+$800
 00FFF2DB 052859                          fcb             'R','Y'+$800
 00FFF2DD 052855                          fcb             'R','U'+$800
 00FFF2DF 052853                          fcb             'R','S'+$800
 00FFF2E1 052043043852                    fcb             "RCC",'R'+$800
 00FFF2E5 052050843                       fcb             "RP",'C'+$800
 00FFF2E8 04C842                          fcb             'L','B'+$800
 00FFF2EA 000000                          fcw             0
 
                              cmdTable2:
 00FFF2EC FFF427                          fcw             Redirect
 00FFF2EE FFF469                          fcw             MonArmBreakpoint
 00FFF2F0 FFF474                          fcw             MonDisarmBreakpoint
 00FFF2F2 FFF899                          fcw             DumpRegs
 00FFF2F4 FFF7D0                          fcw             DumpMemory
 00FFF2F6 FFF82C                          fcw             EditMemory
 00FFF2F8 FE0000                          fcw             $FE0000                                 ; FIG forth
 00FFF2FA FFF86F                          fcw             FillMemory
 00FFF2FC FFF9F5                          fcw             DumpIOFocusList
 00FFF2FE FFF980                          fcw             jump_to_code
 00FFF300 FFD400                          fcw             $FFD400
 00FFF302 FF8000                          fcw             $FF8000                                 ; sprite demo
 00FFF304 FFE524                          fcw             rtc_read
 00FFF306 FF8003                          fcw             $FF8003                                 ; unassembler
 00FFF308 FFFAE6                          fcw             xitMonitor
 00FFF30A FFF44D                          fcw             PromptHelp
 00FFF30C FFF455                          fcw             PromptClearscreen
 00FFF30E FFEE8F                          fcw             S19Loader
 00FFF310 FFD400                          fcw             $FFD400
 00FFF312 FFEFBA                          fcw             xm_ReceiveStart
 00FFF314 FFEF2C                          fcw             xm_SendStart
 00FFF316 FFF8E4                          fcw             SetRegA
 00FFF318 FFF8F3                          fcw             SetRegB
 00FFF31A FFF94D                          fcw             SetRegDPR
 00FFF31C FFF902                          fcw             SetRegD
 00FFF31E FFF911                          fcw             SetRegX
 00FFF320 FFF920                          fcw             SetRegY
 00FFF322 FFF92F                          fcw             SetRegU
 00FFF324 FFF93E                          fcw             SetRegS
 00FFF326 FFF95C                          fcw             SetRegCCR
 00FFF328 FFF96B                          fcw             SetRegPC
 00FFF32A FFFBD2                          fcw             ListBreakpoints
 
                              CmdPrompt:
 00FFF32C 017FFDDA3                       lbsr    CRLF
*** warning 1: Long branch within short branch range could be optimized
 00FFF32F 0C6024                          ldb             #'$'
 00FFF331 017FFFE95                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 00FFF334 016FFFE92                       lbra    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 
                              msgF09Starting:
 00FFF337 04606506D07406906B069           fcb             "Femtiki F09 Multi-core OS Starting",CR,LF,0
 00FFF33E 02004603003902004D075
 00FFF345 06C07406902D06306F072
 00FFF34C 06502004F053020053074
 00FFF353 06107207406906E06700D
 00FFF35A 00A000
 
                              Monitor:
 00FFF35C 01C0EF                          andcc   #$EF                                    ; SWI disables interrupts, re-enable them
 00FFF35E 08601F                          lda             #31                                             ; Timer is IRQ #31
 00FFF360 0150B7FFFE3F010                 sta             PIC+16                          ; register 16 is edge sense reset reg   
 00FFF365 0FC00092C                       ldd             mon_init                        ; check special code to see if monitor has been initialized
 00FFF368 18312D687                       cmpd    #1234567
 00FFF36B 02704D                          beq             mon1
 00FFF36D 07F000810                       clr             BreakpointFlag
 00FFF370 07F000811                       clr             NumSetBreakpoints
 00FFF373 0CC00007B                       ldd             #123
 00FFF376 08E00028E                       ldx             #654
 00FFF379 017FFFEDB                       lbsr    mon_srand
*** warning 1: Long branch within short branch range could be optimized
 00FFF37C 0CCFFF337                       ldd             #msgF09Starting
 00FFF37F 017FFF05B                       lbsr    DisplayString
*** warning 1: Long branch within short branch range could be optimized
 00FFF382 0CCFFF5FE                       ldd             #HelpMsg
 00FFF385 017FFF055                       lbsr    DisplayString
*** warning 1: Long branch within short branch range could be optimized
 00FFF388 0CCFFF32C                       ldd             #CmdPrompt
 00FFF38B 0FD000808                       std             CmdPromptJI
 00FFF38E 0CCFFF5E5                       ldd             #DisplayErr
 00FFF391 0FD00080C                       std             MonErrVec
 00FFF394 0CC0063FF                       ldd             #$63FF                  ; default app stack
 00FFF397 0FD000908                       std             mon_SSAVE
 00FFF39A 07F00090E                       clr             mon_DPRSAVE     ;
 00FFF39D 01F0A8                          tfr             ccr,a
 00FFF39F 0B700090F                       sta             mon_CCRSAVE
 00FFF3A2 07F00090A                       clr             mon_PCSAVE
 00FFF3A5 0CCFFF35C                       ldd             #Monitor
 00FFF3A8 0FD00090B                       std             mon_PCSAVE+1
 00FFF3AB 07F000902                       clr             mon_XSAVE
 00FFF3AE 07F000904                       clr             mon_YSAVE
 00FFF3B1 07F000906                       clr             mon_USAVE
 00FFF3B4 0CC12D687                       ldd             #1234567
 00FFF3B7 0FD00092C                       std             mon_init
                              mon1:
 00FFF3BA 03280F006FFF                    leas    $6FFF                           ; reset stack pointer
 00FFF3BE 05F                             clrb                                                    ; turn off keyboard echo
 00FFF3BF 017FFFE0B                       lbsr    SetKeyboardEcho
*** warning 1: Long branch within short branch range could be optimized
                                      ; Reset IO vectors
 00FFF3C2 0CCFFEC73                       ldd             #SerialPeekCharDirect
 00FFF3C5 0FD000804                       std             CharInVec
 00FFF3C8 0CCFFE31C                       ldd             #DisplayChar
 00FFF3CB 0FD000800                       std             CharOutVec
 00FFF3CE 0CCFFF32C                       ldd             #CmdPrompt
 00FFF3D1 0FD000808                       std             CmdPromptJI
                              ;       jsr             RequestIOFocus
                              PromptLn:
 00FFF3D4 0AD90F000808                    jsr             [CmdPromptJI]
 
                              ; Get characters until a CR is keyed
                                      
                              Prompt3:
 00FFF3D8 0CCFFFFFF                       ldd             #-1                                     ; block until key present
 00FFF3DB 017FFFDB3                       lbsr    INCH
*** warning 1: Long branch within short branch range could be optimized
 00FFF3DE 04D                             tsta                                                    ; should not get this with blocking
 00FFF3DF 02BFF7                          bmi             Prompt3
 00FFF3E1 0C100D                          cmpb    #CR                                     ; carriage return?
 00FFF3E3 027005                          beq             Prompt1 
 00FFF3E5 017FFFDE1                       lbsr    OUTCH                           ; spit out the character
*** warning 1: Long branch within short branch range could be optimized
 00FFF3E8 020FEE                          bra             Prompt3                 ; and keep going
 
                              ; Process the screen line that the CR was keyed on
                              ;
                              Prompt1:
 00FFF3EA 0CC005050                       ldd             #$5050
 00FFF3ED 0150FDFFFE60001                 std             LEDS
                              ;       ldb             RunningID
                              ;       cmpb    #61
                              ;       bhi             Prompt3
 00FFF3F2 00F111                          clr             CursorCol                       ; go back to the start of the line
 00FFF3F4 017FFEEFE                       lbsr    CalcScreenLoc   ; calc screen memory location
*** warning 1: Long branch within short branch range could be optimized
 00FFF3F7 01F002                          tfr             d,y
                              skipDollar:
 00FFF3F9 08D067                          bsr             MonGetNonSpace
 00FFF3FB 0C1024                          cmpb    #'$'
 00FFF3FD 027FFA                          beq             skipDollar              ; skip over '$' prompt character
 
                              ; Dispatch based on command
                              ;
 00FFF3FF 0313FF                          dey
 00FFF401 01F023                          tfr             y,u                                                     ; save off input position
 00FFF403 05F                             clrb
 00FFF404 08EFFF29A                       ldx             #cmdTable1
                              parseCmd1:
 00FFF407 0A6A00                          lda             ,y+                                                     ; get input character
 00FFF409 06D804                          tst             ,x                                                      ; test for end of command
 00FFF40B 02B00F                          bmi             endOfWord                               ;
 00FFF40D 0A1800                          cmpa    ,x+                                                     ; does input match command?
 00FFF40F 027FF6                          beq             parseCmd1
                              scanNextWord:
 00FFF411 06D800                          tst             ,x+
 00FFF413 027F47                          beq             Monitor                                 ; if end of table reached, not a command
 00FFF415 02AFFA                          bpl             scanNextWord
 00FFF417 05C                             incb
 00FFF418 01F032                          tfr             u,y                                                     ; reset input pointer
 00FFF41A 020FEB                          bra             parseCmd1                               ; try again
                              endOfWord:
 00FFF41C 0A8804                          eora    ,x
 00FFF41E 048                             asla
 00FFF41F 026FF0                          bne             scanNextWord
                                      ; we found the command in the table
 00FFF421 058                             aslb                                                                    ; b = word index
 00FFF422 08EFFF2EC                       ldx             #cmdTable2
 00FFF425 06E905                          jmp             [b,x]                                           ; execute command
 
                              Redirect:
 00FFF427 08D034                          bsr             MonGetch
 00FFF429 0C1073                          cmpb    #'s'
 00FFF42B 02600E                          bne             Prompt2a
 00FFF42D 0CCFFEC73                       ldd             #SerialPeekCharDirect
 00FFF430 0FD000804                       std             CharInVec
 00FFF433 0CCFFEC9A                       ldd             #SerialPutChar
 00FFF436 0FD000800                       std             CharOutVec
 00FFF439 020F21                          bra             Monitor
                              Prompt2a:
 00FFF43B 0C1063                          cmpb    #'c'
 00FFF43D 026F1D                          bne             Monitor
 00FFF43F 0CCFFEA92                       ldd             #GetKey
 00FFF442 0FD000804                       std             CharInVec
 00FFF445 0CCFFE31C                       ldd             #DisplayChar
 00FFF448 0FD000800                       std             CharOutVec
 00FFF44B 020F0F                          bra             Monitor
 
                              PromptHelp:
 00FFF44D 0CCFFF5FE                       ldd             #HelpMsg
 00FFF450 017FFEF8A                       lbsr    DisplayString
*** warning 1: Long branch within short branch range could be optimized
 00FFF453 020F07                          bra             Monitor
 
                              PromptClearscreen:
 00FFF455 017FFEDE4                       lbsr    ClearScreen
*** warning 1: Long branch within short branch range could be optimized
 00FFF458 017FFEE58                       lbsr    HomeCursor
*** warning 1: Long branch within short branch range could be optimized
 00FFF45B 020EFF                          bra             Monitor
 
                              MonGetch:
 00FFF45D 0E6A04                          ldb             ,y
 00FFF45F 031201                          iny
 00FFF461 039                             rts
 
                              MonGetNonSpace:
 00FFF462 08DFF9                          bsr             MonGetCh
 00FFF464 0C1020                          cmpb    #' '
 00FFF466 027FFA                          beq             MonGetNonSpace
 00FFF468 039                             rts
 
                              MonArmBreakpoint:
 00FFF469 0170006D5                       lbsr    ArmBreakpoint
 00FFF46C 0C6FFF                          ldb             #$FFF
 00FFF46E 0F7000810                       stb             BreakpointFlag
 00FFF471 016FFFEE8                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              MonDisarmBreakpoint:
 00FFF474 017000700                       lbsr    DisarmBreakpoint
 00FFF477 016FFFEE2                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
 
                              ;------------------------------------------------------------------------------
                              ; Ignore blanks in the input
                              ; Y = text pointer
                              ; D destroyed
                              ;------------------------------------------------------------------------------
                              ;
                              ignBlanks:
                              ignBlanks1:
 00FFF47A 08DFE1                          bsr             MonGetch
 00FFF47C 0C1020                          cmpb    #' '
 00FFF47E 027FFA                          beq             ignBlanks1
 00FFF480 0313FF                          dey
 00FFF482 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Multiply number in work area by 10.
                              ;------------------------------------------------------------------------------
                              Times10:
 00FFF483 034006                          pshs    d
 00FFF485 0FC000910                       ldd             mon_numwka              ; make a copy of the number
 00FFF488 0FD000918                       std             mon_numwka+8
 00FFF48B 0FC000912                       ldd             mon_numwka+2
 00FFF48E 0FD00091A                       std             mon_numwka+10
 00FFF491 08D05B                          bsr             shl_numwka              ; shift left = *2
 00FFF493 08D059                          bsr             shl_numwka              ; shift left = *4
 00FFF495 0FC000912                       ldd             mon_numwka+2    ; add in original value
 00FFF498 0F300091A                       addd    mon_numwka+10   ; = *5
 00FFF49B 0F6000911                       ldb             mon_numwka+1
 00FFF49E 0F9000919                       adcb    mon_numwka+9
 00FFF4A1 0F7000911                       stb             mon_numwka+1
 00FFF4A4 0B6000910                       lda             mon_numwka+0
 00FFF4A7 0B9000918                       adca    mon_numwka+8
 00FFF4AA 0B7000910                       sta             mon_numwka+0
 00FFF4AD 08D03F                          bsr             shl_numwka              ; shift left = * 10
 00FFF4AF 035086                          puls    d,pc
                                      
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              GetTwoParams:
 00FFF4B1 08DFC7                          bsr             ignBlanks
 00FFF4B3 08D0DC                          bsr             GetNumber                       ; get start address of dump
 00FFF4B5 0FC000910                       ldd             mon_numwka
 00FFF4B8 0FD000920                       std             mon_r1
 00FFF4BB 0FC000912                       ldd             mon_numwka+2
 00FFF4BE 0FD000922                       std             mon_r1+2
 00FFF4C1 08DFB7                          bsr             ignBlanks
 00FFF4C3 08D0CC                          bsr             GetNumber                       ; get end address of dump
 00FFF4C5 0FC000910                       ldd             mon_numwka
 00FFF4C8 0FD000924                       std             mon_r2
 00FFF4CB 0FC000912                       ldd             mon_numwka+2
 00FFF4CE 0FD000926                       std             mon_r2+2
 00FFF4D1 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Get a range, the end must be greater or equal to the start.
                              ;------------------------------------------------------------------------------
                              GetRange:
 00FFF4D2 08DFDD                          bsr             GetTwoParams
 00FFF4D4 0FC000926                       ldd             mon_r2+2
 00FFF4D7 0B3000922                       subd    mon_r1+2
 00FFF4DA 0FC000924                       ldd             mon_r2
 00FFF4DD 0F2000921                       sbcb    mon_r1+1
 00FFF4E0 0B2000920                       sbca    mon_r1
 00FFF4E3 124000007                       lbcc    grng1
 00FFF4E6 0AD90F00080C                    jsr             [MonErrVec]
 00FFF4EA 016FFFE6F                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              grng1:
 00FFF4ED 039                             rts
 
                              shl_numwka:
 00FFF4EE 078000913                       asl             mon_numwka+3
 00FFF4F1 079000912                       rol             mon_numwka+2
 00FFF4F4 079000911                       rol             mon_numwka+1
 00FFF4F7 079000910                       rol             mon_numwka
 00FFF4FA 039                             rts
 
                              ;------------------------------------------------------------------------------
                              ; Get a hexidecimal number. Maximum of twelve digits.
                              ;
                              ; Modifies:
                              ;       Y = text pointer (updated)
                              ;       D = number of digits
                              ;       mon_numwka contains number
                              ;------------------------------------------------------------------------------
                              ;
                              GetHexNumber:
 00FFF4FB 04F05F                          clrd
 00FFF4FD 0FD000910                       std             mon_numwka      ; zero out work area
 00FFF500 0FD000912                       std             mon_numwka+2
 00FFF503 034010                          pshs    x
 00FFF505 08E000000                       ldx             #0                                      ; max 12 eight digits
                              gthxn2:
 00FFF508 08DF53                          bsr             MonGetch
 00FFF50A 08D093                          bsr             AsciiToHexNybble
 00FFF50C 0C1FFF                          cmpb    #-1
 00FFF50E 027017                          beq             gthxn1
 00FFF510 08DFDC                          bsr             shl_numwka
 00FFF512 08DFDA                          bsr             shl_numwka
 00FFF514 08DFD8                          bsr             shl_numwka
 00FFF516 08DFD6                          bsr             shl_numwka
 00FFF518 0C400F                          andb    #$0f
 00FFF51A 0FA000913                       orb             mon_numwka+3
 00FFF51D 0F7000913                       stb             mon_numwka+3
 00FFF520 030001                          inx
 00FFF522 08C00000C                       cmpx    #12
 00FFF525 025FE1                          blo             gthxn2
                              gthxn1:
 00FFF527 01F010                          tfr             x,d
 00FFF529 035090                          puls    x,pc
 
                              GetBinNumber:
 00FFF52B 04F05F                          clrd
 00FFF52D 0FD000910                       std             mon_numwka
 00FFF530 0FD000912                       std             mon_numwka+2
 00FFF533 034010                          pshs    x
 00FFF535 08E000000                       ldx             #0
                              gtbin2:
 00FFF538 08DF23                          bsr             MonGetch
 00FFF53A 08D099                          bsr             AsciiToBinDigit
 00FFF53C 05D                             tstb
 00FFF53D 02B00F                          bmi             gtbin1
 00FFF53F 08DFAD                          bsr             shl_numwka
 00FFF541 0FA000913                       orb             mon_numwka+3
 00FFF544 0F7000913                       stb             mon_numwka+3
 00FFF547 030001                          inx
 00FFF549 08C000030                       cpx             #48
 00FFF54C 025FEA                          blo             gtbin2
                              gtbin1:
 00FFF54E 01F010                          tfr             x,d
 00FFF550 035090                          puls    x,pc
                                      
                              GetDecNumber:
 00FFF552 04F05F                          clrd
 00FFF554 0FD000910                       std             mon_numwka
 00FFF557 0FD000912                       std             mon_numwka+2
 00FFF55A 034010                          pshs    x
 00FFF55C 08E000000                       ldx             #0
                              gtdec2:
 00FFF55F 08DEFC                          bsr             MonGetch
 00FFF561 08D064                          bsr             AsciiToDecDigit
 00FFF563 05D                             tstb
 00FFF564 02B027                          bmi             gtdec1
 00FFF566 08DF1B                          bsr             Times10
 00FFF568 0FB000913                       addb    mon_numwka+3
 00FFF56B 0F7000913                       stb             mon_numwka+3
 00FFF56E 0F6000912                       ldb             mon_numwka+2
 00FFF571 0C9000                          adcb    #0
 00FFF573 0F7000912                       stb             mon_numwka+2
 00FFF576 0F6000911                       ldb             mon_numwka+1
 00FFF579 0C9000                          adcb    #0
 00FFF57B 0F7000911                       stb             mon_numwka+1
 00FFF57E 0F6000910                       ldb             mon_numwka+0
 00FFF581 0C9000                          adcb    #0
 00FFF583 0F7000910                       stb             mon_numwka+0
 00FFF586 030001                          inx
 00FFF588 08C00000F                       cpx             #15
 00FFF58B 025FD2                          blo             gtdec2
                              gtdec1:
 00FFF58D 01F010                          tfr             x,d
 00FFF58F 035090                          puls    x,pc
 
                              GetNumber:
 00FFF591 08DECA                          bsr             MonGetch
 00FFF593 0C102B                          cmpb    #'+'
 00FFF595 027FBB                          beq             GetDecNumber
 00FFF597 0C1025                          cmpb    #'%'
 00FFF599 027F90                          beq             GetBinNumber
 00FFF59B 0313FF                          dey
 00FFF59D 020F5C                          bra             GetHexNumber
 
                              ;       phx
                              ;       push    r4
                              ;       push    r5
                              ;       ldx             #0
                              ;       ld              r4,#10
                              ;       ld              r5,#10
                              ;gtdcn2:
                              ;       jsr             MonGetch
                              ;       jsr             AsciiToDecNybble
                              ;       cmp             #-1
                              ;       beq             gtdcn1
                              ;       mul             r2,r2,r5
                              ;       add             r2,r1
                              ;       dec             r4
                              ;       bne             gtdcn2
                              ;gtdcn1:
                              ;       txa
                              ;       pop             r5
                              ;       pop             r4
                              ;       plx
                              ;       rts
 
                              ;------------------------------------------------------------------------------
                              ; Convert ASCII character in the range '0' to '9', 'a' to 'f' or 'A' to 'F'
                              ; to a hex nybble.
                              ;------------------------------------------------------------------------------
                              ;
                              AsciiToHexNybble:
 00FFF59F 0C1030                          cmpb    #'0'
 00FFF5A1 025021                          blo             gthx3
 00FFF5A3 0C1039                          cmpb    #'9'
 00FFF5A5 022003                          bhi             gthx5
 00FFF5A7 0C0030                          subb    #'0'
 00FFF5A9 039                             rts
                              gthx5:
 00FFF5AA 0C1041                          cmpb    #'A'
 00FFF5AC 025016                          blo             gthx3
 00FFF5AE 0C1046                          cmpb    #'F'
 00FFF5B0 022005                          bhi             gthx6
 00FFF5B2 0C0041                          subb    #'A'
 00FFF5B4 0CB00A                          addb    #10
 00FFF5B6 039                             rts
                              gthx6:
 00FFF5B7 0C1061                          cmpb    #'a'
 00FFF5B9 025009                          blo             gthx3
 00FFF5BB 0C107A                          cmpb    #'z'
 00FFF5BD 022005                          bhi             gthx3
 00FFF5BF 0C0061                          subb    #'a'
 00FFF5C1 0CB00A                          addb    #10
 00FFF5C3 039                             rts
                              gthx3:
 00FFF5C4 0C6FFF                          ldb             #-1             ; not a hex number
 00FFF5C6 039                             rts
 
                              AsciiToDecDigit:
 00FFF5C7 0C1030                          cmpb    #'0'
 00FFF5C9 025007                          blo             gtdc3
 00FFF5CB 0C1039                          cmpb    #'9'
 00FFF5CD 022003                          bhi             gtdc3
 00FFF5CF 0C0030                          subb    #'0'
 00FFF5D1 039                             rts
                              gtdc3:
 00FFF5D2 0C6FFF                          ldb             #-1
 00FFF5D4 039                             rts
 
                              AsciiToBinDigit:
 00FFF5D5 0C1030                          cmpb    #'0'
 00FFF5D7 026002                          bne             abd1
 00FFF5D9 05F                             clrb
 00FFF5DA 039                             rts
                              abd1:
 00FFF5DB 0C1031                          cmpb    #'1'
 00FFF5DD 026003                          bne             abd2
 00FFF5DF 0C6001                          ldb             #1
 00FFF5E1 039                             rts
                              abd2:
 00FFF5E2 0C6FFF                          ldb             #-1
 00FFF5E4 039                             rts
 
                              DisplayErr:
 00FFF5E5 0CCFFF5F6                       ldd             #msgErr
 00FFF5E8 017FFEDF2                       lbsr    DisplayString
*** warning 1: Long branch within short branch range could be optimized
 00FFF5EB 07EFFF35C                       jmp             Monitor
 
                              DisplayStringDX
 00FFF5EE 0DD024                          std             Strptr
 00FFF5F0 09F026                          stx             Strptr+2
 00FFF5F2 0BDFFE3DD                       jsr             DisplayString
 00FFF5F5 039                             rts
 
                              msgErr:
 00FFF5F6 02A02A04507207200D00A           fcb     "**Err",CR,LF,0
 00FFF5FD 000
 
                              HelpMsg:
 00FFF5FE 03F02003D020044069073           fcb             "? = Display help",CR,LF
 00FFF605 07006C061079020068065
 00FFF60C 06C07000D00A
 00FFF610 04304C05302003D020063           fcb     "CLS = clear screen",CR,LF
 00FFF617 06C065061072020073063
 00FFF61E 07206506506E00D00A
 00FFF624 06202B02003D020073065           fcb     "b+ = set breakpoint",CR,LF
 00FFF62B 07402006207206506106B
 00FFF632 07006F06906E07400D00A
 00FFF639 06202D02003D02006306C           fcb     "b- = clear breakpoint",CR,LF
 00FFF640 065061072020062072065
 00FFF647 06106B07006F06906E074
 00FFF64E 00D00A
                              ;       db      "S = Boot from SD Card",CR,LF
 00FFF650 03A02003D020045064069           fcb     ": = Edit memory bytes",CR,LF
 00FFF657 07402006D06506D06F072
 00FFF65E 079020062079074065073
 00FFF665 00D00A
                              ;       db      "L = Load sector",CR,LF
                              ;       db      "W = Write sector",CR,LF
 00FFF667 04405202003D020044075           fcb "DR = Dump registers",CR,LF
 00FFF66E 06D070020072065067069
 00FFF675 07307406507207300D00A
 00FFF67C 04402003D02004407506D           fcb     "D = Dump memory",CR,LF
 00FFF683 07002006D06506D06F072
 00FFF68A 07900D00A
 00FFF68D 04602003D02004606906C           fcb     "F = Fill memory",CR,LF
 00FFF694 06C02006D06506D06F072
 00FFF69B 07900D00A
 00FFF69E 04604C02003D020044075           fcb "FL = Dump I/O Focus List",CR,LF
 00FFF6A5 06D07002004902F04F020
 00FFF6AC 04606F06307507302004C
 00FFF6B3 06907307400D00A
                              ;       fcb "FIG = start FIG Forth",CR,LF
                              ;       db      "KILL n = kill task #n",CR,LF
                              ;       db      "B = start tiny basic",CR,LF
                              ;       db      "b = start EhBasic 6502",CR,LF
 00FFF6B8 04A02003D02004A07506D           fcb     "J = Jump to code",CR,LF
 00FFF6BF 07002007406F02006306F
 00FFF6C6 06406500D00A
 00FFF6CA 04A04403402003D02004A           fcb     "JD4 = Jump to $FFD400",CR,LF
 00FFF6D1 07506D07002007406F020
 00FFF6D8 024046046044034030030
 00FFF6DF 00D00A
 00FFF6E1 05205B06E05D02003D020           fcb     "R[n] = Set register value",CR,LF
 00FFF6E8 053065074020072065067
 00FFF6EF 069073074065072020076
 00FFF6F6 06106C07506500D00A
                              ;       db      "r = random lines - test bitmap",CR,LF
                              ;       db      "e = ethernet test",CR,LF
 00FFF6FC 07302003D020073065072           fcb     "s = serial output test",CR,LF
 00FFF703 06906106C02006F075074
 00FFF70A 070075074020074065073
 00FFF711 07400D00A
 00FFF714 05303103902003D020072           fcb     "S19 = run S19 loader",CR,LF
 00FFF71B 07506E020053031039020
 00FFF722 06C06F06106406507200D
 00FFF729 00A
 00FFF72A 05305002003D020073070           fcb     "SP = sprite demo",CR,LF
 00FFF731 072069074065020064065
 00FFF738 06D06F00D00A
                              ;       db      "T = Dump task list",CR,LF
                              ;       db      "TO = Dump timeout list",CR,LF
 00FFF73C 05404902003D020064069           fcb     "TI = display date/time",CR,LF
 00FFF743 07307006C061079020064
 00FFF74A 06107406502F07406906D
 00FFF751 06500D00A
                              ;       db      "TEMP = display temperature",CR,LF
 00FFF754 05502003D02007506E061           fcb     "U = unassemble",CR,LF
 00FFF75B 07307306506D06206C065
 00FFF762 00D00A
                              ;       db      "P = Piano",CR,LF
 00FFF764 05804D02003D02007806D           fcb     "XM = xmodem transfer",CR,LF
 00FFF76B 06F06406506D020074072
 00FFF772 06106E07306606507200D
 00FFF779 00A
 00FFF77A 07802003D020065078069           fcb     "x = exit monitor",CR,LF
 00FFF781 07402006D06F06E069074
 00FFF788 06F07200D00A
 00FFF78C 000                             fcb             0
 
                              msgRegHeadings
 00FFF78D 00D00A02002004402F041           fcb     CR,LF,"  D/AB     X      Y      U      S       PC    DP  CCR",CR,LF,0
 00FFF794 042020020020020020058
 00FFF79B 020020020020020020059
 00FFF7A2 020020020020020020055
 00FFF7A9 020020020020020020053
 00FFF7B0 020020020020020020020
 00FFF7B7 050043020020020020044
 00FFF7BE 05002002004304305200D
 00FFF7C5 00A000
 
                              nHEX4:
 00FFF7C7 0BDFFD2D2                       jsr             HEX4
 00FFF7CA 039                             rts
 
                              nXBLANK:
 00FFF7CB 0C6020                          ldb             #' '
 00FFF7CD 016FFF9F9                       lbra    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 
                              ;------------------------------------------------------------------------------
                              ; Dump Memory
                              ;
                              ; Usage:
                              ;       $D FFFC12 FFFC20
                              ;
                              ; Dump formatted to look like:
                              ;               :FFFC12 012 012 012 012 555 666 777 888
                              ;
                              ;------------------------------------------------------------------------------
 
                              DumpMemory:
 00FFF7D0 08DD00                          bsr             GetRange
 00FFF7D2 18E000000                       ldy             #0
 00FFF7D5 1BE000922                       ldy             mon_r1+2
                              dmpm2:
 00FFF7D8 017FFD8F7                       lbsr    CRLF
*** warning 1: Long branch within short branch range could be optimized
 00FFF7DB 0C603A                          ldb             #':'
 00FFF7DD 017FFF9E9                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 00FFF7E0 01F020                          tfr             y,d
                                      ;addd   mon_r1+2                                        ; output the address
 00FFF7E2 017FFEC4C                       lbsr    DispWordAsHex
*** warning 1: Long branch within short branch range could be optimized
 00FFF7E5 0C6020                          ldb             #' '
 00FFF7E7 017FFF9DF                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 00FFF7EA 08E000008                       ldx             #8                                                              ; number of bytes to display
                              dmpm1:
                              ;       ldb             far [mon_r1+1],y
                                      ;ldb            [mon_r1+2],y
 00FFF7ED 0E6A04                          ldb             ,y
 00FFF7EF 031201                          iny
 00FFF7F1 017FFEC46                       lbsr    DispByteAsHex                   ; display byte
*** warning 1: Long branch within short branch range could be optimized
 00FFF7F4 0C6020                          ldb             #' '                                                    ; followed by a space
 00FFF7F6 017FFF9D0                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 00FFF7F9 05F                             clrb
 00FFF7FA 04F                             clra
 00FFF7FB 017FFF993                       lbsr    INCH
*** warning 1: Long branch within short branch range could be optimized
 00FFF7FE 0C1003                          cmpb    #CTRLC
 00FFF800 027024                          beq             dmpm3
 00FFF802 0301FF                          dex
 00FFF804 026FE7                          bne             dmpm1
                                      ; Now output ascii
 00FFF806 0C6020                          ldb             #' '
 00FFF808 017FFF9BE                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 00FFF80B 08E000008                       ldx             #8                                                              ; 8 chars to output
 00FFF80E 0313F8                          leay    -8,y                                                    ; backup pointer
                              dmpm5:
                              ;       ldb             far [mon_r1+1],y        ; get the char
                              ;       ldb             [mon_r1+2],y                    ; get the char
 00FFF810 0E6A04                          ldb             ,y
 00FFF812 0C1020                          cmpb    #$20                                                    ; is it a control char?
 00FFF814 024002                          bhs             dmpm4
 00FFF816 0C602E                          ldb             #'.'
                              dmpm4:
 00FFF818 017FFF9AE                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
 00FFF81B 031201                          iny
 00FFF81D 0301FF                          dex
 00FFF81F 026FEF                          bne             dmpm5
 00FFF821 1BC000926                       cmpy    mon_r2+2
 00FFF824 025FB2                          blo             dmpm2
                              dmpm3:
 00FFF826 017FFD8A9                       lbsr    CRLF
*** warning 1: Long branch within short branch range could be optimized
 00FFF829 016FFFB30                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
 
                              ;------------------------------------------------------------------------------
                              ; Edit Memory
                              ;
                              ; Usage:
                              ;       $$:FFFC12 8 "Hello World!" 0
                              ;
                              ; Dump formatted to look like:
                              ;               :FFFC12 012 012 012 012 555 666 777 888
                              ;
                              ;------------------------------------------------------------------------------
 
                              EditMemory:
 00FFF82C 0CE000008                       ldu             #8                                              ; set max byte count
 00FFF82F 017FFFC48                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 00FFF832 017FFFCC6                       lbsr    GetHexNumber    ; get the start address
*** warning 1: Long branch within short branch range could be optimized
 00FFF835 0BE000912                       ldx             mon_numwka+2
                              EditMem2:
 00FFF838 017FFFC3F                       lbsr    ignBlanks                       ; skip over blanks
*** warning 1: Long branch within short branch range could be optimized
 00FFF83B 017FFFCBD                       lbsr    GetHexNumber    ; get the byte value
*** warning 1: Long branch within short branch range could be optimized
 00FFF83E 05D                             tstb                                                            ; check for valid value
 00FFF83F 02700C                          beq             EditMem1                        ; if invalid, quit
 00FFF841 0F6000913                       ldb             mon_numwka+3    ; get value
 00FFF844 0E7800                          stb             ,x+                                             ; update memory at address
 00FFF846 0335FF                          leau    -1,u                                    ; decremeent byte count
 00FFF848 283000000                       cmpu    #0
 00FFF84B 026FEB                          bne             EditMem2                        ; go back for annother byte
                              EditMem1:
 00FFF84D 017FFFC0D                       lbsr    MonGetch                        ; see if a string is being entered
*** warning 1: Long branch within short branch range could be optimized
 00FFF850 0C1022                          cmpb    #'"'
 00FFF852 026018                          bne             EditMem3                        ; no string, we're done
 00FFF854 0CE000028                       ldu             #40                                             ; string must be less than 40 chars
                              EditMem4:
 00FFF857 017FFFC03                       lbsr    MonGetch                        ; look for close quote
*** warning 1: Long branch within short branch range could be optimized
 00FFF85A 0C1022                          cmpb    #'"'
 00FFF85C 026005                          bne             EditMem6                        ; end of string?
 00FFF85E 0CE000008                       ldu             #8                                              ; reset the byte count
 00FFF861 020FD5                          bra             EditMem2
                              EditMem6:                       
 00FFF863 0E7800                          stb             ,x+                                             ; store the character in memory
 00FFF865 0335FF                          leau    -1,u                                    ; decrement byte count
 00FFF867 283000000                       cmpu    #0
 00FFF86A 022FEB                          bhi             EditMem4                        ; max 40 chars
                              EditMem3:
 00FFF86C 016FFFAED                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                                      
 
                              ;------------------------------------------------------------------------------
                              ; Fill Memory
                              ;
                              ; Usage:
                              ;       $$F FFFC12 FFFC30 89F
                              ;
                              ;------------------------------------------------------------------------------
 
                              FillMemory:
 00FFF86F 017FFFC60                       lbsr    GetRange                        ; get address range to fill
*** warning 1: Long branch within short branch range could be optimized
 00FFF872 017FFFC05                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 00FFF875 017FFFC83                       lbsr    GetHexNumber    ; get target byte to write
*** warning 1: Long branch within short branch range could be optimized
 00FFF878 0F6000913                       ldb             mon_numwka+3
 00FFF87B 0BE000922                       ldx             mon_r1+2
 00FFF87E 04F                             clra
                              fillm1:                                                         ; Check for a CTRL-C every page of memory
 00FFF87F 04D                             tsta
 00FFF880 02600D                          bne             fillm2
 00FFF882 05F                             clrb                                                            ; we want a non-blocking check
 00FFF883 04F                             clra
 00FFF884 017FFF90A                       lbsr    INCH
*** warning 1: Long branch within short branch range could be optimized
 00FFF887 0C1003                          cmpb    #CTRLC
 00FFF889 127FFFAD0                       lbeq    Monitor
*** warning 1: Long branch within short branch range could be optimized
 00FFF88C 0F6000913                       ldb             mon_numwka+3    ; reset target byte
                              fillm2:
 00FFF88F 0E7800                          stb             ,x+
 00FFF891 0BC000926                       cmpx    mon_r2+2
 00FFF894 023FE9                          bls             fillm1
                              fillm3:
 00FFF896 016FFFAC3                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                                      
                              ;------------------------------------------------------------------------------
                              ; Dump Registers
                              ;
                              ;       Usage:
                              ;               $DR
                              ;------------------------------------------------------------------------------
 
                              DumpRegs:
 00FFF899 0CCFFF78D                       ldd             #msgRegHeadings
 00FFF89C 017FFEB3E                       lbsr    DisplayString
*** warning 1: Long branch within short branch range could be optimized
 00FFF89F 08DF2A                          bsr             nXBLANK
 00FFF8A1 0FC000900                       ldd             mon_DSAVE
 00FFF8A4 08DF21                          bsr             nHEX4
 00FFF8A6 08DF23                          bsr             nXBLANK
 00FFF8A8 0FC000902                       ldd             mon_XSAVE
 00FFF8AB 08DF1A                          bsr             nHEX4
 00FFF8AD 08DF1C                          bsr             nXBLANK
 00FFF8AF 0FC000904                       ldd             mon_YSAVE
 00FFF8B2 08DF13                          bsr             nHEX4
 00FFF8B4 08DF15                          bsr             nXBLANK
 00FFF8B6 0FC000906                       ldd             mon_USAVE
 00FFF8B9 08DF0C                          bsr             nHEX4
 00FFF8BB 08DF0E                          bsr             nXBLANK
 00FFF8BD 0FC000908                       ldd             mon_SSAVE
 00FFF8C0 08DF05                          bsr             nHEX4
 00FFF8C2 08DF07                          bsr             nXBLANK
 00FFF8C4 0F600090B                       ldb             mon_PCSAVE+1
 00FFF8C7 017FFEB70                       lbsr    DispByteAsHex   
*** warning 1: Long branch within short branch range could be optimized
 00FFF8CA 0FC00090C                       ldd             mon_PCSAVE+2
 00FFF8CD 08DEF8                          bsr             nHEX4
 00FFF8CF 08DEFA                          bsr             nXBLANK
 00FFF8D1 0FC00090E                       ldd             mon_DPRSAVE
 00FFF8D4 0BDFFD2CE                       jsr             HEX2
 00FFF8D7 08DEF2                          bsr             nXBLANK
 00FFF8D9 0B600090F                       lda             mon_CCRSAVE
 00FFF8DC 017FFD9EF                       lbsr    HEX2
*** warning 1: Long branch within short branch range could be optimized
 00FFF8DF 08DEEA                          bsr             nXBLANK
 00FFF8E1 016FFFA78                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
 
                              ;------------------------------------------------------------------------------
                              ; SetRegXXX
                              ;
                              ; Set the value to be loaded into a register.
                              ;------------------------------------------------------------------------------
 
                              SetRegA:
 00FFF8E4 017FFFB93                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 00FFF8E7 017FFFCA7                       lbsr    GetNumber
*** warning 1: Long branch within short branch range could be optimized
 00FFF8EA 0B6000913                       lda             mon_numwka+3
 00FFF8ED 0B7000900                       sta             mon_DSAVE
 00FFF8F0 016FFFA69                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              SetRegB:
 00FFF8F3 017FFFB84                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 00FFF8F6 017FFFC98                       lbsr    GetNumber
*** warning 1: Long branch within short branch range could be optimized
 00FFF8F9 0B6000913                       lda             mon_numwka+3
 00FFF8FC 0B7000901                       sta             mon_DSAVE+1
 00FFF8FF 016FFFA5A                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              SetRegD:
 00FFF902 017FFFB75                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 00FFF905 017FFFC89                       lbsr    GetNumber
*** warning 1: Long branch within short branch range could be optimized
 00FFF908 0FC000912                       ldd             mon_numwka+2
 00FFF90B 0FD000900                       std             mon_DSAVE
 00FFF90E 016FFFA4B                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              SetRegX:
 00FFF911 017FFFB66                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 00FFF914 017FFFC7A                       lbsr    GetNumber
*** warning 1: Long branch within short branch range could be optimized
 00FFF917 0FC000912                       ldd             mon_numwka+2
 00FFF91A 0FD000902                       std             mon_XSAVE
 00FFF91D 016FFFA3C                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              SetRegY:
 00FFF920 017FFFB57                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 00FFF923 017FFFC6B                       lbsr    GetNumber
*** warning 1: Long branch within short branch range could be optimized
 00FFF926 0FC000912                       ldd             mon_numwka+2
 00FFF929 0FD000904                       std             mon_YSAVE
 00FFF92C 016FFFA2D                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              SetRegU:
 00FFF92F 017FFFB48                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 00FFF932 017FFFC5C                       lbsr    GetNumber
*** warning 1: Long branch within short branch range could be optimized
 00FFF935 0FC000912                       ldd             mon_numwka+2
 00FFF938 0FD000906                       std             mon_USAVE
 00FFF93B 016FFFA1E                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              SetRegS:
 00FFF93E 017FFFB39                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 00FFF941 017FFFC4D                       lbsr    GetNumber
*** warning 1: Long branch within short branch range could be optimized
 00FFF944 0FC000912                       ldd             mon_numwka+2
 00FFF947 0FD000908                       std             mon_SSAVE
 00FFF94A 016FFFA0F                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              SetRegDPR:
 00FFF94D 017FFFB2A                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 00FFF950 017FFFC3E                       lbsr    GetNumber
*** warning 1: Long branch within short branch range could be optimized
 00FFF953 0B6000913                       lda             mon_numwka+3
 00FFF956 0B700090E                       sta             mon_DPRSAVE
 00FFF959 016FFFA00                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              SetRegCCR:
 00FFF95C 017FFFB1B                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 00FFF95F 017FFFC2F                       lbsr    GetNumber
*** warning 1: Long branch within short branch range could be optimized
 00FFF962 0B6000913                       lda             mon_numwka+3
 00FFF965 0B700090F                       sta             mon_CCRSAVE
 00FFF968 016FFF9F1                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                              SetRegPC:
 00FFF96B 017FFFB0C                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 00FFF96E 017FFFC20                       lbsr    GetNumber
*** warning 1: Long branch within short branch range could be optimized
 00FFF971 0FC000912                       ldd             mon_numwka+2
 00FFF974 0FD00090C                       std             mon_PCSAVE+2
 00FFF977 0F6000911                       ldb             mon_numwka+1
 00FFF97A 0F700090B                       stb             mon_PCSAVE+1
 00FFF97D 016FFF9DC                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
 
                              ;------------------------------------------------------------------------------
                              ; Jump to code
                              ;
                              ; Registers are loaded with values from the monitor register save area before
                              ; the code is jumped to.
                              ;
                              ; J <address>
                              ;------------------------------------------------------------------------------
 
                              jump_to_code:
 00FFF980 017FFFAF7                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 00FFF983 017FFFC0B                       lbsr    GetNumber
*** warning 1: Long branch within short branch range could be optimized
 00FFF986 01A010                          sei
 00FFF988 1FE000908                       lds             mon_SSAVE
 00FFF98B 0CCFFF9BA                       ldd             #jtc_exit                       ; setup stack for RTS back to monitor
 00FFF98E 034006                          pshs    d
 00FFF990 0C6000                          ldb             #0
 00FFF992 034004                          pshs    b
 00FFF994 0FC000906                       ldd             mon_USAVE
 00FFF997 034006                          pshs    d
 00FFF999 0FC000904                       ldd             mon_YSAVE
 00FFF99C 034006                          pshs    d
 00FFF99E 0FC000902                       ldd             mon_XSAVE
 00FFF9A1 034006                          pshs    d
 00FFF9A3 0B600090E                       lda             mon_DPRSAVE
 00FFF9A6 034002                          pshs    a
 00FFF9A8 0FC000900                       ldd             mon_DSAVE
 00FFF9AB 034006                          pshs    d
 00FFF9AD 0B600090F                       lda             mon_CCRSAVE
 00FFF9B0 034002                          pshs    a
 00FFF9B2 01503507F                       puls    far ccr,d,dpr,x,y,u
 00FFF9B5 01506E90F000911                 jmp             far [mon_numwka+1]
                              jtc_exit:
 00FFF9BA 1FF000908                       sts             >mon_SSAVE              ; need to use extended addressing, no direct page setting
 00FFF9BD 03280F006FFF                    leas    $6FFF                                   ; reset stack to system area, dont modify flags register!
 00FFF9C1 034001                          pshs    ccr                                             ; now the stack can be used
 00FFF9C3 034002                          pshs    a                                                       ; save acca register so we can use it
 00FFF9C5 01F0B8                          tfr             dpr,a                                   ; a = outgoing dpr value
 00FFF9C7 0B700090E                       sta             >mon_DPRSAVE    ; force extended addressing mode usage here dpr is not set
 00FFF9CA 04F                             clra                                                            ; dpg register must be set to zero before values are 
 00FFF9CB 01F08B                          tfr             a,dpr                                   ; saved in the monitor register save area.
 00FFF9CD 035002                          puls    a                                                       ; get back acca
 00FFF9CF 0FD000900                       std             mon_DSAVE                       ; save regsters, can use direct addressing now
 00FFF9D2 0BF000902                       stx             mon_XSAVE
 00FFF9D5 1BF000904                       sty             mon_YSAVE
 00FFF9D8 0FF000906                       stu             mon_USAVE
 00FFF9DB 035002                          puls    a                                                       ; get back ccr
 00FFF9DD 0B700090F                       sta             mon_CCRSAVE             ; and save it too
                                      ; Reset vectors in case they got toasted.
 00FFF9E0 0CCFFEC73                       ldd             #SerialPeekCharDirect
 00FFF9E3 0FD000804                       std             CharInVec
 00FFF9E6 0CCFFE31C                       ldd             #DisplayChar
 00FFF9E9 0FD000800                       std             CharOutVec
 00FFF9EC 0FCFFF5E5                       ldd             DisplayErr
 00FFF9EF 0FD00080C                       std             MonErrVec
                                      ; todo set according to coreid
 00FFF9F2 016FFFEA4                       lbra    DumpRegs                        ; now go do a register dump
*** warning 1: Long branch within short branch range could be optimized
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
 
                              DumpIOFocusList:
 00FFF9F5 08E000000                       ldx             #0
                              dfl2:
 00FFF9F8 0E680A000FFC000                 ldb             IOFocusList,x
 00FFF9FD 0C1018                          cmpb    #24
 00FFF9FF 02600A                          bne             dfl1
 00FFFA01 01F010                          tfr             x,d
 00FFFA03 017FFEA34                       lbsr    DispByteAsHex
*** warning 1: Long branch within short branch range could be optimized
 00FFFA06 0C6020                          ldb             #' '
 00FFFA08 017FFF7BE                       lbsr    OUTCH
*** warning 1: Long branch within short branch range could be optimized
                              dfl1:
 00FFFA0B 030001                          inx
 00FFFA0D 08C000010                       cmpx    #16
 00FFFA10 025FE6                          blo             dfl2
 00FFFA12 017FFD6BD                       lbsr    CRLF
*** warning 1: Long branch within short branch range could be optimized
 00FFFA15 016FFF944                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                                      
                              bootpg:
 00FFFA18 000                             fcb             $000
                              boot_stack:
 00FFFA19 FFC0FF                          fcw             $FFC0FF
                              numBreakpoints:
 00FFFA1B 000008                          fcw             8
                              mon_rom_vectab:
 00FFFA1D FFFA1F                          fcw             mon_rom_vecs
                              mon_rom_vecs:
 00FFFA1F FFF35C                          fcw             Monitor                                         ; enter monitor program
 00FFFA21 FFF191                          fcw             INCH                                                    ; input a character
 00FFFA23 FFF1C9                          fcw             OUTCH                                                   ; output a character
 00FFFA25 FFD0D2                          fcw             CRLF                                                    ; output carriage-return, line feed
 00FFFA27 FFE3DD                          fcw             DisplayString
 00FFFA29 FFE43A                          fcw             DispByteAsHex
 00FFFA2B FFE431                          fcw             DispWordAsHex
 00FFFA2D FFF1D3                          fcw             ShowSprites
 00FFFA2F FFF257                          fcw             mon_srand
 00FFFA31 FFF285                          fcw             mon_rand
 00FFFA33 000000                          fcw             0                                                                       ; operating system call
 00FFFA35 FFF4D2                          fcw             GetRange
 00FFFA37 FFF591                          fcw             GetNumber
 00FFFA39 FFEC9A                          fcw             SerialPutChar   
 
                              NumFuncs        EQU     (*-mon_rom_vectab)/2
 
                              ; The following table indicates which routines need to return values in the
                              ; D and possibly X registers.
 
                              mon_rettab:
 00FFFA3B 000                             fcb             0                       ; monitor
 00FFFA3C 800                             fcb             $800    ; INCH
 00FFFA3D 000                             fcb             0                       ; OUTCH
 00FFFA3E 000                             fcb             0                       ; CRLF
 00FFFA3F 000                             fcb             0                       ; DisplayString
 00FFFA40 000                             fcb             0                       ; DisplayByte
 00FFFA41 000                             fcb             0                       ; DisplayWord
 00FFFA42 000                             fcb             0                       ; show sprites
 00FFFA43 000                             fcb             0                       ; srand
 00FFFA44 C00                             fcb             $C00    ; rand
 00FFFA45 C00                             fcb             $C00    ; OS call
 00FFFA46 000                             fcb             0                       ; GetRange
 00FFFA47 800                             fcb             $800    ; GetNumber
 00FFFA48 000                             fcb             0                       ; SerialPutChar
                                      
                              ;------------------------------------------------------------------------------
                              ; SWI routine.
                              ;
                              ; SWI is used to call ROM monitor routines and process breakpoints.
                              ;
                              ;       swi
                              ;       fcb <desired function>
                              ;------------------------------------------------------------------------------
 
                              swi_rout:
 00FFFA49 0E680CFCC                       ldb             bootpg,pcr                      ; reset direct page
 00FFFA4C 01F09B                          tfr             b,dp
                              swi_rout1:
 00FFFA4E 0EE60B                          ldu             11,s                                            ; get program counter (low order 2 bytes)
 00FFFA50 0335FF                          leau    -1,u                                            ; backup a byte
 00FFFA52 07D000810                       tst             BreakpointFlag  ; are we in breakpoint mode?
 00FFFA55 02700F                          beq             swiNotBkpt
 00FFFA57 18E000820                       ldy             #Breakpoints
 00FFFA5A 0F6000811                       ldb             NumSetBreakpoints
 00FFFA5D 027007                          beq             swiNotBkpt
                              swi_rout2:
 00FFFA5F 2A3A01                          cmpu    ,y++    
 00FFFA61 02704B                          beq             processBreakpoint
 00FFFA63 05A                             decb
 00FFFA64 026FF9                          bne             swi_rout2
                              swiNotBkpt:
 00FFFA66 07F000810                       clr             BreakpointFlag
 00FFFA69 037006                          pulu    d                                                               ; get function #, increment PC
 00FFFA6B 0C100F                          cmpb    #NumFuncs
 00FFFA6D 122FFFB75                       lbhi    DisplayErr
*** warning 1: Long branch within short branch range could be optimized
 00FFFA70 0EF60B                          stu             11,s                                            ; save updated PC on stack
 00FFFA72 0C100A                          cmpb    #MF_OSCALL
 00FFFA74 027072                          beq             swiCallOS
 00FFFA76 058                             aslb                                                                    ; 2 bytes per vector
 00FFFA77 0AE80CFA3                       ldx             mon_rom_vectab,pcr
 00FFFA7A 03A                             abx
 00FFFA7B 0AE804                          ldx             ,x
 00FFFA7D 0BF000928                       stx             jmpvec
 00FFFA80 054                             lsrb
 00FFFA81 08EFFFA3B                       ldx             #mon_rettab
 00FFFA84 03A                             abx
 00FFFA85 0E6804                          ldb             ,x
 00FFFA87 0F7000930                       stb             mon_retflag
 00FFFA8A 1FF000908                       sts             mon_SSAVE                               ; save the stack pointer
 00FFFA8D 0EC601                          ldd             1,s                                                     ; get back D
 00FFFA8F 0AE604                          ldx             4,s                                                     ; get back X
 00FFFA91 1AE606                          ldy             6,s                                                     ; get back Y
 00FFFA93 0EE608                          ldu             8,s                                                     ; get back U
 00FFFA95 1EE80CF81                       lds             boot_stack,pcr  ; and use our own stack
 00FFFA98 0AD90F000928                    jsr             [jmpvec]                                ; call the routine
                              swi_rout3:
 00FFFA9C 1FE000908                       lds             mon_SSAVE                               ; restore stack
 00FFFA9F 07D000930                       tst             mon_retflag
 00FFFAA2 02A009                          bpl             swi_rout4
 00FFFAA4 0ED601                          std             1,s                                                     ; return value in D
 00FFFAA6 078000930                       asl             mon_retflag
 00FFFAA9 02A002                          bpl             swi_rout4
 00FFFAAB 0AF604                          stx             4,s                                                     ; return value in X
                              swi_rout4:
 00FFFAAD 03B                             rti
 
                              ;------------------------------------------------------------------------------
                              ; A breakpoint was struck during program execution, process accordingly.
                              ;------------------------------------------------------------------------------
 
                              processBreakpoint:
 00FFFAAE 0A6E04                          lda             ,s
 00FFFAB0 0B700090F                       sta             mon_CCRSAVE
 00FFFAB3 0EC601                          ldd             1,s
 00FFFAB5 0FD000900                       std             mon_DSAVE
 00FFFAB8 0E6603                          ldb             3,s
 00FFFABA 0F700090E                       stb             mon_DPRSAVE
 00FFFABD 0EC604                          ldd             4,s
 00FFFABF 0FD000902                       std             mon_XSAVE
 00FFFAC2 0EC606                          ldd             6,s
 00FFFAC4 0FD000904                       std             mon_YSAVE
 00FFFAC7 0EC608                          ldd             8,s
 00FFFAC9 0FD000906                       std             mon_USAVE
 00FFFACC 1FF000908                       sts             mon_SSAVE
 00FFFACF 0E660A                          ldb             10,s
 00FFFAD1 0F700090A                       stb             mon_PCSAVE
 00FFFAD4 0EC60B                          ldd             11,s
 00FFFAD6 0FD00090B                       std             mon_PCSAVE+1
 00FFFAD9 1EE80CF3D                       lds             boot_stack,pcr
 00FFFADC 0CCFFFA9C                       ldd             #swi_rout3                      ; setup so monitor can return
 00FFFADF 034006                          pshs    d
 00FFFAE1 08D01F                          bsr             DisarmAllBreakpoints
 00FFFAE3 016FFFDB3                       lbra    DumpRegs
*** warning 1: Long branch within short branch range could be optimized
 
                              xitMonitor:
 00FFFAE6 020039                          bra             ArmAllBreakpoints
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
 
                              swiCallOS:      
 00FFFAE8 033401                          leau    1,u                                                     ; next byte is func number
 00FFFAEA 0E6C00                          ldb             ,u+
 00FFFAEC 0C1019                          cmpb    #NumOSFuncs                     ; check for valid range
 00FFFAEE 122FFFAF4                       lbhi    DisplayErr
*** warning 1: Long branch within short branch range could be optimized
 00FFFAF1 0EF60B                          stu             11,s                                            ; save updateed PC on stack
 00FFFAF3 058                             aslb                                                                    ; compute vector address
 00FFFAF4 08EFFF1DE                       ldx             #OSCallTbl
 00FFFAF7 06DE0F                          tst             b,x                                                     ; check for non-zero vector
 00FFFAF9 027FA1                          beq             swi_rout3
                              osc1:
                              ;       tst             OSSEMA+1                                ; wait for availability
                              ;       beq             osc1
 00FFFAFB 0ADF0F                          jsr             [b,x]                                           ; call the OS routine
                              oscx:
 00FFFAFD 07FEF0011                       clr             OSSEMA+1
 00FFFB00 020F9A                          bra             swi_rout3
 
                              ;------------------------------------------------------------------------------
                              ; DisarmAllBreakpoints, used when entering the monitor.
                              ;------------------------------------------------------------------------------
 
                              DisarmAllBreakpoints:
 00FFFB02 034036                          pshs    d,x,y
 00FFFB04 18E000000                       ldy             #0
 00FFFB07 05F                             clrb
 00FFFB08 08E000830                       ldx             #BreakpointBytes        ; x = breakpoint byte table address
                              disarm2:
 00FFFB0B 0C1A1B                          cmpb    #numBreakpoints         ; safety check
 00FFFB0D 024010                          bhs             disarm1
 00FFFB0F 0F1000811                       cmpb    NumSetBreakpoints
 00FFFB12 02400B                          bhs             disarm1
 00FFFB14 0A6837                          lda             b,x                                                             ; get memory byte
 00FFFB16 0A7B09000820                    sta             [Breakpoints,y]         ; and store it back to memory
 00FFFB1A 031202                          leay    2,y                                                             ; increment for next address
 00FFFB1C 05C                             incb                                                                            ; increment to next byte
 00FFFB1D 020FEC                          bra             disarm2                                         ; loop back
                              disarm1:
 00FFFB1F 0350B6                          puls    d,x,y,pc
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
 
                              ArmAllBreakpoints:
 00FFFB21 034036                          pshs    d,x,y
 00FFFB23 18E000000                       ldy             #0
 00FFFB26 05F                             clrb
 00FFFB27 08E000830                       ldx             #BreakpointBytes        ; x = breakpoint byte table address
                              arm2:
 00FFFB2A 0F1FFFA1B                       cmpb    numBreakpoints          ; safety check
 00FFFB2D 024010                          bhs             arm1
 00FFFB2F 0F1000811                       cmpb    NumSetBreakpoints
 00FFFB32 02400B                          bhs             arm1
 00FFFB34 0A6B09000820                    lda             [Breakpoints,y]         ; load byte at memory address
 00FFFB38 0A7B0D                          sta             b,x                                                             ; save in table
 00FFFB3A 031202                          leay    2,y                                                             ; increment for next address
 00FFFB3C 05C                             incb                                                                            ; increment to next byte
 00FFFB3D 020FEB                          bra             arm2                                                    ; loop back
                              arm1:
 00FFFB3F 0350B6                          puls    d,x,y,pc
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
 
                              ArmBreakpoint:
 00FFFB41 034036                          pshs    d,x,y
 00FFFB43 0B6000811                       lda             NumSetBreakpoints               ; check if too many breakpoints set
 00FFFB46 0B1FFFA1B                       cmpa    numBreakpoints
 00FFFB49 124FFFA99                       lbhs    DisplayErr
*** warning 1: Long branch within short branch range could be optimized
 00FFFB4C 017FFF92B                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 00FFFB4F 017FFF9A9                       lbsr    GetHexNumber                            ; get address parameter
*** warning 1: Long branch within short branch range could be optimized
 00FFFB52 05D                             tstb
 00FFFB53 12BFFFA8F                       lbmi    DisplayErr
*** warning 1: Long branch within short branch range could be optimized
 00FFFB56 0F6000811                       ldb             NumSetBreakpoints               ; bv= number of set breakpoints
 00FFFB59 1BE000912                       ldy             mon_numwka+2                            ; get address
 00FFFB5C 0A6A04                          lda             ,y                                                                      ; get byte at address
 00FFFB5E 08E000830                       ldx             #BreakpointBytes                ; and store byte in a table
 00FFFB61 0A7A05                          sta             b,x                                                                     ; record
 00FFFB63 08603F                          lda             #OPC_SWI                                                ; put a SWI instruction in place
 00FFFB65 0A7A04                          sta             ,y
 00FFFB67 08E000820                       ldx             #Breakpoints                            ; also store the address in a table
 00FFFB6A 058                             aslb                                                                                    ; index for 2 byte values
 00FFFB6B 1AFA05                          sty             b,x
 00FFFB6D 054                             lsrb                                                                                    ; size back to single byte
 00FFFB6E 05C                             incb
 00FFFB6F 0F7000811                       stb             NumSetBreakpoints
 00FFFB72 035036                          puls    d,x,y
 00FFFB74 016FFF7E5                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
 
                              DisarmBreakpoint:
 00FFFB77 034076                          pshs    d,x,y,u
 00FFFB79 017FFF8FE                       lbsr    ignBlanks
*** warning 1: Long branch within short branch range could be optimized
 00FFFB7C 017FFF97C                       lbsr    GetHexNumber
*** warning 1: Long branch within short branch range could be optimized
 00FFFB7F 05D                             tstb
 00FFFB80 12BFFF7D9                       lbmi    Monitor
*** warning 1: Long branch within short branch range could be optimized
 00FFFB83 05F                             clrb
 00FFFB84 05F                             clrb
 00FFFB85 01F001                          tfr             d,x                                                                     ; x = zero too
                              disarm6:
 00FFFB87 0F1FFFA1B                       cmpb    numBreakpoints                  ; no more than this many may be set
 00FFFB8A 024041                          bhs             disarm4
 00FFFB8C 0F1000811                       cmpb    NumSetBreakpoints               ; number actually set
 00FFFB8F 02403C                          bhs             disarm4
 00FFFB91 1AE809000820                    ldy             Breakpoints,x                           ; y = breakpoint address
 00FFFB95 1BC000912                       cmpy    mon_numwka+2                            ; is it the one we want?
 00FFFB98 02602E                          bne             disarm3                                                 ; if not, go increment to next
 00FFFB9A 0BE000912                       ldx             mon_numwka+2                            ; x = memory address
 00FFFB9D 18E000830                       ldy             #BreakpointBytes
 00FFFBA0 0A6A0D                          lda             b,y                                                                     ; get saved byte from table
 00FFFBA2 0A7804                          sta             ,x                                                                      ; set the byte at the memory address
                                      ; compress breakpoint table by removing breakpoint
 00FFFBA4 07A000811                       dec             NumSetBreakpoints               ; set the new number of set breakpoints
 00FFFBA7 034004                          pshs    b                                                                               ; save the position we're removing from
                              disarm7:
 00FFFBA9 05C                             incb                                                                                    ; set index for next byte
 00FFFBAA 0A6A05                          lda             b,y                                                                     ; get byte
 00FFFBAC 05A                             decb                                                                                    ; and store it back
 00FFFBAD 0A7A05                          sta             b,y
 00FFFBAF 05C                             incb                                                                                    ; move to next position
 00FFFBB0 0F1FFFA1B                       cmpb    numBreakpoints                  ; hit end of table?
 00FFFBB3 025FF4                          blo             disarm7
 00FFFBB5 035004                          puls    b                                                                               ; get back position
 00FFFBB7 058                             aslb                                                                                    ; times two for word index
 00FFFBB8 04F                             clra
 00FFFBB9 01F002                          tfr             d,y
 00FFFBBB 054                             lsrb                                                                                    ; back to byte index value
                              disarm8:
 00FFFBBC 0EE202                          ldu             2,y                                                                     ; get next breakpoint address
 00FFFBBE 0EFA01                          stu             ,y++                                                            ; store in current pos, increment
 00FFFBC0 05C                             incb                                                                                    ; increment count
 00FFFBC1 0F1FFFA1B                       cmpb    numBreakpoints                  ; hit end of table?
 00FFFBC4 025FF6                          blo             disarm8
 00FFFBC6 0350F6                          puls    d,x,y,u,pc
                              disarm3:
 00FFFBC8 030002                          leax    2,x
 00FFFBCA 05C                             incb
 00FFFBCB 020FBA                          bra             disarm6
                              disarm4:
 00FFFBCD 035076                          puls    d,x,y,u
 00FFFBCF 016FFF78A                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
 
                              ListBreakpoints:
 00FFFBD2 034016                          pshs    d,x
 00FFFBD4 03F                             swi
 00FFFBD5 003                             fcb             MF_CRLF
 00FFFBD6 08E000000                       ldx             #0
 00FFFBD9 0C6000                          ldb             #0
                              lbrk1:
 00FFFBDB 0F1FFFA1B                       cmpb    numBreakpoints
 00FFFBDE 024016                          bhs             lbrk2
 00FFFBE0 0F1000811                       cmpb    NumSetBreakpoints
 00FFFBE3 024011                          bhs             lbrk2
 00FFFBE5 0EC809000820                    ldd             Breakpoints,x
 00FFFBE9 030002                          leax    2,x
 00FFFBEB 05C                             incb
 00FFFBEC 034004                          pshs    b
 00FFFBEE 03F                             swi
 00FFFBEF 006                             fcb             MF_DisplayWordAsHex
 00FFFBF0 03F                             swi
 00FFFBF1 003                             fcb             MF_CRLF
 00FFFBF2 035004                          puls    b
 00FFFBF4 020FE5                          bra             lbrk1
                              lbrk2:
 00FFFBF6 035016                          puls    d,x
 00FFFBF8 016FFF761                       lbra    Monitor
*** warning 1: Long branch within short branch range could be optimized
                               
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              swi3_rout:
 00FFFBFB 01A010                          sei
 00FFFBFD 0A6E04                          lda             ,s
 00FFFBFF 0B700090F                       sta             mon_CCRSAVE
 00FFFC02 0EC601                          ldd             1,s
 00FFFC04 0FD000900                       std             mon_DSAVE
 00FFFC07 0E6603                          ldb             3,s
 00FFFC09 0F700090E                       stb             mon_DPRSAVE
 00FFFC0C 0EC604                          ldd             4,s
 00FFFC0E 0FD000902                       std             mon_XSAVE
 00FFFC11 0EC606                          ldd             6,s
 00FFFC13 0FD000904                       std             mon_YSAVE
 00FFFC16 0EC608                          ldd             8,s
 00FFFC18 0FD000906                       std             mon_USAVE
 00FFFC1B 1FF000908                       sts             mon_SSAVE
 00FFFC1E 0EC60B                          ldd             11,s
 00FFFC20 0FD00090A                       std             mon_PCSAVE
 00FFFC23 1FF000908                       sts             mon_SSAVE
 00FFFC26 1CE003FFF                       lds             #$3FFF
 00FFFC29 0CCFFFC33                       ldd             #swi3_exit
 00FFFC2C 034006                          pshs    d
 00FFFC2E 01C0EF                          cli
 00FFFC30 07EFFF899                       jmp             DumpRegs
                              swi3_exit:
 00FFFC33 1FE000908                       lds             mon_SSAVE
 00FFFC36 03B                             rti
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              firq_rout:
 00FFFC37 03B                             rti
 
                              irq_rout:
 00FFFC38 04F                             clra
 00FFFC39 01F08B                          tfr             a,dpr
                                      setdp   $000
                              ;       lbsr    SerialIRQ       ; check for recieved character
 00FFFC3B 017FFE855                       lbsr    TimerIRQ
*** warning 1: Long branch within short branch range could be optimized
 
 00FFFC3E 0B6FFC014                       lda             IrqBase                 ; get the IRQ flag byte
 00FFFC41 044                             lsra
 00FFFC42 0BAFFC014                       ora             IrqBase
 00FFFC45 084FE0                          anda    #$FE0
 00FFFC47 0B7FFC014                       sta             IrqBase
 
                              ;       inc             TEXTSCR+54              ; update IRQ live indicator on screen
                              ;       inc             TEXTSCR+$2000+54
                                      
                                      ; flash the cursor
                                      ; only bother to flash the cursor for the task with the IO focus.
 00FFFC4A 0150B6FFFFFFFE0                 lda             COREID
 00FFFC4F 0B1FFC010                       cmpa    IOFocusID
 00FFFC52 02600D                          bne             tr1a
 00FFFC54 096114                          lda             CursorFlash             ; test if we want a flashing cursor
 00FFFC56 027009                          beq             tr1a
 00FFFC58 017FFE69A                       lbsr    CalcScreenLoc   ; compute cursor location in memory
*** warning 1: Long branch within short branch range could be optimized
 00FFFC5B 01F002                          tfr             d,y
 00FFFC5D 06CA09002000                    inc             $2000,y                 ; get color code $2000 higher in memory
                              tr1a:
 00FFFC61 03B                             rti
 
                              ;------------------------------------------------------------------------------
                              ;------------------------------------------------------------------------------
                              nmi_rout:
 00FFFC62 0150F6FFFFFFFE0                 ldb             COREID
 00FFFC67 086049                          lda             #'I'
 00FFFC69 08EE00028                       ldx             #TEXTSCR+40
 00FFFC6C 0A7A0D                          sta             b,x
                              rti_insn:
 00FFFC6E 03B                             rti
 
                              ; Special Register Area
                                      org             $FFFFE0
 
                              ; Interrupt vector table
 
                                      org             $FFFFF0
 00FFFFF0 FFFC6E                          fcw             rti_insn                ; reserved
 00FFFFF2 FFFBFB                          fcw             swi3_rout               ; SWI3
 00FFFFF4 FFFC6E                          fcw             rti_insn                ; SWI2
 00FFFFF6 FFFC37                          fcw             firq_rout               ; FIRQ
 00FFFFF8 FFFC38                          fcw             irq_rout                ; IRQ
 00FFFFFA FFFA49                          fcw             swi_rout                ; SWI
 00FFFFFC FFFC62                          fcw             nmi_rout                ; NMI
 00FFFFFE FFE023                          fcw             start                           ; RST

112 warning(s) in pass 2.

SYMBOL TABLE
      ABD1 02 00FFF5DB      ABD2 02 00FFF5E2      ACIA 00 FFE30100  ACIA_CMD 00 00000002
 ACIA_CTRL 00 00000003 ACIA_CTRL2 00 0000000B ACIA_IRQS 00 00000004   ACIA_RX 00 00000000
 ACIA_STAT 00 00000001   ACIA_TX 00 00000000       ACK 00 00000006      ARM1 02 00FFFB3F
      ARM2 02 00FFFB2A ARMALLBREAKPOINTS 02 00FFFB21 ARMBREAKPOINT 02 00FFFB41 ASCIITOBINDIGIT 02 00FFF5D5
 ASCIITODECDIGIT 02 00FFF5C7 ASCIITOHEXNYBBLE 02 00FFF59F    ASMBUF 00 00000160 BIOS_SCREENS 00 17000000
 BLANKLINE 02 00FFE283 BLKCPYDST 00 00000020 BLKCPYSRC 00 0000001C   BLNKLN1 02 00FFE296
    BOOTPG 02 00FFFA18 BOOT_STACK 02 00FFFA19 BREAKPOINTBYTES 00 00000830 BREAKPOINTFLAG 00 00000810
 BREAKPOINTS 00 00000820        BS 00 00000008 CALCSCREENLOC 02 00FFE2F5       CAN 00 00000018
 CHARCOLOR 00 00000112 CHARINVEC 00 00000804 CHAROUTVEC 00 00000800 CHECKPOINT 02 00FFE140
 CLEARSCREEN 02 00FFE23C CLEARSCREENJMP 02 00FFD300 CMDPROMPT 02 00FFF32C CMDPROMPTJI 00 00000808
 CMDTABLE1 02 00FFF29A CMDTABLE2 02 00FFF2EC COLORCODELOCATION 00 00000014      COLS 00 00000040
 COPYSCREENTOVIRTUALSCREEN 02 00FFE20C COPYVIRTUALSCREENTOSCREEN 02 00FFE1D5    COREID 00 FFFFFFE0        CR 00 0000000D
      CRLF 02 00FFD0D2     CRLF1 02 00FFD0D2    CRLFST 02 00FFE425       CS1 02 00FFE249
       CS2 02 00FFE260     CS2V1 02 00FFE218       CS3 02 00FFE266      CSL1 02 00FFE314
     CTRLC 00 00000003     CTRLH 00 00000008     CTRLI 00 00000009     CTRLJ 00 0000000A
     CTRLK 00 0000000B     CTRLM 00 0000000D     CTRLS 00 00000013     CTRLT 00 00000014
     CTRLX 00 00000018     CTRLZ 00 0000001A CURSORCOL 00 00000111 CURSORFLASH 00 00000114
 CURSORROW 00 00000110     CV2S1 02 00FFE1EA DBGCHECKFORKEY 02 00FFEA90     DBGK1 02 00FFEACB
    DBGK10 02 00FFEB30    DBGK11 02 00FFEB89    DBGK12 02 00FFEB8F    DBGK13 02 00FFEB9B
    DBGK14 02 00FFEBAB    DBGK15 02 00FFEBBA    DBGK16 02 00FFEBC5    DBGK17 02 00FFEBCE
    DBGK18 02 00FFEBD1     DBGK2 02 00FFEA96    DBGK20 02 00FFEAB8    DBGK22 02 00FFEAD4
    DBGK23 02 00FFEAE5    DBGK24 02 00FFEAC6     DBGK3 02 00FFEAE8     DBGK4 02 00FFEAF4
     DBGK5 02 00FFEB00     DBGK7 02 00FFEB10     DBGK8 02 00FFEB16     DBGK9 02 00FFEB2A
 DBGKNOTALT 02 00FFEB93 DBGKNOTCAPSLOCK 02 00FFEB62 DBGKNOTCTRL 02 00FFEB1A DBGKNOTNUMLOCK 02 00FFEB4B
 DBGKNOTRSHIFT 02 00FFEB34 DBGKNOTSCROLLLOCK 02 00FFEB79      DCCR 02 00FFE32C      DCLF 02 00FFE3B6
     DCX10 02 00FFE366     DCX11 02 00FFE376     DCX12 02 00FFE372     DCX13 02 00FFE382
     DCX14 02 00FFE329      DCX3 02 00FFE3A4      DCX4 02 00FFE3B8      DCX5 02 00FFE393
      DCX6 02 00FFE33D      DCX7 02 00FFE339      DCX8 02 00FFE34A      DCX9 02 00FFE357
       DEL 00 0000007F   DELAY3S 02 00FFE1B8      DFL1 02 00FFFA0B      DFL2 02 00FFF9F8
   DISARM1 02 00FFFB1F   DISARM2 02 00FFFB0B   DISARM3 02 00FFFBC8   DISARM4 02 00FFFBCD
   DISARM6 02 00FFFB87   DISARM7 02 00FFFBA9   DISARM8 02 00FFFBBC DISARMALLBREAKPOINTS 02 00FFFB02
 DISARMBREAKPOINT 02 00FFFB77 DISPBYTEASHEX 02 00FFE43A DISPDWORDASHEX 02 00FFE428 DISPLAYCHAR 02 00FFE31C
 DISPLAYERR 02 00FFF5E5 DISPLAYSTRING 02 00FFE3DD DISPLAYSTRINGCRLF 02 00FFE3FD DISPLAYSTRINGDX 02 00FFF5EE
   DISPNYB 02 00FFE452  DISPNYB1 02 00FFE461 DISPWORDASHEX 02 00FFE431    DLY3S1 02 00FFE1BB
    DLY3S2 02 00FFE1BF     DMPM1 02 00FFF7ED     DMPM2 02 00FFF7D8     DMPM3 02 00FFF826
     DMPM4 02 00FFF818     DMPM5 02 00FFF810 DRAM_BASE 00 10000000    DSPJ1B 02 00FFE3EF
     DSPJ2 02 00FFE3EA    DSRETB 02 00FFE3F8 DUMPIOFOCUSLIST 02 00FFF9F5 DUMPMEMORY 02 00FFF7D0
  DUMPREGS 02 00FFF899    DUMRTS 02 00FFE022  EDITMEM1 02 00FFF84D  EDITMEM2 02 00FFF838
  EDITMEM3 02 00FFF86C  EDITMEM4 02 00FFF857  EDITMEM6 02 00FFF863 EDITMEMORY 02 00FFF82C
 ENDOFWORD 02 00FFF41C       EOT 00 00000004       ETB 00 00000017   FARFLAG 00 0000015F
    FILLM1 02 00FFF87F    FILLM2 02 00FFF88F    FILLM3 02 00FFF896 FILLMEMORY 02 00FFF86F
 FIRQ_ROUT 02 00FFFC37 FIRST_CORE 00 00000001   FREEMBX 02 00000002   FREEMSG 02 00000006
   FREETCB 00 0000078A GETBINNUMBER 02 00FFF52B GETDECNUMBER 02 00FFF552 GETHEXNUMBER 02 00FFF4FB
    GETKEY 02 00FFEA92 GETNUMBER 02 00FFF591  GETRANGE 02 00FFF4D2 GETSCREENLOCATION 02 00FFE29D
 GETTWOPARAMS 02 00FFF4B1     GRNG1 02 00FFF4ED      GSL1 02 00FFE2AF    GTBIN1 02 00FFF54E
    GTBIN2 02 00FFF538     GTDC3 02 00FFF5D2    GTDEC1 02 00FFF58D    GTDEC2 02 00FFF55F
     GTHX3 02 00FFF5C4     GTHX5 02 00FFF5AA     GTHX6 02 00FFF5B7    GTHXN1 02 00FFF527
    GTHXN2 02 00FFF508       HC1 02 00FFE2CD   HELPMSG 02 00FFF5FE      HEX2 02 00FFD2CE
      HEX4 02 00FFD2D2 HOMECURSOR 02 00FFE2B3 HOMECURSORJMP 02 00FFD308     I2CW1 02 00FFE4EF
    I2CWR1 02 00FFE51C   I2C_CMD 00 00000004  I2C_CTRL 00 00000002  I2C_INIT 02 00FFE4E3
  I2C_PREH 00 00000001  I2C_PREL 00 00000000   I2C_RXR 00 00000003  I2C_STAT 00 00000004
   I2C_TXR 00 00000003 I2C_WAIT_RX_NACK 02 00FFE51A I2C_WAIT_TIP 02 00FFE4ED I2C_WR_CMD 02 00FFE4F7
 I2C_XMIT1 02 00FFE500      ICC1 02 00FFE3D9      ICC2 02 00FFE3DB      ICR1 02 00FFE3CB
 IGNBLANKS 02 00FFF47A IGNBLANKS1 02 00FFF47A INCCURSORPOS 02 00FFE3BA INCCURSORROW 02 00FFE3C9
      INCH 02 00FFF191     INCH1 02 00FFF1A6     INCH2 02 00FFF193     INCHE 02 00FFF1AF
    INCHEK 02 00FFF1B3   INCHEK1 02 00FFF1C8   INCHEK2 02 00FFF1C5   INCHEK3 02 00FFF1BC
      INIT 02 00FFE0A8     INIT1 02 00FFE0B0     INIT2 02 00FFE0FB INITSERIAL 02 00FFEBEF
 IOFOCUSID 00 00FFC010 IOFOCUSLIST 00 00FFC000 IOFOCUSNDX 00 00000100   IRQBASE 00 00FFC014
   IRQFLAG 00 00FFC012 IRQSOURCE 00 00FFC011  IRQ_ROUT 02 00FFFC38    JMPVEC 00 00000928
  JTC_EXIT 02 00FFF9BA JUMP_TO_CODE 02 00FFF980 KBDBUFFULL 02 00FFEA8D   KBDFIFO 00 00000040
 KBDFIFOALIAS 00 00C00040 KBDHEADRCV 00 00000127  KBDI0002 02 00FFE9C9  KBDI0004 02 00FFEA0E
 KBDITRYAGAIN 02 00FFEA02 KBDRCVCOUNT 02 00FFEA3D KBDTAILRCV 00 00000128     KBGS1 02 00FFE978
     KBGS2 02 00FFE970     KBGS3 02 00FFE961     KEYBD 00 FFE30400  KEYBDACK 00 FFFFCC00
  KEYBDBAD 00 FFFFCB00 KEYBDBLOCK 00 00000126 KEYBDBUFFER 00 FFFFC000 KEYBDCHECKFORKEYDIRECT 02 00FFF18F
 KEYBDCLOSE 02 00FFEBEB  KEYBDCLR 00 FFE30402 KEYBDCONTROLCODES 02 00FFE800 KEYBDECHO 00 FFFFCA00
 KEYBDEXTENDEDCODES 02 00FFE880 KEYBDGETID 02 00FFE99C KEYBDGETSCANCODE 02 00FFE97D KEYBDGETSTATUS 02 00FFE961
 KEYBDHEAD 00 FFFFC800   KEYBDID 00 00000124 KEYBDINIT 02 00FFE9C0  KEYBDIRQ 02 00FFEA4F
 KEYBDLOCKS 00 FFFFCD00 KEYBDOPEN 02 00FFEBEA KEYBDREAD 02 00FFEBEC KEYBDRECVBYTE 02 00FFE900
 KEYBDSEEK 02 00FFEBEE KEYBDSENDBYTE 02 00FFE919 KEYBDSETLED 02 00FFE989 KEYBDTAIL 00 FFFFC900
 KEYBDWAITTX 02 00FFE91F KEYBDWRITE 02 00FFEBED    KEYLED 00 00000122 KEYSTATE1 00 00000120
 KEYSTATE2 00 00000121     KGID1 02 00FFE9B9  KGNOTKBD 02 00FFE9BC      KRB3 02 00FFE905
      KRB4 02 00FFE915    KRCXIT 02 00FFEA4E      KWT1 02 00FFE924      KWT2 02 00FFE935
     LBRK1 02 00FFFBDB     LBRK2 02 00FFFBF6      LEDS 00 FFE60001    LEDXIT 02 00FFEA22
    LETTER 02 00FFD2C1        LF 00 0000000A LISTBREAKPOINTS 02 00FFFBD2 MAX_TASKNO 00 0000003F
   MF_CRLF 00 00000003 MF_DISPLAYBYTEASHEX 00 00000005 MF_DISPLAYSTRING 00 00000004 MF_DISPLAYWORDASHEX 00 00000006
 MF_GETNUMBER 00 0000000C MF_GETRANGE 00 0000000B   MF_INCH 00 00000001 MF_MONITOR 00 00000000
 MF_OSCALL 00 0000000A  MF_OUTCH 00 00000002 MF_RANDOM 00 00000009 MF_SERIALPUTCHAR 00 0000000D
 MF_SHOWSPRITES 00 00000007  MF_SRAND 00 00000008 MILLISECONDS 00 00FFC014      MON1 02 00FFF3BA
 MONARMBREAKPOINT 02 00FFF469 MONDISARMBREAKPOINT 02 00FFF474 MONERRVEC 00 0000080C  MONGETCH 02 00FFF45D
 MONGETNONSPACE 02 00FFF462   MONITOR 02 00FFF35C MON_CCRSAVE 00 0000090F MON_DPRSAVE 00 0000090E
 MON_DSAVE 00 00000900  MON_INIT 00 0000092C MON_NUMWKA 00 00000910 MON_PCSAVE 00 0000090A
    MON_R1 00 00000920    MON_R2 00 00000924  MON_RAND 02 00FFF285 MON_RETFLAG 00 00000930
 MON_RETTAB 02 00FFFA3B MON_ROM_VECS 02 00FFFA1F MON_ROM_VECTAB 02 00FFFA1D MON_SRAND 02 00FFF257
 MON_SRAND1 02 00FFF25A MON_SSAVE 00 00000908 MON_USAVE 00 00000906 MON_VECTB 00 00000880
 MON_XSAVE 00 00000902 MON_YSAVE 00 00000904   MSCOUNT 00 FFFFFFE4 MSGBADKEYBD 02 00FFEA2E
 MSGCHECKSUMERR 02 00FFEF19    MSGERR 02 00FFF5F6 MSGF09STARTING 02 00FFF337 MSGREGHEADINGS 02 00FFF78D
 MSGS19LOADER 02 00FFEF05 MSGSERIALTEST 02 00FFED54 MSGSTARTUP 02 00FFE11F MSGXMNOTRANSMITTER 02 00FFF0B2
 MSGXMTIMEOUT 02 00FFF09E MULTI_SIEVE 02 00FFE156 MULTI_SIEVE1 02 00FFE179 MULTI_SIEVE2 02 00FFE175
 MULTI_SIEVE3 02 00FFE163 MULTI_SIEVE4 02 00FFE18C       NAK 00 00000015     NHEX4 02 00FFF7C7
  NMAILBOX 02 00000004 NMESERIAL 02 00FFED1D   NMIBASE 00 00FFC013  NMI_ROUT 02 00FFFC62
   NMSGBLK 02 00000008 NOTKBDIRQ 02 00FFEA8C  NOTRXINT 02 00FFED1B NOTRXINT1 02 00FFED19
 NOTSERINT 02 00FFED1B NOTTIMERIRQ 02 00FFE4E2 NUMBREAKPOINTS 02 00FFFA1B  NUMFUNCS 00 0000000F
 NUMOSFUNCS 00 00000019 NUMSETBREAKPOINTS 00 00000811   NXBLANK 02 00FFF7CB    ONEKEY 02 00FFD1DC
   OPC_SWI 00 0000003F      OSC1 02 00FFFAFB OSCALLTBL 02 00FFF1DE      OSCX 02 00FFFAFD
    OSSEMA 00 00EF0010     OUTCH 02 00FFF1C9   OUTSEMA 00 00EF0000 PARSECMD1 02 00FFF407
     PCRLF 02 00FFE411     PDATA 02 00FFE41E       PIC 00 FFE3F000    PICPTR 00 00000028
     PRINT 02 00FFE41B      PRNG 00 FFE30600 PROCESSBREAKPOINT 02 00FFFAAE   PROMPT1 02 00FFF3EA
  PROMPT2A 02 00FFF43B   PROMPT3 02 00FFF3D8 PROMPTCLEARSCREEN 02 00FFF455 PROMPTHELP 02 00FFF44D
  PROMPTLN 02 00FFF3D4    PSTRNG 02 00FFE40D     QNDX0 00 00000780     QNDX1 00 00000782
     QNDX2 00 00000784     QNDX3 00 00000786     QNDX4 00 00000788    RAMERR 02 00FFD42C
   RAMERR1 02 00FFD445   RAMTEST 02 00FFD400  RAMTEST1 02 00FFD40D  RAMTEST3 02 00FFD417
  REDIRECT 02 00FFF427 RELEASEIOFOCUS 02 00FFF227 REQUESTIOFOCUS 02 00FFF210     RIOF1 02 00FFF24E
     RIOF2 02 00FFF23D  ROMTORAM 02 00FFE146 ROMTORAM1 02 00FFE14C      ROWS 00 00000020
       RTC 00 FFE30500    RTCBUF 00 00007FC0  RTCR0001 02 00FFE54A  RTCW0001 02 00FFE595
  RTC_READ 02 00FFE524 RTC_RXERR 02 00FFE573 RTC_WRITE 02 00FFE577  RTI_INSN 02 00FFFC6E
 RUNNINGID 00 00FFC013 RUNNINGTCB 06 00000000  S19ABORT 00 0000094A S19ADDCHECK 02 00FFED99
 S19ADDRESS 00 00000940 S19CHECKSUM 00 0000094B S19CLEARADDRESS 02 00FFEDD4    S19GA1 02 00FFEDF6
    S19GA2 02 00FFEE18    S19GB1 02 00FFEDAF    S19GB2 02 00FFEDD0 S19GETADDRESS2 02 00FFEDE1
 S19GETADDRESS3 02 00FFEDF7 S19GETBYTE 02 00FFEDA3    S19IC1 02 00FFED79    S19IC2 02 00FFED78
 S19INPUTCHAR 02 00FFED67     S19L2 02 00FFEF02     S19L3 02 00FFEEAC     S19L4 02 00FFEEA1
    S19LNR 02 00FFEEF5 S19LOADER 02 00FFEE8F S19NEXTRECORD 02 00FFED7F    S19NR1 02 00FFED98
    S19NR2 02 00FFED8C    S19NR3 02 00FFED93    S19P11 02 00FFEE5A    S19P21 02 00FFEE6D
    S19PM1 02 00FFEE43    S19PM2 02 00FFEE37    S19PM3 02 00FFEE1A S19PROCESSS1 02 00FFEE49
 S19PROCESSS2 02 00FFEE5C S19PROCESSS8 02 00FFEE7F S19PROCESSS9 02 00FFEE6F S19PUTMEM 02 00FFEE19
 S19RECLEN 00 00000949 S19RECTYPE 00 00000948 S19SOURCE 00 0000094E S19STARTADDRESS 00 00000944
 S19SUMMARYCHECKSUM 00 0000094C S19XFERADDRESS 00 00000950 SCANNEXTWORD 02 00FFF411 SCREENCOLOR 00 00000113
 SCREENDISPLAYCHAR 02 00FFE31F SCREENLOCATION 00 00000010 SCREENLOCATION2 00 00000018  SCROLLUP 02 00FFE268
    SCRUP1 02 00FFE275    SC_ALT 00 00000011      SC_C 00 00000021 SC_CAPSLOCK 00 00000058
   SC_CTRL 00 00000014    SC_DEL 00 00000071 SC_EXTEND 00 000000E0    SC_F12 00 00000007
  SC_KEYUP 00 000000F0 SC_NUMLOCK 00 00000077 SC_RSHIFT 00 00000059 SC_SCROLLLOCK 00 0000007E
      SC_T 00 0000002C    SC_TAB 00 0000000D      SC_Z 00 0000001A   SEMAABS 00 00001000
 SERHEADRCV 00 00FFC015 SERHEADXMIT 00 00FFC017  SERHZERO 00 00000130 SERIALGETCHAR 02 00FFEC23
 SERIALINIT 02 00FFEBEF SERIALIRQ 02 00FFECCC SERIALOUTPUTTEST 02 00FFED34 SERIALPEEKCHAR 02 00FFEC55
 SERIALPEEKCHARDIRECT 02 00FFEC73 SERIALPUTCHAR 02 00FFEC9A SERIALPUTSTRING 02 00FFED24 SERIALRCVCOUNT 02 00FFECBD
 SERRCVBUF 00 00FFB000 SERRCVXOFF 00 00FFC01A SERRCVXON 00 00FFC019 SERTAILRCV 00 00FFC016
 SERTAILXMIT 00 00FFC018  SERTZERO 00 00000132 SETKEYBOARDECHO 02 00FFF1CD   SETREGA 02 00FFF8E4
   SETREGB 02 00FFF8F3 SETREGCCR 02 00FFF95C   SETREGD 02 00FFF902 SETREGDPR 02 00FFF94D
  SETREGPC 02 00FFF96B   SETREGS 02 00FFF93E   SETREGU 02 00FFF92F   SETREGX 02 00FFF911
   SETREGY 02 00FFF920      SGC2 02 00FFEC3D SGCNOCHARS 02 00FFEC50    SGCXIT 02 00FFEC53
 SHIFTEDSCANCODES 02 00FFE700 SHIFTLEFT5 02 00FFE1CA SHL_NUMWKA 02 00FFF4EE SHOWSPRITES 02 00FFF1D3
     SIEVE 02 00FFE190    SIEVE1 02 00FFE1A8    SIEVE2 02 00FFE1A4    SIEVE3 02 00FFE195
    SIEVE4 02 00FFE1B7     SINI1 02 00FFEC08 SIRQNXTBYTE 02 00FFECD9 SIRQRXFULL 02 00FFED1B
 SKIPDOLLAR 02 00FFF3F9 SKIP_INIT 02 00FFE10D       SOH 00 00000001    SOTST1 02 00FFED3E
   SPC0001 02 00FFECA0  SPCD0001 02 00FFEC95 SPCNOCHARS 02 00FFEC6E    SPCXIT 02 00FFEC71
 SPRITE_CTRL 00 FFE10000 SPRITE_EN 00 000003C0      SPS2 02 00FFED28    SPSXIT 02 00FFED32
    SRCXIT 02 00FFECCB       ST1 02 00FFE0B8      ST10 02 00FFE11B      ST11 02 00FFE060
       ST3 02 00FFE09F       ST6 02 00FFE03C       ST7 02 00FFE046       ST8 02 00FFE046
       ST9 02 00FFE069     START 02 00FFE023    STRPTR 00 00000024 SWI3_EXIT 02 00FFFC33
 SWI3_ROUT 02 00FFFBFB SWICALLOS 02 00FFFAE8 SWINOTBKPT 02 00FFFA66  SWI_ROUT 02 00FFFA49
 SWI_ROUT1 02 00FFFA4E SWI_ROUT2 02 00FFFA5F SWI_ROUT3 02 00FFFA9C SWI_ROUT4 02 00FFFAAD
       TAB 00 00000009 TCB_CURSORCOL 00 00000021 TCB_CURSORROW 00 00000020  TCB_HJCB 00 0000001C
 TCB_HWAITMBX 00 00000022 TCB_IOF_NEXT 00 0000002C TCB_IOF_PREV 00 00000030 TCB_MBQ_NEXT 00 00000024
 TCB_MBQ_PREV 00 00000028 TCB_MMU_MAP 00 00000038 TCB_MSGPTR_D1 00 00000014 TCB_MSGPTR_D2 00 00000018
 TCB_NXTRDY 00 00000000 TCB_NXTTCB 00 00000008 TCB_PRIORITY 00 00000010 TCB_PRVRDY 00 00000004
 TCB_SPSAVE 00 00000034 TCB_STATUS 00 0000001E TCB_TIMEOUT 00 0000000C TEXTCLOSE 02 00FFE238
  TEXTOPEN 02 00FFE237  TEXTREAD 02 00FFE239   TEXTREG 00 FFE07F00   TEXTSCR 00 FFE00000
  TEXTSEEK 02 00FFE23B TEXTWRITE 02 00FFE23A TEXT_COLS 00 00000000 TEXT_CURPOS 00 00000022
 TEXT_ROWS 00 00000001 TIMEOUTLIST 00 0000078C TIMERINIT 02 00FFE468  TIMERIRQ 02 00FFE493
   TIMES10 02 00FFF483      TR1A 02 00FFFC61      UCP1 02 00FFE2F3 UNSHIFTEDSCANCODES 02 00FFE600
 UPDATECURSORPOS 02 00FFE2CF       VIA 00 FFE60000   VIA_ACR 00 0000000B  VIA_DDRA 00 00000003
   VIA_IER 00 0000000E   VIA_IFR 00 0000000D    VIA_PA 00 00000001 VIA_T3CMPH 00 00000015
 VIA_T3CMPL 00 00000014  VIA_T3LH 00 00000013  VIA_T3LL 00 00000012  W10_0001 02 00FFE940
 W300_0001 02 00FFE954  WAIT10MS 02 00FFE939 WAIT300MS 02 00FFE94D    XBLANK 02 00FFD0AF
 XITMONITOR 02 00FFFAE6 XM_CALC_CHECKSUM 02 00FFF0D7 XM_CALC_CRC 02 00FFF0E9 XM_CHECKSUM 00 000009F7
    XM_CRC 00 000009FE   XM_CRC1 02 00FFF0F4   XM_CRC2 02 00FFF150   XM_CRC3 02 00FFF158
   XM_CRC4 02 00FFF13B    XM_CS1 02 00FFF0DB    XM_EOT 02 00FFF07E   XM_FLAG 00 000009F6
    XM_GB1 02 00FFEFA9    XM_GB2 02 00FFEFB7 XM_GETBYTE 02 00FFEFA9   XM_IBUF 00 00000A00
 XM_NOTRANSMITTER 02 00FFF096   XM_OBUF 00 00000A80 XM_OUTBYTEASHEX 02 00FFF170 XM_PACKETNUM 00 000009FA
 XM_PROTOCOL 00 000009F5   XM_RCV1 02 00FFEFDF   XM_RCV2 02 00FFF015   XM_RCV3 02 00FFF05A
   XM_RCV4 02 00FFEFDC   XM_RCV5 02 00FFEFD7 XM_RCV_CHKSUM 02 00FFF052 XM_RCV_NAK 02 00FFEFF4
 XM_RCV_TO1 02 00FFF076 XM_RCV_TO2 02 00FFF074 XM_RECEIVE 02 00FFEFD5 XM_RECEIVESTART 02 00FFEFBA
 XM_RETRY1 02 00FFF085   XM_SEND 02 00FFEF39  XM_SEND1 02 00FFEF58  XM_SEND2 02 00FFEF86
  XM_SEND3 02 00FFEF8D  XM_SEND4 02 00FFEF49  XM_SEND5 02 00FFEF46 XM_SENDSTART 02 00FFEF2C
    XM_SOH 02 00FFEFFA  XM_TIMER 00 00FFC020    XM_TMP 00 000009FC   XM_TMP2 00 000009F8
      XOFF 00 00000013       XON 00 00000011
658 SYMBOLS

3 error(s), 1006 warning(s)
